[{"name": "app.py", "content": "import seaborn as sns\nfrom faicons import icon_svg\nimport matplotlib.pyplot as plt\n# Import data from shared.py\nfrom shared import app_dir, df\nfrom pathlib import Path\nfrom shiny import App, reactive, render, ui\napp_dir = Path(__file__).parent\nfrom pgmcomponents.elements import *\n\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.accordion(\n            ui.accordion_panel(\n                \"Beam Configurations\",\n                ui.input_slider(\"beam_height\", \"Beam Height (mm)\", 0, 60,step=0.1, value=5),\n                ui.input_slider(\"beam_width\",\"Beam Width (mm)\",0,60,value=5,step=0.1),\n            ),\n            open=True\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Mirror Configurations\",\n                ui.input_numeric('mirror_height', \"Mirror Height (mm)\", 20,min=0),\n                ui.input_numeric(\"mirror_length\", \"Mirror Length/Tangential (mm)\", 150, min=0),\n                ui.input_numeric('mirror_width', \"Mirror Width/Sagittal (mm)\", 45, min=0),\n            ),\n            open=False\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Grating Configurations\",\n                ui.input_numeric('grating_height', \"Grating Height (mm)\", 20, min=0),\n                ui.input_numeric('grating_length', \"Grating Length (mm)\", 150, min=0),\n                ui.input_numeric('grating_width', \"Grating Width (mm)\", 45, min=0),\n            ),\n            open=False\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Offsets Configurations\",\n                ui.img(src='pgm.png'),\n                ui.input_numeric('beam_vertical_offset', \"Beam Vertical Offset (mm) $b$\" , -13, min=-100, max=100),\n                ui.input_numeric('mirror_horizontal_offset', \"Mirror Horizontal Offset $a$ (mm)\", 0, min=-100, max=100),\n                ui.input_checkbox(\"calculate_offsets\", \"Calculate Offsets Automatically\", value=True),\n                ui.input_numeric('mirror_vertical_offset', \"Mirror Vertical Offset $c$ (mm)\", 13, min=-100, max=100),\n                ui.input_numeric('mirror_axis_horizontal_offset', \"Mirror Axis Horizontal Offset $h$ (mm)\", 0, min=-100, max=100),\n                ui.input_numeric('mirror_axis_vertical_offset', \"Mirror Axis Vertical Offset $v$ (mm)\", 6.5, min=-100, max=100),\n            ), open=False),\n        title=\"PGM Configurations\"),\n    ui.layout_column_wrap(\n        ui.value_box(\n            \"Energy (eV)\",\n            ui.input_numeric(\"energy\", \"\", 500, min=0, step=10),\n        ),\n        ui.value_box(\n            \"Order\",\n            ui.input_slider(\"order\", \"\", 1, 10, value=1),\n        ),\n        ui.value_box(\n            r'\\(\\mathit{c_{ff}}\\)',\n            ui.input_numeric(\"c_ff\", \"\", 1.4, min=1, max=15, step=0.1),\n        ),\n        ui.value_box(\n            \"Line Density (l/mm)\",\n            ui.input_numeric(\"line_density\", \"\", 400, min=0, max=3600),\n        ),\n        fill=False,\n    ),\n    ui.layout_columns(\n        ui.card(\n            ui.card_header(\"Side View\"),\n            ui.output_plot(\"top_view\"),\n            full_screen=True,\n        ),\n        ui.card(\n            ui.card_header(\"Footprint View\"),\n            ui.output_plot(\"side_view\"),\n            full_screen=True,\n        ),\n    ),\n    ui.include_css(app_dir / \"styles.css\"),\n    ui.tags.head(ui.tags.script(src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"),\n    ui.tags.script(id=\"MathJax-script\", src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\")),\n    title=\"Plane Grating Monochromator Simulator\",\n    fillable=True,\n)\n\n\ndef server(input, output, session):\n    @reactive.calc\n    def filtered_df():\n        filt_df = df[df[\"species\"].isin(input.species())]\n        filt_df = filt_df.loc[filt_df[\"body_mass_g\"] < input.mass()]\n        return filt_df\n\n    @render.text\n    def count():\n        return filtered_df().shape[0]\n\n    @render.text\n    def bill_length():\n        return f\"{filtered_df()['bill_length_mm'].mean():.1f} mm\"\n\n    @render.text\n    def bill_depth():\n        return f\"{filtered_df()['bill_depth_mm'].mean():.1f} mm\"\n\n    @render.plot\n    def top_view():\n        fig, ax = plt.subplots()\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        pgm.beam_height = input.beam_height()\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        pgm.mirror.dimensions = [float(input.mirror_length()),float(input.mirror_width()),float(input.mirror_height())]\n        pgm.grating.dimensions=[float(input.grating_length()),float(input.grating_width()),float(input.grating_height())]\n        pgm.beam_offset=float(input.beam_vertical_offset())\n        pgm.mirror.hoffset=float(input.mirror_horizontal_offset())\n        pgm.mirror.voffset=float(input.mirror_vertical_offset())\n        pgm.mirror.axis_hoffset=float(input.mirror_axis_horizontal_offset())\n        pgm.mirror.axis_voffset=float(input.mirror_axis_vertical_offset())\n        _ = pgm.mirror.compute_corners()\n        _ = pgm.grating.compute_corners()\n        pgm.generate_rays()\n        pgm.grating.compute_angles()\n        pgm.set_theta()\n        pgm.draw_sideview(ax)\n        ax.set_xlim(-250,250)\n        ax.set_ylim(-100,100)\n        ax.set_aspect(\"equal\")\n        return fig\n\n    @render.plot\n    def side_view():\n        fig, ax = plt.subplots()\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        pgm.beam_height = input.beam_height()\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        pgm.mirror.dimensions = [float(input.mirror_length()),float(input.mirror_width()),float(input.mirror_height())]\n        pgm.grating.dimensions=[float(input.grating_length()),float(input.grating_width()),float(input.grating_height())]\n        pgm.beam_offset=float(input.beam_vertical_offset())\n        pgm.mirror.hoffset=float(input.mirror_horizontal_offset())\n        pgm.mirror.voffset=float(input.mirror_vertical_offset())\n        pgm.mirror.axis_hoffset=float(input.mirror_axis_horizontal_offset())\n        pgm.mirror.axis_voffset=float(input.mirror_axis_vertical_offset())\n        _ = pgm.mirror.compute_corners()\n        _ = pgm.grating.compute_corners()\n        pgm.generate_rays()\n        pgm.grating.compute_angles()\n        pgm.set_theta()\n        #pgm.draw_sideview(ax)\n        #ax.set_xlim(-250,250)\n        #ax.set_ylim(-100,100)\n        ax.set_aspect(\"equal\")\n        pgm.draw_topview(ax)\n        #ax.set_xlim(-250,250)\n        #ax.set_ylim(-100,100)\n        #ax.set_aspect(\"equal\")\n        return fig\n\n\napp = App(app_ui, server, static_assets=app_dir / \"static\",)\n", "type": "text"}, {"name": "__init__.py", "content": "", "type": "text"}, {"name": "penguins.csv", "content": "species,island,bill_length_mm,bill_depth_mm,flipper_length_mm,body_mass_g,sex\nAdelie,Torgersen,39.1,18.7,181.0,3750.0,Male\nAdelie,Torgersen,39.5,17.4,186.0,3800.0,Female\nAdelie,Torgersen,40.3,18.0,195.0,3250.0,Female\nAdelie,Torgersen,,,,,\nAdelie,Torgersen,36.7,19.3,193.0,3450.0,Female\nAdelie,Torgersen,39.3,20.6,190.0,3650.0,Male\nAdelie,Torgersen,38.9,17.8,181.0,3625.0,Female\nAdelie,Torgersen,39.2,19.6,195.0,4675.0,Male\nAdelie,Torgersen,34.1,18.1,193.0,3475.0,\nAdelie,Torgersen,42.0,20.2,190.0,4250.0,\nAdelie,Torgersen,37.8,17.1,186.0,3300.0,\nAdelie,Torgersen,37.8,17.3,180.0,3700.0,\nAdelie,Torgersen,41.1,17.6,182.0,3200.0,Female\nAdelie,Torgersen,38.6,21.2,191.0,3800.0,Male\nAdelie,Torgersen,34.6,21.1,198.0,4400.0,Male\nAdelie,Torgersen,36.6,17.8,185.0,3700.0,Female\nAdelie,Torgersen,38.7,19.0,195.0,3450.0,Female\nAdelie,Torgersen,42.5,20.7,197.0,4500.0,Male\nAdelie,Torgersen,34.4,18.4,184.0,3325.0,Female\nAdelie,Torgersen,46.0,21.5,194.0,4200.0,Male\nAdelie,Biscoe,37.8,18.3,174.0,3400.0,Female\nAdelie,Biscoe,37.7,18.7,180.0,3600.0,Male\nAdelie,Biscoe,35.9,19.2,189.0,3800.0,Female\nAdelie,Biscoe,38.2,18.1,185.0,3950.0,Male\nAdelie,Biscoe,38.8,17.2,180.0,3800.0,Male\nAdelie,Biscoe,35.3,18.9,187.0,3800.0,Female\nAdelie,Biscoe,40.6,18.6,183.0,3550.0,Male\nAdelie,Biscoe,40.5,17.9,187.0,3200.0,Female\nAdelie,Biscoe,37.9,18.6,172.0,3150.0,Female\nAdelie,Biscoe,40.5,18.9,180.0,3950.0,Male\nAdelie,Dream,39.5,16.7,178.0,3250.0,Female\nAdelie,Dream,37.2,18.1,178.0,3900.0,Male\nAdelie,Dream,39.5,17.8,188.0,3300.0,Female\nAdelie,Dream,40.9,18.9,184.0,3900.0,Male\nAdelie,Dream,36.4,17.0,195.0,3325.0,Female\nAdelie,Dream,39.2,21.1,196.0,4150.0,Male\nAdelie,Dream,38.8,20.0,190.0,3950.0,Male\nAdelie,Dream,42.2,18.5,180.0,3550.0,Female\nAdelie,Dream,37.6,19.3,181.0,3300.0,Female\nAdelie,Dream,39.8,19.1,184.0,4650.0,Male\nAdelie,Dream,36.5,18.0,182.0,3150.0,Female\nAdelie,Dream,40.8,18.4,195.0,3900.0,Male\nAdelie,Dream,36.0,18.5,186.0,3100.0,Female\nAdelie,Dream,44.1,19.7,196.0,4400.0,Male\nAdelie,Dream,37.0,16.9,185.0,3000.0,Female\nAdelie,Dream,39.6,18.8,190.0,4600.0,Male\nAdelie,Dream,41.1,19.0,182.0,3425.0,Male\nAdelie,Dream,37.5,18.9,179.0,2975.0,\nAdelie,Dream,36.0,17.9,190.0,3450.0,Female\nAdelie,Dream,42.3,21.2,191.0,4150.0,Male\nAdelie,Biscoe,39.6,17.7,186.0,3500.0,Female\nAdelie,Biscoe,40.1,18.9,188.0,4300.0,Male\nAdelie,Biscoe,35.0,17.9,190.0,3450.0,Female\nAdelie,Biscoe,42.0,19.5,200.0,4050.0,Male\nAdelie,Biscoe,34.5,18.1,187.0,2900.0,Female\nAdelie,Biscoe,41.4,18.6,191.0,3700.0,Male\nAdelie,Biscoe,39.0,17.5,186.0,3550.0,Female\nAdelie,Biscoe,40.6,18.8,193.0,3800.0,Male\nAdelie,Biscoe,36.5,16.6,181.0,2850.0,Female\nAdelie,Biscoe,37.6,19.1,194.0,3750.0,Male\nAdelie,Biscoe,35.7,16.9,185.0,3150.0,Female\nAdelie,Biscoe,41.3,21.1,195.0,4400.0,Male\nAdelie,Biscoe,37.6,17.0,185.0,3600.0,Female\nAdelie,Biscoe,41.1,18.2,192.0,4050.0,Male\nAdelie,Biscoe,36.4,17.1,184.0,2850.0,Female\nAdelie,Biscoe,41.6,18.0,192.0,3950.0,Male\nAdelie,Biscoe,35.5,16.2,195.0,3350.0,Female\nAdelie,Biscoe,41.1,19.1,188.0,4100.0,Male\nAdelie,Torgersen,35.9,16.6,190.0,3050.0,Female\nAdelie,Torgersen,41.8,19.4,198.0,4450.0,Male\nAdelie,Torgersen,33.5,19.0,190.0,3600.0,Female\nAdelie,Torgersen,39.7,18.4,190.0,3900.0,Male\nAdelie,Torgersen,39.6,17.2,196.0,3550.0,Female\nAdelie,Torgersen,45.8,18.9,197.0,4150.0,Male\nAdelie,Torgersen,35.5,17.5,190.0,3700.0,Female\nAdelie,Torgersen,42.8,18.5,195.0,4250.0,Male\nAdelie,Torgersen,40.9,16.8,191.0,3700.0,Female\nAdelie,Torgersen,37.2,19.4,184.0,3900.0,Male\nAdelie,Torgersen,36.2,16.1,187.0,3550.0,Female\nAdelie,Torgersen,42.1,19.1,195.0,4000.0,Male\nAdelie,Torgersen,34.6,17.2,189.0,3200.0,Female\nAdelie,Torgersen,42.9,17.6,196.0,4700.0,Male\nAdelie,Torgersen,36.7,18.8,187.0,3800.0,Female\nAdelie,Torgersen,35.1,19.4,193.0,4200.0,Male\nAdelie,Dream,37.3,17.8,191.0,3350.0,Female\nAdelie,Dream,41.3,20.3,194.0,3550.0,Male\nAdelie,Dream,36.3,19.5,190.0,3800.0,Male\nAdelie,Dream,36.9,18.6,189.0,3500.0,Female\nAdelie,Dream,38.3,19.2,189.0,3950.0,Male\nAdelie,Dream,38.9,18.8,190.0,3600.0,Female\nAdelie,Dream,35.7,18.0,202.0,3550.0,Female\nAdelie,Dream,41.1,18.1,205.0,4300.0,Male\nAdelie,Dream,34.0,17.1,185.0,3400.0,Female\nAdelie,Dream,39.6,18.1,186.0,4450.0,Male\nAdelie,Dream,36.2,17.3,187.0,3300.0,Female\nAdelie,Dream,40.8,18.9,208.0,4300.0,Male\nAdelie,Dream,38.1,18.6,190.0,3700.0,Female\nAdelie,Dream,40.3,18.5,196.0,4350.0,Male\nAdelie,Dream,33.1,16.1,178.0,2900.0,Female\nAdelie,Dream,43.2,18.5,192.0,4100.0,Male\nAdelie,Biscoe,35.0,17.9,192.0,3725.0,Female\nAdelie,Biscoe,41.0,20.0,203.0,4725.0,Male\nAdelie,Biscoe,37.7,16.0,183.0,3075.0,Female\nAdelie,Biscoe,37.8,20.0,190.0,4250.0,Male\nAdelie,Biscoe,37.9,18.6,193.0,2925.0,Female\nAdelie,Biscoe,39.7,18.9,184.0,3550.0,Male\nAdelie,Biscoe,38.6,17.2,199.0,3750.0,Female\nAdelie,Biscoe,38.2,20.0,190.0,3900.0,Male\nAdelie,Biscoe,38.1,17.0,181.0,3175.0,Female\nAdelie,Biscoe,43.2,19.0,197.0,4775.0,Male\nAdelie,Biscoe,38.1,16.5,198.0,3825.0,Female\nAdelie,Biscoe,45.6,20.3,191.0,4600.0,Male\nAdelie,Biscoe,39.7,17.7,193.0,3200.0,Female\nAdelie,Biscoe,42.2,19.5,197.0,4275.0,Male\nAdelie,Biscoe,39.6,20.7,191.0,3900.0,Female\nAdelie,Biscoe,42.7,18.3,196.0,4075.0,Male\nAdelie,Torgersen,38.6,17.0,188.0,2900.0,Female\nAdelie,Torgersen,37.3,20.5,199.0,3775.0,Male\nAdelie,Torgersen,35.7,17.0,189.0,3350.0,Female\nAdelie,Torgersen,41.1,18.6,189.0,3325.0,Male\nAdelie,Torgersen,36.2,17.2,187.0,3150.0,Female\nAdelie,Torgersen,37.7,19.8,198.0,3500.0,Male\nAdelie,Torgersen,40.2,17.0,176.0,3450.0,Female\nAdelie,Torgersen,41.4,18.5,202.0,3875.0,Male\nAdelie,Torgersen,35.2,15.9,186.0,3050.0,Female\nAdelie,Torgersen,40.6,19.0,199.0,4000.0,Male\nAdelie,Torgersen,38.8,17.6,191.0,3275.0,Female\nAdelie,Torgersen,41.5,18.3,195.0,4300.0,Male\nAdelie,Torgersen,39.0,17.1,191.0,3050.0,Female\nAdelie,Torgersen,44.1,18.0,210.0,4000.0,Male\nAdelie,Torgersen,38.5,17.9,190.0,3325.0,Female\nAdelie,Torgersen,43.1,19.2,197.0,3500.0,Male\nAdelie,Dream,36.8,18.5,193.0,3500.0,Female\nAdelie,Dream,37.5,18.5,199.0,4475.0,Male\nAdelie,Dream,38.1,17.6,187.0,3425.0,Female\nAdelie,Dream,41.1,17.5,190.0,3900.0,Male\nAdelie,Dream,35.6,17.5,191.0,3175.0,Female\nAdelie,Dream,40.2,20.1,200.0,3975.0,Male\nAdelie,Dream,37.0,16.5,185.0,3400.0,Female\nAdelie,Dream,39.7,17.9,193.0,4250.0,Male\nAdelie,Dream,40.2,17.1,193.0,3400.0,Female\nAdelie,Dream,40.6,17.2,187.0,3475.0,Male\nAdelie,Dream,32.1,15.5,188.0,3050.0,Female\nAdelie,Dream,40.7,17.0,190.0,3725.0,Male\nAdelie,Dream,37.3,16.8,192.0,3000.0,Female\nAdelie,Dream,39.0,18.7,185.0,3650.0,Male\nAdelie,Dream,39.2,18.6,190.0,4250.0,Male\nAdelie,Dream,36.6,18.4,184.0,3475.0,Female\nAdelie,Dream,36.0,17.8,195.0,3450.0,Female\nAdelie,Dream,37.8,18.1,193.0,3750.0,Male\nAdelie,Dream,36.0,17.1,187.0,3700.0,Female\nAdelie,Dream,41.5,18.5,201.0,4000.0,Male\nChinstrap,Dream,46.5,17.9,192.0,3500.0,Female\nChinstrap,Dream,50.0,19.5,196.0,3900.0,Male\nChinstrap,Dream,51.3,19.2,193.0,3650.0,Male\nChinstrap,Dream,45.4,18.7,188.0,3525.0,Female\nChinstrap,Dream,52.7,19.8,197.0,3725.0,Male\nChinstrap,Dream,45.2,17.8,198.0,3950.0,Female\nChinstrap,Dream,46.1,18.2,178.0,3250.0,Female\nChinstrap,Dream,51.3,18.2,197.0,3750.0,Male\nChinstrap,Dream,46.0,18.9,195.0,4150.0,Female\nChinstrap,Dream,51.3,19.9,198.0,3700.0,Male\nChinstrap,Dream,46.6,17.8,193.0,3800.0,Female\nChinstrap,Dream,51.7,20.3,194.0,3775.0,Male\nChinstrap,Dream,47.0,17.3,185.0,3700.0,Female\nChinstrap,Dream,52.0,18.1,201.0,4050.0,Male\nChinstrap,Dream,45.9,17.1,190.0,3575.0,Female\nChinstrap,Dream,50.5,19.6,201.0,4050.0,Male\nChinstrap,Dream,50.3,20.0,197.0,3300.0,Male\nChinstrap,Dream,58.0,17.8,181.0,3700.0,Female\nChinstrap,Dream,46.4,18.6,190.0,3450.0,Female\nChinstrap,Dream,49.2,18.2,195.0,4400.0,Male\nChinstrap,Dream,42.4,17.3,181.0,3600.0,Female\nChinstrap,Dream,48.5,17.5,191.0,3400.0,Male\nChinstrap,Dream,43.2,16.6,187.0,2900.0,Female\nChinstrap,Dream,50.6,19.4,193.0,3800.0,Male\nChinstrap,Dream,46.7,17.9,195.0,3300.0,Female\nChinstrap,Dream,52.0,19.0,197.0,4150.0,Male\nChinstrap,Dream,50.5,18.4,200.0,3400.0,Female\nChinstrap,Dream,49.5,19.0,200.0,3800.0,Male\nChinstrap,Dream,46.4,17.8,191.0,3700.0,Female\nChinstrap,Dream,52.8,20.0,205.0,4550.0,Male\nChinstrap,Dream,40.9,16.6,187.0,3200.0,Female\nChinstrap,Dream,54.2,20.8,201.0,4300.0,Male\nChinstrap,Dream,42.5,16.7,187.0,3350.0,Female\nChinstrap,Dream,51.0,18.8,203.0,4100.0,Male\nChinstrap,Dream,49.7,18.6,195.0,3600.0,Male\nChinstrap,Dream,47.5,16.8,199.0,3900.0,Female\nChinstrap,Dream,47.6,18.3,195.0,3850.0,Female\nChinstrap,Dream,52.0,20.7,210.0,4800.0,Male\nChinstrap,Dream,46.9,16.6,192.0,2700.0,Female\nChinstrap,Dream,53.5,19.9,205.0,4500.0,Male\nChinstrap,Dream,49.0,19.5,210.0,3950.0,Male\nChinstrap,Dream,46.2,17.5,187.0,3650.0,Female\nChinstrap,Dream,50.9,19.1,196.0,3550.0,Male\nChinstrap,Dream,45.5,17.0,196.0,3500.0,Female\nChinstrap,Dream,50.9,17.9,196.0,3675.0,Female\nChinstrap,Dream,50.8,18.5,201.0,4450.0,Male\nChinstrap,Dream,50.1,17.9,190.0,3400.0,Female\nChinstrap,Dream,49.0,19.6,212.0,4300.0,Male\nChinstrap,Dream,51.5,18.7,187.0,3250.0,Male\nChinstrap,Dream,49.8,17.3,198.0,3675.0,Female\nChinstrap,Dream,48.1,16.4,199.0,3325.0,Female\nChinstrap,Dream,51.4,19.0,201.0,3950.0,Male\nChinstrap,Dream,45.7,17.3,193.0,3600.0,Female\nChinstrap,Dream,50.7,19.7,203.0,4050.0,Male\nChinstrap,Dream,42.5,17.3,187.0,3350.0,Female\nChinstrap,Dream,52.2,18.8,197.0,3450.0,Male\nChinstrap,Dream,45.2,16.6,191.0,3250.0,Female\nChinstrap,Dream,49.3,19.9,203.0,4050.0,Male\nChinstrap,Dream,50.2,18.8,202.0,3800.0,Male\nChinstrap,Dream,45.6,19.4,194.0,3525.0,Female\nChinstrap,Dream,51.9,19.5,206.0,3950.0,Male\nChinstrap,Dream,46.8,16.5,189.0,3650.0,Female\nChinstrap,Dream,45.7,17.0,195.0,3650.0,Female\nChinstrap,Dream,55.8,19.8,207.0,4000.0,Male\nChinstrap,Dream,43.5,18.1,202.0,3400.0,Female\nChinstrap,Dream,49.6,18.2,193.0,3775.0,Male\nChinstrap,Dream,50.8,19.0,210.0,4100.0,Male\nChinstrap,Dream,50.2,18.7,198.0,3775.0,Female\nGentoo,Biscoe,46.1,13.2,211.0,4500.0,Female\nGentoo,Biscoe,50.0,16.3,230.0,5700.0,Male\nGentoo,Biscoe,48.7,14.1,210.0,4450.0,Female\nGentoo,Biscoe,50.0,15.2,218.0,5700.0,Male\nGentoo,Biscoe,47.6,14.5,215.0,5400.0,Male\nGentoo,Biscoe,46.5,13.5,210.0,4550.0,Female\nGentoo,Biscoe,45.4,14.6,211.0,4800.0,Female\nGentoo,Biscoe,46.7,15.3,219.0,5200.0,Male\nGentoo,Biscoe,43.3,13.4,209.0,4400.0,Female\nGentoo,Biscoe,46.8,15.4,215.0,5150.0,Male\nGentoo,Biscoe,40.9,13.7,214.0,4650.0,Female\nGentoo,Biscoe,49.0,16.1,216.0,5550.0,Male\nGentoo,Biscoe,45.5,13.7,214.0,4650.0,Female\nGentoo,Biscoe,48.4,14.6,213.0,5850.0,Male\nGentoo,Biscoe,45.8,14.6,210.0,4200.0,Female\nGentoo,Biscoe,49.3,15.7,217.0,5850.0,Male\nGentoo,Biscoe,42.0,13.5,210.0,4150.0,Female\nGentoo,Biscoe,49.2,15.2,221.0,6300.0,Male\nGentoo,Biscoe,46.2,14.5,209.0,4800.0,Female\nGentoo,Biscoe,48.7,15.1,222.0,5350.0,Male\nGentoo,Biscoe,50.2,14.3,218.0,5700.0,Male\nGentoo,Biscoe,45.1,14.5,215.0,5000.0,Female\nGentoo,Biscoe,46.5,14.5,213.0,4400.0,Female\nGentoo,Biscoe,46.3,15.8,215.0,5050.0,Male\nGentoo,Biscoe,42.9,13.1,215.0,5000.0,Female\nGentoo,Biscoe,46.1,15.1,215.0,5100.0,Male\nGentoo,Biscoe,44.5,14.3,216.0,4100.0,\nGentoo,Biscoe,47.8,15.0,215.0,5650.0,Male\nGentoo,Biscoe,48.2,14.3,210.0,4600.0,Female\nGentoo,Biscoe,50.0,15.3,220.0,5550.0,Male\nGentoo,Biscoe,47.3,15.3,222.0,5250.0,Male\nGentoo,Biscoe,42.8,14.2,209.0,4700.0,Female\nGentoo,Biscoe,45.1,14.5,207.0,5050.0,Female\nGentoo,Biscoe,59.6,17.0,230.0,6050.0,Male\nGentoo,Biscoe,49.1,14.8,220.0,5150.0,Female\nGentoo,Biscoe,48.4,16.3,220.0,5400.0,Male\nGentoo,Biscoe,42.6,13.7,213.0,4950.0,Female\nGentoo,Biscoe,44.4,17.3,219.0,5250.0,Male\nGentoo,Biscoe,44.0,13.6,208.0,4350.0,Female\nGentoo,Biscoe,48.7,15.7,208.0,5350.0,Male\nGentoo,Biscoe,42.7,13.7,208.0,3950.0,Female\nGentoo,Biscoe,49.6,16.0,225.0,5700.0,Male\nGentoo,Biscoe,45.3,13.7,210.0,4300.0,Female\nGentoo,Biscoe,49.6,15.0,216.0,4750.0,Male\nGentoo,Biscoe,50.5,15.9,222.0,5550.0,Male\nGentoo,Biscoe,43.6,13.9,217.0,4900.0,Female\nGentoo,Biscoe,45.5,13.9,210.0,4200.0,Female\nGentoo,Biscoe,50.5,15.9,225.0,5400.0,Male\nGentoo,Biscoe,44.9,13.3,213.0,5100.0,Female\nGentoo,Biscoe,45.2,15.8,215.0,5300.0,Male\nGentoo,Biscoe,46.6,14.2,210.0,4850.0,Female\nGentoo,Biscoe,48.5,14.1,220.0,5300.0,Male\nGentoo,Biscoe,45.1,14.4,210.0,4400.0,Female\nGentoo,Biscoe,50.1,15.0,225.0,5000.0,Male\nGentoo,Biscoe,46.5,14.4,217.0,4900.0,Female\nGentoo,Biscoe,45.0,15.4,220.0,5050.0,Male\nGentoo,Biscoe,43.8,13.9,208.0,4300.0,Female\nGentoo,Biscoe,45.5,15.0,220.0,5000.0,Male\nGentoo,Biscoe,43.2,14.5,208.0,4450.0,Female\nGentoo,Biscoe,50.4,15.3,224.0,5550.0,Male\nGentoo,Biscoe,45.3,13.8,208.0,4200.0,Female\nGentoo,Biscoe,46.2,14.9,221.0,5300.0,Male\nGentoo,Biscoe,45.7,13.9,214.0,4400.0,Female\nGentoo,Biscoe,54.3,15.7,231.0,5650.0,Male\nGentoo,Biscoe,45.8,14.2,219.0,4700.0,Female\nGentoo,Biscoe,49.8,16.8,230.0,5700.0,Male\nGentoo,Biscoe,46.2,14.4,214.0,4650.0,\nGentoo,Biscoe,49.5,16.2,229.0,5800.0,Male\nGentoo,Biscoe,43.5,14.2,220.0,4700.0,Female\nGentoo,Biscoe,50.7,15.0,223.0,5550.0,Male\nGentoo,Biscoe,47.7,15.0,216.0,4750.0,Female\nGentoo,Biscoe,46.4,15.6,221.0,5000.0,Male\nGentoo,Biscoe,48.2,15.6,221.0,5100.0,Male\nGentoo,Biscoe,46.5,14.8,217.0,5200.0,Female\nGentoo,Biscoe,46.4,15.0,216.0,4700.0,Female\nGentoo,Biscoe,48.6,16.0,230.0,5800.0,Male\nGentoo,Biscoe,47.5,14.2,209.0,4600.0,Female\nGentoo,Biscoe,51.1,16.3,220.0,6000.0,Male\nGentoo,Biscoe,45.2,13.8,215.0,4750.0,Female\nGentoo,Biscoe,45.2,16.4,223.0,5950.0,Male\nGentoo,Biscoe,49.1,14.5,212.0,4625.0,Female\nGentoo,Biscoe,52.5,15.6,221.0,5450.0,Male\nGentoo,Biscoe,47.4,14.6,212.0,4725.0,Female\nGentoo,Biscoe,50.0,15.9,224.0,5350.0,Male\nGentoo,Biscoe,44.9,13.8,212.0,4750.0,Female\nGentoo,Biscoe,50.8,17.3,228.0,5600.0,Male\nGentoo,Biscoe,43.4,14.4,218.0,4600.0,Female\nGentoo,Biscoe,51.3,14.2,218.0,5300.0,Male\nGentoo,Biscoe,47.5,14.0,212.0,4875.0,Female\nGentoo,Biscoe,52.1,17.0,230.0,5550.0,Male\nGentoo,Biscoe,47.5,15.0,218.0,4950.0,Female\nGentoo,Biscoe,52.2,17.1,228.0,5400.0,Male\nGentoo,Biscoe,45.5,14.5,212.0,4750.0,Female\nGentoo,Biscoe,49.5,16.1,224.0,5650.0,Male\nGentoo,Biscoe,44.5,14.7,214.0,4850.0,Female\nGentoo,Biscoe,50.8,15.7,226.0,5200.0,Male\nGentoo,Biscoe,49.4,15.8,216.0,4925.0,Male\nGentoo,Biscoe,46.9,14.6,222.0,4875.0,Female\nGentoo,Biscoe,48.4,14.4,203.0,4625.0,Female\nGentoo,Biscoe,51.1,16.5,225.0,5250.0,Male\nGentoo,Biscoe,48.5,15.0,219.0,4850.0,Female\nGentoo,Biscoe,55.9,17.0,228.0,5600.0,Male\nGentoo,Biscoe,47.2,15.5,215.0,4975.0,Female\nGentoo,Biscoe,49.1,15.0,228.0,5500.0,Male\nGentoo,Biscoe,47.3,13.8,216.0,4725.0,\nGentoo,Biscoe,46.8,16.1,215.0,5500.0,Male\nGentoo,Biscoe,41.7,14.7,210.0,4700.0,Female\nGentoo,Biscoe,53.4,15.8,219.0,5500.0,Male\nGentoo,Biscoe,43.3,14.0,208.0,4575.0,Female\nGentoo,Biscoe,48.1,15.1,209.0,5500.0,Male\nGentoo,Biscoe,50.5,15.2,216.0,5000.0,Female\nGentoo,Biscoe,49.8,15.9,229.0,5950.0,Male\nGentoo,Biscoe,43.5,15.2,213.0,4650.0,Female\nGentoo,Biscoe,51.5,16.3,230.0,5500.0,Male\nGentoo,Biscoe,46.2,14.1,217.0,4375.0,Female\nGentoo,Biscoe,55.1,16.0,230.0,5850.0,Male\nGentoo,Biscoe,44.5,15.7,217.0,4875.0,\nGentoo,Biscoe,48.8,16.2,222.0,6000.0,Male\nGentoo,Biscoe,47.2,13.7,214.0,4925.0,Female\nGentoo,Biscoe,,,,,\nGentoo,Biscoe,46.8,14.3,215.0,4850.0,Female\nGentoo,Biscoe,50.4,15.7,222.0,5750.0,Male\nGentoo,Biscoe,45.2,14.8,212.0,5200.0,Female\nGentoo,Biscoe,49.9,16.1,213.0,5400.0,Male\n", "type": "text"}, {"name": "requirements.txt", "content": "faicons\nshiny\nseaborn\npandas\n", "type": "text"}, {"name": "shared.py", "content": "from pathlib import Path\n\nimport pandas as pd\n\napp_dir = Path(__file__).parent\ndf = pd.read_csv(app_dir / \"penguins.csv\")\n", "type": "text"}, {"name": "styles.css", "content": ":root {\n  --bslib-sidebar-main-bg: #f8f8f8;\n}", "type": "text"}, {"name": "pgmcomponents\\__init__.py", "content": "", "type": "text"}, {"name": "pgmcomponents\\gui\\__init__.py", "content": "from .gui_widgets import *\nfrom .mplwidgets import *", "type": "text"}, {"name": "pgmcomponents\\gui\\gui_widgets.py", "content": "\"\"\"\ngui_widgets.py\n\nProvides a set of widgets for use in the GUI.\n\nAuthor: Patrick Wang\nEmail: patrick.wang@diamond.ac.uk\nDate: 2023-10-05\nVersion = 0.4.1\n\n\"\"\"\nfrom __future__ import annotations\nimport numpy as np\nimport PySimpleGUI as sg\nfrom pgmcomponents.geometry import calc_beam_size\nimport traceback\nimport matplotlib.pyplot as plt\nfrom pgmcomponents.gui.mplwidgets import draw_figure_w_toolbar\nfrom colorama import Fore, Back, Style, init\nfrom pgmcomponents.elements import *\n\n \n\nclass EPICScontrol(object):\n    \"\"\"\n    A EPICS like control widget.\n\n    Parameters\n    ----------\n    name : str\n        The name of the control.\n    value : float\n        The default value of the control\n    increments: float\n        The default increment value of the control.\n    key : str\n        The key of the control.\n    pgm : PGM\n        The PGM object.\n\n\n    Methods\n    -------\n    up(window)\n        Add increment to value\n    down(window)\n        Subtract increment from value\n    update(window)\n        Update the displayed value of the control.\n    write(window, value, pgm)\n        Write a value to the control.\n    \n    \"\"\"\n\n    def __init__(self, name: str, value: float, increments: float, key: str, pgm=None) -> None:\n        self.name = name\n        self.value = value\n        self.increments = increments\n        self.key = key\n        button_image=b'\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x08\\x06\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\\x00\\x00\\x00\\rIDATx\\x9cc````\\x00\\x00\\x00\\x05\\x00\\x01\\xa5\\xf6E@\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82'\n        \n        self.properties = {'-ENERGY-':'energy', '-CFF-':'cff', '-ORDER-':'grating.order', '-LINE_DENSITY-':'grating.line_density'}\n\n        if pgm is not None:\n            # avoid use of eval with user input (key)\n            self.value = eval(f\"pgm.{self.properties[self.key]}\")\n\n        layout = [[sg.Button(button_text='\u00e2\u20ac\u2022', key=f\"{key}_down\", font=('Arial', 10),image_data=button_image, image_size=(20,30)),\n                   sg.Column([[sg.Input(default_text=self.value, key=f\"{key}\", size=(8,1), font=('Arial', 14),justification='center')],\n                              [sg.HorizontalSeparator()],\n                              [sg.Push(), sg.Input(default_text=increments, key=f\"{key}_inc\", size=(8,1),justification='center'), sg.Push()]]),\n                              sg.Button(button_text='+',font=('Arial', 16),image_data=button_image, image_size=(20,30), auto_size_button=False,key=f\"{key}_up\")],\n                ]\n        self.frame = sg.Frame(title=name, layout=layout, expand_x=True, expand_y=True)\n\n        # don't need return\n        return\n\n    # PGM imported from * import. \n    def up(self, window: sg.Window, values: dict, pgm: PGM) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        window : PySimpleGUI.Window\n            The window object containing the control.\n        values : dict\n            The values of the window.\n        pgm : PGM\n            The PGM object.\n        \n        Returns\n        -------\n        None\n\n        Add increment to value, needs the window object to update the value.\n        \"\"\"\n        if self.key == \"-ORDER-\":\n            try:\n                updated = int(float(values[self.key])) + int(float(values[f\"{self.key}_inc\"]))\n                values[self.key] = updated\n                window[self.key].update(value=updated)\n                window.write_event_value('Update', self.key)\n                print('here!')\n                setattr(pgm.grating, 'order', updated)\n\n            # make exception more specific\n            except Exception as e:\n                sg.Popup('Order should be type int', e)\n            \n        else:\n            updated = round(float(values[self.key]) + float(values[f\"{self.key}_inc\"]), ndigits=3)\n            values[self.key] = updated\n            window[self.key].update(value=updated)\n            window.write_event_value('Update', self.key)\n            setattr(pgm, self.properties[self.key], updated)\n            \n        return\n    \n    def down(self, window: sg.Window, values: dict, pgm: PGM) -> None:\n            \"\"\"\n            Subtract the increment value from the current value of the widget.\n            If the widget is an order widget, the current value is converted to an integer before subtraction.\n            The updated value is then set as the new value of the widget and also updated in the corresponding attribute of the pgm object.\n\n            Parameters\n            ----------\n            window : PySimpleGUI.Window\n                The window object containing the control.\n            values : dict\n                The values of the window.\n            pgm : PGM20\n                The PGM object.\n            \"\"\"\n            if self.key == \"-ORDER-\":\n                try:\n                    updated = int(float(window[self.key].get())) - int(float(window[f\"{self.key}_inc\"].get()))\n                    values[self.key] = updated\n                    window[self.key].update(value=updated)\n                    window.write_event_value('Update', values)\n                    setattr(pgm.grating, 'order', updated)\n\n                except Exception as e:\n                    sg.Popup('Order should be type int', e)\n                \n            elif self.key == \"-CFF-\":\n                print('1st loop')\n                test_update = round(float(window[self.key].get()) - float(window[f\"{self.key}_inc\"].get()), ndigits=3)\n                if test_update <= 1:\n                    print(\"Is condition triggered?\")\n                    sg.Popup('Cff cannot be less than 1')\n                    return\n                else:\n                    updated = round(float(window[self.key].get()) - float(window[f\"{self.key}_inc\"].get()), ndigits=3)\n                    values[self.key] = updated\n                    window[self.key].update(value=updated)\n                    window.write_event_value('Update', values)\n                    setattr(pgm, self.properties[self.key], updated)\n\n\n            else:\n                updated = round(float(window[self.key].get()) - float(window[f\"{self.key}_inc\"].get()), ndigits=3)\n                values[self.key] = updated\n                window[self.key].update(value=updated)\n                window.write_event_value('Update', values)\n                setattr(pgm, self.properties[self.key], updated)\n            return\n    \n    def update(self, window: sg.Window, pgm: PGM) -> None:\n            \"\"\"\n            Update the value of the control.\n\n            Parameters\n            ----------\n\n            window: The window object containing the control.\n            pgm: The program object containing the property to be updated.\n\n            Returns\n            -------\n\n            None\n            \"\"\"\n            window[self.key].update(value=self.value)\n            if self.key == \"-ORDER-\":\n                setattr(pgm.grating, 'order', int(self.value))\n            else:\n                setattr(pgm, self.properties[self.key], float(self.value))\n            return\n    \n    # pgm parameter not used\n    def write(self, window: sg.Window, value: dict, pgm: PGM)-> None:\n        \"\"\"\n        Subroutine to write the values of a known pgm to\n        the window.\n\n        Parameters\n        ----------\n        window : PySimpleGUI.Window\n            The main window.\n        value : float\n            The value to write to the control.\n        pgm : PGM\n            The PGM object.\n\n        \"\"\"\n        window[self.key].update(value=value)\n        setattr(pgm, self.properties[self.key], float(window[self.key].get()))\n    \n        return\n\n    def update_inc(self, window: sg.Window)-> None:\n        \"\"\"\n        Update the increment of the control.\n\n        Parameters\n        ----------\n        window : PySimpleGUI.Window\n            The window object containing the control.\n        \n        Returns\n        -------\n        None\n\n        \"\"\"\n        window[f\"{self.key}_inc\"].update(value=self.increments)\n        return\n    \n    \n\n# Plane_Mirror and Grating undefined here\ndef configuration_popup(title: str, key: str, element: Plane_Mirror | Grating, window)-> dict:\n    \"\"\"\n    Creates a popup window for configuration of Plane_Mirror or Grating.\n\n    Parameters\n    ----------\n    title : str\n        The title of the popup window.\n    key : str\n        The key of the element.\n    element : Plane_Mirror or Grating\n        The element to configure. Either 'Plane_Mirror' or 'Grating'.\n    \n    Returns\n    -------\n    values : dict\n        A dictionary of values for the element.\n\n    \"\"\"\n    length, width, height = element.dimensions\n    sagittal_borders = element.borders[0]\n    tangential_borders = element.borders[2]\n    layout = [[\n    [sg.Column([[sg.Text('Length')], \n                [sg.Text('Width')], \n                [sg.Text('Height')],\n                [sg.HorizontalSeparator()], \n                [sg.Text('Sagittal Borders')], \n                [sg.Text('Tangential Borders')]]),\n\n    sg.Column([[sg.Input(key=f'{key}_length', size=(10,1),default_text=length)], \n               [sg.Input(key=f'{key}_width', size=(10,1), default_text=width)], \n               [sg.Input(key=f'{key}_height', size=(10,1), default_text=height)],\n               [sg.HorizontalSeparator()], \n               [sg.Input(key=f'{key}_sagittal_borders', size=(10,1), default_text=sagittal_borders)], \n               [sg.Input(key=f'{key}_tangential_borders', size=(10,1), default_text=tangential_borders)]])],\n                [sg.Push(), sg.Button('Cancel'), sg.Button('Save')]\n                ]]\n\n    configwindow = sg.Window(title, layout=layout, modal=True)\n    while True:\n        event, values = configwindow.read()\n        if event == sg.WIN_CLOSED or event == 'Cancel':\n            configwindow.close()\n            break\n        elif event == 'Save':\n            configwindow.close()\n            try:\n                element.dimensions = np.array([float(values[f'{key}_length']), \n                                               float(values[f'{key}_width']), \n                                               float(values[f'{key}_height'])])\n            # catch more specific exception\n            except Exception as e:\n                print(e)\n                sg.Popup('Invalid dimensions')\n                continue\n            try:\n                element.borders = np.array([float(values[f'{key}_sagittal_borders']), \n                                            float(values[f'{key}_sagittal_borders']), \n                                            float(values[f'{key}_tangential_borders']), \n                                            float(values[f'{key}_tangential_borders'])])\n            except Exception as e:\n                print(e)\n                sg.Popup('Invalid borders', [[e],[traceback.format_exc()]])\n                continue\n            window.write_event_value('Update', key)\n            break\n            \n    return values if event == 'Save' else None\n\n# don't need to inherit from object. Rename BeamConfig for PascalCase\nclass Beam_Config(object):\n    \"\"\"\n    Provides a class for beam configuration.\n\n    Attributes\n    ----------\n    electron_size_h : float\n        The electron horizontal size RMS.\n    electron_size_v : float\n        The electron vertical size RMS.\n    electron_div_h : float\n        The electron horizontal divergence RMS.\n    electron_div_v : float\n        The electron vertical divergence RMS.\n    id_length : float\n        The length of the insertion device.\n    distance : float\n        The distance from the insertion device to the image plane.\n    num_of_sigmas : float\n        The number of sigmas to include in the beam size calculation.\n    beam_size_h : float\n        The horizontal beam size.\n    beam_size_v : float\n        The vertical beam size.\n\n    Methods\n    -------\n    window(window, pgm)\n        Pops up a window for beam configuration.\n\n    \n    \n    \"\"\"\n\n    def __init__(self):\n        self.electron_size_h = None\n        self.electron_size_v = None\n        self.electron_div_h = None\n        self.electron_div_v = None\n        self.id_length = None\n        self.distance = None\n        self.num_of_sigmas = None\n        self.beam_size_h = None\n        self.beam_size_v = None\n        self.calc = False\n\n        # don't need return\n        return\n\n\n    \n    # This function is very long. Can you refactor into smaller functions.\n    def window(self, pgm: PGM, window: sg.Window)-> None:\n        \"\"\"\n        Pops up a window for beam configuration.\n\n        Parameters\n        ----------\n        window : PySimpleGUI.Window\n            The main window.\n        pgm : PGM\n            The PGM object.\n\n        \"\"\"\n        \n        layout = [[\n            [sg.Column([\n                [sg.Checkbox('Calculate for ID beamline', key='calculate_q', default=True,enable_events=True)],\n                [sg.Text('Electron Horizontal Size RMS (\u00ce\u00bcm)')],\n                [sg.Text('Electron Vertical Size RMS (\u00ce\u00bcm)')],\n                [sg.Text('Electron Divergence Horizontal RMS (\u00ce\u00bcrad)')],\n                [sg.Text('Electron Divergence Vertical RMS (\u00ce\u00bcrad)')],\n                [sg.Text('ID Length (m)')],\n                [sg.Text('Distance from ID (m)')],\n                [sg.Text('Number of sigma to include')],\n                [sg.HorizontalSeparator()],\n                [sg.Text('Beam Horizontal Size (mm)')],\n                [sg.Text('Beam Vertical Size (mm)')],\n            ]),\n            sg.Column([\n                [],\n                [sg.Input(key='electron_size_h', size=(8,1), enable_events=True)],\n                [sg.Input(key='electron_size_v', size=(8,1), enable_events=True)],\n                [sg.Input(key='electron_div_h', size=(8,1), enable_events=True)],\n                [sg.Input(key='electron_div_v', size=(8,1), enable_events=True)],\n                [sg.Input(key='id_length', size=(8,1), enable_events=True)],\n                [sg.Input(key='distance', size=(8,1), enable_events=True)],\n                [sg.Input(key='num_of_sigmas', size=(8,1), enable_events=True)],\n                [sg.HorizontalSeparator()],\n                [sg.Input(key='beam_size_h', size=(8,1),readonly=True)],\n                [sg.Input(key='beam_size_v', size=(8,1),readonly=True)],\n            ], pad=((20,0),(30,0)))],\n            [sg.Push(), sg.Button('Cancel'),sg.Button('Save & Exit') ]\n        ]]\n\n        config_keys = ['electron_size_h', 'electron_size_v', 'electron_div_h', 'electron_div_v', 'id_length', 'distance', 'num_of_sigmas']\n\n        # use def instead of lambda here\n        check_fill = lambda: all([window_beam[key].get() != '' for key in config_keys])\n        window_beam = sg.Window('Beam Configuration', layout=layout, modal=True, finalize=True)\n\n        if self.calc:\n            try:\n                window_beam['electron_size_h'].update(value=self.electron_size_h)\n                window_beam['electron_size_v'].update(value=self.electron_size_v)\n                window_beam['electron_div_h'].update(value=self.electron_div_h)\n                window_beam['electron_div_v'].update(value=self.electron_div_v)\n                window_beam['id_length'].update(value=self.id_length)\n                window_beam['distance'].update(value=self.distance)\n                window_beam['num_of_sigmas'].update(value=self.num_of_sigmas)\n                if pgm.beam_width == self.beam_size_h and pgm.beam_height == self.beam_size_v:\n                    window_beam['beam_size_h'].update(value=self.beam_size_h, readonly=True)\n                    window_beam['beam_size_v'].update(value=self.beam_size_v, readonly=True)\n                else:\n                    raise ValueError('Beam size does not match calculated beam size.')\n            # Can you give a more specific exception and useful error msg here\n            except Exception as e:\n                sg.Popup('Invalid values', e)\n        \n        else:\n            window_beam['electron_size_h'].update(value=self.electron_size_h)\n            window_beam['electron_size_v'].update(value=self.electron_size_v)\n            window_beam['electron_div_h'].update(value=self.electron_div_h)\n            window_beam['electron_div_v'].update(value=self.electron_div_v)\n            window_beam['id_length'].update(value=self.id_length)\n            window_beam['distance'].update(value=self.distance)\n            window_beam['num_of_sigmas'].update(value=self.num_of_sigmas)\n            window_beam['calculate_q'].update(value=False)\n            for key in config_keys:\n                window_beam[key].update(readonly=True)\n            window_beam['beam_size_h'].update(value=pgm.beam_width, readonly=False)\n            window_beam['beam_size_v'].update(value=pgm.beam_height, readonly=False)\n            \n           \n\n        while True:\n            event, values = window_beam.read()\n\n            if event == sg.WIN_CLOSED:\n                break\n\n            elif event == 'calculate_q':\n                if values['calculate_q']:\n                    for key in ['electron_size_h', 'electron_size_v', 'electron_div_h', 'electron_div_v', 'id_length', 'distance', 'num_of_sigmas']:\n                        window_beam[key].update(readonly=False)\n                    window_beam['beam_size_h'].update(readonly=True)\n                    window_beam['beam_size_v'].update(readonly=True)\n                else:\n                    for key in ['electron_size_h', 'electron_size_v', 'electron_div_h', 'electron_div_v', 'id_length', 'distance', 'num_of_sigmas']:\n                        window_beam[key].update(readonly=True)\n                    window_beam['beam_size_h'].update(readonly=False)\n                    window_beam['beam_size_v'].update(readonly=False)\n\n\n            elif event == 'Save & Exit':\n                if values['calculate_q']:\n                    try:\n                        self.electron_size_h = float(values['electron_size_h'])\n                        self.electron_size_v = float(values['electron_size_v'])\n                        self.electron_div_h = float(values['electron_div_h'])\n                        self.electron_div_v = float(values['electron_div_v'])\n                        self.id_length = float(values['id_length'])\n                        self.distance = float(values['distance'])\n                        self.num_of_sigmas = float(values['num_of_sigmas'])\n                        self.calc = True\n                        beam_size_h = calc_beam_size(float(values['electron_size_h']),\n                                                     float(values['electron_div_h']),\n                                                     pgm.wavelength,\n                                                     float(values['distance']),\n                                                     float(values['id_length']),\n                                                     num_of_sigmas=float(values['num_of_sigmas']))\n                        beam_size_v = calc_beam_size(float(values['electron_size_v']),\n                                                    float(values['electron_div_v']),\n                                                    pgm.wavelength,\n                                                    float(values['distance']),\n                                                    float(values['id_length']),\n                                                    num_of_sigmas=float(values['num_of_sigmas']))\n                        self.beam_size_h = beam_size_h\n                        self.beam_size_v = beam_size_v\n                        pgm.beam_width = beam_size_h\n                        pgm.beam_height = beam_size_v\n                        window_beam.close()\n                        window.write_event_value('Update', 'beam')\n                        break\n\n                    except Exception as e:\n                        sg.Popup('Invalid values', [[e],[traceback.format_exc()]])\n                        continue\n                else:\n\n                    try:\n                        pgm.beam_width = float(window_beam['beam_size_h'].get()) if window_beam['beam_size_h'].get() != '' else None\n                        pgm.beam_height = float(window_beam['beam_size_v'].get()) if window_beam['beam_size_v'].get() != '' else None\n                        self.calc = False\n                        self.electron_size_h = float(window_beam['electron_size_h'].get()) if window_beam['electron_size_h'].get() != '' else None\n                        self.electron_size_v = float(window_beam['electron_size_v'].get()) if window_beam['electron_size_v'].get() != '' else None\n                        self.electron_div_h = float(window_beam['electron_div_h'].get()) if window_beam['electron_div_h'].get() != '' else None\n                        self.electron_div_v = float(window_beam['electron_div_v'].get()) if window_beam['electron_div_v'].get() != '' else None\n                        self.id_length = float(window_beam['id_length'].get()) if window_beam['id_length'].get() != '' else None\n                        self.distance = float(window_beam['distance'].get()) if window_beam['distance'].get() != '' else None\n                        self.num_of_sigmas = float(window_beam['num_of_sigmas'].get()) if window_beam['num_of_sigmas'].get() != '' else None\n\n\n                        window_beam.close()\n                        window.write_event_value('Update', 'beam')\n                        break\n\n                        \n                    except ValueError:\n                        if sg.PopupOKCancel(\"Can't convert certain values to float. Discarding problematic values. Continue?\") == 'OK':\n                            self.beam_size_h = values['beam_size_h']\n                            self.beam_size_v = values['beam_size_v']\n                            self.calc = False\n                            self.electron_size_h = ''\n                            self.electron_size_v = ''\n                            self.electron_div_h = ''\n                            self.electron_div_v = ''\n                            self.id_length = ''\n                            self.distance = ''\n                            self.num_of_sigmas = ''\n\n                            window_beam.close()\n                            break\n\n                        else:\n                            continue\n\n                    except Exception as e:\n                        sg.Popup('Invalid values', [[e],[traceback.format_exc()]])\n                        continue\n\n\n\n\n            elif event == 'Cancel':\n                window_beam.close()\n                break\n\n            if check_fill() and values['calculate_q']:\n                try:\n\n                    beam_size_h = calc_beam_size(float(values['electron_size_h']), \n                                                float(values['electron_div_h']), \n                                                pgm.wavelength, \n                                                float(values['distance']),\n                                                float(values['id_length']), \n                                                num_of_sigmas=float(values['num_of_sigmas']))\n                    \n                    \n                    beam_size_v = calc_beam_size(float(values['electron_size_v']),\n                                                float(values['electron_div_v']), \n                                                pgm.wavelength, \n                                                float(values['distance']),\n                                                float(values['id_length']), \n                                                num_of_sigmas=float(values['num_of_sigmas']))\n                    \n                    window_beam['beam_size_h'].update(value=round(beam_size_h, ndigits=3))\n                    window_beam['beam_size_v'].update(value=round(beam_size_v, ndigits=3))\n                    self.beam_size_h = beam_size_h\n                    self.beam_size_v = beam_size_v\n                    pgm.beam_height = beam_size_v\n                    pgm.beam_width = beam_size_h\n                    # don't need pass\n                    pass\n                    \n                except Exception as e:\n                    sg.Popup('Invalid values', [[e],[traceback.format_exc()]])\n                    # dont' need pass\n                    pass\n\n            \n            \n        # don't need return\n        return\n\n\nclass OffsetsControl(object):\n    \"\"\"\n    A class to provide the offsets control widget.\n\n    Attributes\n    ----------\n    values : dict\n        The default values of the control.\n        keys: 'beam_vertical', 'mirror_hoffset', 'mirror_voffset', 'mirror_axis_hoffset', 'mirror_axis_voffset'\n    key : str\n        The key of the control.\n    \n    Methods\n    -------\n    update(window, pgm, )\n    \"\"\"\n\n    def __init__(self, values, key):\n        self.values = values\n\n        self.key = key\n\n        layout = [\n            [sg.Text('Beam Vertical Offset (b):'), sg.Push(), sg.Input(key=f'{key}_beam_vertical', size=(8,1), default_text=values['beam_vertical'], focus=True, enable_events=True )],\n            [sg.Text('Mirror Horizontal Offset (a):'), sg.Push(), sg.Input(key=f'{key}_mirror_horizontal', size=(8,1), default_text=values['mirror_hoffset'])],\n            [sg.HorizontalSeparator()],\n            [sg.Checkbox('Calculate Offsets?', key=f'{key}_calculate', default=True, enable_events=True)],\n            [sg.Text('Mirror Vertical Offset (c):'), sg.Push(), sg.Input(key=f'{key}_mirror_vertical', size=(8,1), default_text=values['mirror_voffset'] ,readonly=True)],\n            [sg.Text('Mirror Axis Horizontal Offset (h):'), sg.Push(), sg.Input(key=f'{key}_mirror_axis_horizontal', size=(8,1), default_text=values['mirror_axis_hoffset'], readonly=False)],\n            [sg.Text('Mirror Axis Vertical Offset (v):'), sg.Push(), sg.Input(key=f'{key}_mirror_axis_vertical', size=(8,1), default_text=values['mirror_axis_voffset'], readonly=True)],\n            ]\n        self.frame = sg.Frame(title='Offsets', layout=layout, expand_x=True, expand_y=True)\n        self._calculate = True\n    \n    def updatepgm(self, window, pgm):\n        \"\"\"\n        Update the values of the PGM object.\n        \"\"\"\n        pgm.beam_offset = -1*float(window[f'{self.key}_beam_vertical'].get())\n        pgm.mirror.hoffset = float(window[f'{self.key}_mirror_horizontal'].get())\n        pgm.mirror.voffset = float(window[f'{self.key}_mirror_vertical'].get())\n        pgm.mirror.axis_hoffset =float(window[f'{self.key}_mirror_axis_horizontal'].get())\n        pgm.mirror.axis_voffset = float(window[f'{self.key}_mirror_axis_vertical'].get())\n        return\n    \n    def calcoffsets(self, window, pgm):\n        \"\"\"\n        Calculate the offsets.\n        \"\"\"\n        # mirror_voffset and mirror_axis_voffset should be in __init__\n        self.mirror_voffset = float(window[f'{self.key}_beam_vertical'].get())\n        self.mirror_axis_voffset = self.mirror_voffset/2\n        pgm.mirror.voffset = self.mirror_voffset\n        pgm.mirror.axis_voffset = self.mirror_axis_voffset\n        window['-OFFSETS-_mirror_vertical'].update(value=self.mirror_voffset)\n        window['-OFFSETS-_mirror_axis_vertical'].update(value=self.mirror_axis_voffset)\n    \n    @property\n    def calculate(self):\n        return self._calculate\n    \n    @calculate.setter\n    def calculate(self, value):\n        self._calculate = value\n        return\n    \n    def write(self, window, values, calcq=True):\n        \"\"\"\n        Write values to the control.\n        \"\"\"\n        window[f'{self.key}_beam_vertical'].update(value=values['beam_vertical'])\n        window[f'{self.key}_mirror_horizontal'].update(value=values['mirror_hoffset'])\n        window[f'{self.key}_mirror_vertical'].update(value=values['mirror_voffset'])\n        window[f'{self.key}_mirror_axis_horizontal'].update(value=values['mirror_axis_hoffset'])\n        window[f'{self.key}_mirror_axis_vertical'].update(value=values['mirror_axis_voffset'])\n        window[f'{self.key}_calculate'].update(value=calcq)\n\n        return\n\n# rename TopViewWidget\nclass Topview_Widget(object):\n    \"\"\"\n    A class to supply the GUI widget for a top-view\n    footprint plot of a given PGM.\n    \n    \"\"\"\n    def __init__(self, pgm, key='-TOPVIEW-', size=(800,400)):\n        \n        self._pgm = pgm\n        self._key = key\n        self._size = size\n        self.make_canvas()\n    \n    @property\n    def pgm(self):\n        return self._pgm\n    \n    @pgm.setter\n    def pgm(self, value):\n        self._pgm = value\n        return\n    \n    @property\n    def key(self):\n        return self._key\n    \n    @key.setter\n    def key(self, value):\n        self._key = value\n        self.make_canvas()\n        return\n    \n    @property\n    def size(self):\n        return self._size\n    \n    @size.setter\n    def size(self, value):\n        self._size = value\n        self.make_canvas()\n        return\n    \n    @property\n    def frame(self):\n        return sg.Frame(title='Footprint View', layout=[[self.canvas]], element_justification='center')\n    \n\n    def make_canvas(self):\n        mirror_corners = self.pgm.mirror_corners()\n        grating_corners = self.pgm.grating_corners()\n        top_right_x = grating_corners[2][1] + self.pgm.mirror._width()*0.5 + self.pgm.grating._width()*0.5\n        top_right_z = grating_corners[2][0]\n        self.canvas = sg.Graph(canvas_size=self.size, \n                               enable_events=True,\n                               graph_bottom_left=self.pgm.mirror_corners()[-1], \n                               graph_top_right=[top_right_z, top_right_x], \n                               key=self.key, \n                               background_color='white',\n                               right_click_menu=[[''],['Reset', 'Save As...']],\n                               motion_events=True)\n        print('grating corners:', grating_corners)\n        print('mirror corners:', mirror_corners)\n        print('graph bottom left:', self.pgm.mirror_corners()[-1])\n        print('graph top right:', [top_right_z, top_right_x])\n    def draw(self):\n        mirror_corners = self.pgm.mirror_corners()\n        grating_corners = self.pgm.grating_corners()\n        grating_corners = np.array(grating_corners) + np.array([0, 0.5*(self.pgm.mirror._width() + self.pgm.grating._width())])\n        top_left = np.array(mirror_corners[2])\n        bottom_right = [mirror_corners[0][0], mirror_corners[0][1]]\n\n        print('rectangle:', top_left, bottom_right)\n        self.canvas.draw_rectangle(top_left, bottom_right, line_color='black', line_width=2, fill_color='red')\n        self.canvas.draw_rectangle(grating_corners[1], grating_corners[-1], line_color='black', line_width=2, fill_color='blue')\n        pass\n\n    def corners(self)-> tuple:\n        \"\"\"\n        Returns the corners of the mirror, grating and the canvas.\n        \"\"\"\n        mirror_corners = self.pgm.mirror_corners()\n        grating_corners = self.pgm.grating_corners()\n        top_right_x = grating_corners[2][1] + self.pgm.mirror._width()*0.5 + self.pgm.grating._width()*0.5\n        top_right_z = grating_corners[2][0]\n        return mirror_corners, grating_corners, [top_right_z, top_right_x]\n\nclass Sideview_Widget(object):\n\n    def __init__(self, pgm, key='-SIDEVIEW-', size=(800, 400)):\n        self._pgm = pgm\n        self._key = key\n        self._size = size\n        self.make_canvas()\n    \n    @property\n    def pgm(self):\n        return self._pgm\n    \n    @pgm.setter\n    def pgm(self, value):\n        self._pgm = value\n        return\n    \n    @property\n    def key(self):\n        return self._key\n    \n    @key.setter\n    def key(self, value):\n        self._key = value\n        self.make_canvas()\n        return\n    \n    @property\n    def size(self):\n        return self._size\n    \n    @size.setter\n    def size(self, value):\n        self._size = value\n        self.make_canvas()\n        return\n    \n    @property\n    def frame(self):\n        return sg.Frame(title='Side View', layout=[[self.canvas], [self.control_canvas]], element_justification='center')\n    \n\n    def make_canvas(self):\n        self.canvas = sg.Canvas(size = self.size, key = self.key, background_color='white', right_click_menu=[[''],['Reset', 'Save As...']])\n        self.control_canvas = sg.Canvas(key=f'{self.key}_control')\n    \n\n    \n\n    def draw(self, window):\n        pass\n        \ndef main():\n    beam = Beam_Config()\n    mirror = Plane_Mirror()\n    grating = Grating()\n    pgm=PGM(mirror=mirror, grating=grating)\n    pgm.beam_height = 5.\n    pgm.beam_width = 5.\n    pgm.generate_rays()\n    _,_ = pgm.grating.compute_angles()\n    pgm.set_theta()\n    \n    offsetscontrol = OffsetsControl(pgm.values(), 'offsets_test')\n    topview = Topview_Widget(pgm, key='topview_test')\n    #sideview = Sideview_Widget(pgm, key='sideview_test')\n    test = EPICScontrol('Energy (eV)', 1100, 10, 'test')\n    window = sg.Window('EPICS Control', layout=[[test.frame], \n                                                [sg.Button('OK'), \n                                                 sg.Button('Cancel'),\n                                                 sg.Button('Beam Config')],\n                                                 [offsetscontrol.frame],\n                                                 [topview.frame]\n                                                 ])\n    window.Finalize()\n    topview.draw()\n    \n    while True:\n        # values not used\n        event, values = window.read()\n        print(event, values)\n        if event == sg.WIN_CLOSED:\n            break\n        elif event == 'OK':\n            configuration_popup('Mirror Configuration', 'test', mirror)\n            \n        \n        elif event == 'test_up':\n            test.up(window)\n\n        elif event == 'test_down':\n            test.down(window)\n\n        elif event == 'Cancel':\n            break\n\n        elif event == 'Beam Config':\n            beam.window(pgm)\n        \n\ndef update_and_draw(window, \n                    pgm, \n                    values, \n                    topview_widget, \n                    sideview_widget, \n                    energy_control, \n                    cff_control, \n                    order_control, \n                    line_density_control,\n                    offsets_control):\n    \"\"\"\n    Update the values of the PGM object and draw the\n    topview and sideview widgets.\n    \n    Parameters\n    ----------\n    window : PySimpleGUI.Window\n        The main window.\n    pgm : PGM\n        The PGM object.\n    values : dict\n        The values of the controls.\n    topview_widget : Topview_Widget\n        The topview widget.\n    sideview_widget : Sideview_Widget\n        The sideview widget.\n    energy_control : EPICScontrol\n        The energy control.\n    cff_control : EPICScontrol\n        The cff control.\n    order_control : EPICScontrol\n        The order control.\n    line_density_control : EPICScontrol\n        The line density control.\n\n    \"\"\"\n\n\n    energy_input = float(values['-ENERGY-'])\n    cff_input = float(values['-CFF-'])\n    order_input = int(values['-ORDER-'])\n    line_density_input = float(values['-LINE_DENSITY-'])\n    try:\n        val = float(energy_input)\n        if val > 0:\n            energy_control.write(window, float(energy_input), pgm)\n            # can remove all of these pass statements\n            pass\n        else:\n            sg.Popup('Error', 'Energy must be a positive number')\n            energy_control.write(window, 250, pgm)\n            pass\n    except ValueError:\n        sg.Popup('Error', 'Energy must be a positive number')\n        energy_control.write(window, 250, pgm)\n        pass\n\n    try:\n        val = float(cff_input)\n        if val > 0:\n            cff_control.write(window, float(cff_input), pgm)\n            pass\n        else:\n            sg.Popup('Error', 'CFF must be a positive number')\n            cff_control.write(window, 2, pgm)\n            pass\n    except ValueError:\n        sg.Popup('Error', 'CFF must be a positive number')\n        cff_control.write(window, 2, pgm)\n        pass\n\n    try:\n        val = int(order_input)\n        if val >= 0:\n            order_control.write(window, int(order_input), pgm)\n            pass\n        else:\n            sg.Popup('Error', 'Order must be a positive integer')\n            order_control.write(window, 1, pgm)\n            pass\n    except ValueError:\n        sg.Popup('Error', 'Order must be a positive integer')\n        order_control.write(window, 1, pgm)\n        pass\n\n    \n    try:\n        val = float(line_density_input)\n        if val > 0:\n            line_density_control.write(window, float(line_density_input), pgm)\n            pass\n        else:\n            sg.Popup('Error', 'Line density must be a positive number')\n            line_density_control.write(window, 400, pgm)\n            pass\n    except ValueError:\n        sg.Popup('Error', 'Line density must be a positive number')\n        line_density_control.write(window, 400, pgm)\n        pass\n\n    pgm.energy = float(values['-ENERGY-']) if float(values['-ENERGY-']) > 0 else 1\n    pgm.cff = float(values['-CFF-']) if float(values['-CFF-']) > 0 else 1\n    pgm.mirror.order = int(values['-ORDER-']) if int(values['-ORDER-']) >= 0 else 1\n    pgm.grating.line_density = float(values['-LINE_DENSITY-']) if float(values['-LINE_DENSITY-']) > 0 else 1\n    \n    offsets_control.updatepgm(window, pgm)\n    if values['-OFFSETS-_calculate']:\n        offsets_control.calcoffsets(window, pgm)\n    else:\n        offsets_control.updatepgm(window, pgm)\n\n    try:\n        # can just call functions without assigning to variables\n        _,_ = pgm.grating.compute_angles()\n        _=pgm.mirror.compute_corners()\n        _=pgm.grating.compute_corners()\n        pgm.set_theta()\n        _=pgm.mirror.compute_corners()\n    except Exception as e:\n        sg.Popup('Error', e)\n        return\n        \n    topview_widget.draw(window)\n    sideview_widget.draw(window)\n\n    pass\n\n\ndef initial_draw(window: sg.Window, \n                 pgm:PGM, \n                 topview_widget:Topview_Widget, \n                 sideview_widget:Sideview_Widget, \n                 offsets_control:OffsetsControl)-> None:\n    \"\"\"\n    Draw the topview and sideview widgets.\n    \n    Parameters\n    ----------\n    window : PySimpleGUI.Window\n        The main window.\n    pgm : PGM\n        The PGM object.\n    topview_widget : Topview_Widget\n        The topview widget.\n    sideview_widget : Sideview_Widget\n        The sideview widget.\n    offsets_control : OffsetsControl\n        The offsets control widget.\n    \"\"\"\n    pgm.generate_rays()\n    offsets_control.calcoffsets(window, pgm)\n    offsets_control.updatepgm(window, pgm)\n    _,_ = pgm.grating.compute_angles()\n    _=pgm.mirror.compute_corners()\n    _=pgm.grating.compute_corners()\n    pgm.set_theta()\n    _=pgm.mirror.compute_corners()\n\n    topview_widget.draw(window)\n    sideview_widget.draw(window)\n    return\n\ndef maketable(pgm: PGM)-> sg.Table:\n    \"\"\"\n    Returns a PySimpleGUI table for the PGM parameters.\n\n    Parameters\n    ----------\n    pgm : PGM\n        The PGM object.\n\n    Returns\n    -------\n    table : PySimpleGUI.Table\n        The table.\n    \"\"\"\n    columns = (\"Parameter\", \"Value\")\n    parameters = [\"Order\", \n                \"LD (l/mm)\",\n                \"Energy (eV)\",\n                \"Cff\",\n                \"b (mm)\",\n                \"a (mm)\",\n                \"c (mm)\",\n                \"h (mm)\",\n                \"v (mm)\",\n                \"alpha (deg)\",\n                \"beta(deg)\",\n                \"theta (deg)\"]\n    values = [pgm.grating.order,\n              pgm.grating.line_density,\n              pgm.energy,\n              pgm.grating.cff,\n              pgm.beam_offset,\n              pgm.mirror.hoffset,\n              pgm.mirror.voffset,\n              pgm.mirror.axis_hoffset,\n              pgm.mirror.axis_voffset,\n              pgm.grating.alpha,\n              pgm.grating.beta,\n              pgm.mirror.theta]\n    data = [(param, round(val, ndigits=3)) for param, val in zip(parameters, values)]\n    table = sg.Table(values=data, headings=columns, auto_size_columns=False, justification='left', num_rows=12, key='-TABLE-')\n    return table\n\n\nclass ParamTable():\n    \"\"\"\n    A class to provide a table of PGM parameters.\n    \"\"\"\n    def __init__(self, pgm: PGM, key: str):\n        self.pgm = pgm\n        self.key = key\n        self.table = maketable(self.pgm)\n        self.frame = sg.Frame(title='PGM Parameters', layout=[[self.table]])\n    \n    def update(self, window: sg.Window)-> None:\n        \"\"\" \n        Update the table.\n        \"\"\"\n        self.table.update(values=maketable(self.pgm).Values)\n        return\n\nclass ParamTable():\n    \"\"\"\n    A class to provide a table of PGM parameters.\n    \"\"\"\n    def __init__(self, pgm: PGM, key: str):\n        self.pgm = pgm\n        self.key = key\n        self.table = maketable(self.pgm)\n        self.frame = sg.Frame(title='PGM Parameters', layout=[[self.table]])\n    \n    def update(self, window: sg.Window)-> None:\n        \"\"\" \n        Update the table.\n        \"\"\"\n        self.table.update(values=maketable(self.pgm).Values)\n        return\n\n\nclass ZoomWidget(object):\n    \"\"\"\n    A class to provide a widget to configure\n    plotting ranges.\n    \"\"\"\n\n    def __init__(self, pgm: PGM, key: str)-> None:\n        self.pgm = pgm\n        self.key = key\n        layout = [[sg.Text(\"z min\"),sg.Input(key=\"-ZMIN-\", size=(8,8)),\n                  sg.Text(\"z max\"),sg.Input(key=\"-ZMAX-\", size=(8,8)),\n                  sg.Text(\"x min\"),sg.Input(key=\"-XMIN-\", size=(8,8)),\n                  sg.Text(\"x max\"),sg.Input(key=\"-XMAX-\", size=(8,8))]]\n        self.frame = sg.Frame(layout=layout, title='Zoom', expand_x=True)\n    \n\n\nif __name__ == \"__main__\":\n    main()\n", "type": "text"}, {"name": "pgmcomponents\\gui\\main.py", "content": "\"\"\"\nMain program for PGM simulation GUI.\n\n\nAuthor: Patrick Wang, 2023\nEmail: patrick.wang@diamond.ac.uk\nVersion = 0.4.1\n\n\"\"\"\n\nimport PySimpleGUI as sg\nfrom PySimpleGUI.PySimpleGUI import _upgrade_gui as upgrade\nfrom colorama import Fore\nimport numpy as np\nimport dill as pickle\n\nimport matplotlib.pyplot as plt\nfrom pgmcomponents.elements import *\nfrom pgmcomponents.geometry import *\nfrom pgmcomponents.gui import *\n\n\n# main function is more of a long script. Better to break down into smaller chunks of code in methods\ndef main():\n\n    version = sg.__version__\n    version_str = version.split('.')\n    print(Fore.GREEN,\"Welcome to pgm-gui!\", Fore.RESET)\n    print(Fore.YELLOW,\"Checking PySimpleGUI version...\", Fore.RESET)\n    if len(version_str) <= 3:\n        print(Fore.RED + \"PySimpleGUI is not up-to-date, see popup!\" + Fore.RESET)\n        response = sg.PopupOKCancel(f\"Your PySimpleGUI version is {version}\\nThis program requires version the github dev version.\\n Press OK to begin upgrade sequence.\")\n        if response == 'OK':\n            _ = upgrade()\n            sg.Popup('Upgrade complete, please restart program.')\n            exit()\n        else:\n            sg.Popup('Proceeding, but program will potentially break!')\n    print('Initialising PGM...')\n    mirror = Plane_Mirror(hoffset=50, voffset=0, dimensions=np.array([450,70,50]))\n    grating = Grating(line_density=400, order = 1, cff=2., energy=250, dimensions=np.array([150,40,50]))\n    pgm = PGM(mirror=mirror, grating=grating)\n    pgm.beam_height= 5\n    pgm.beam_width = 5\n    pgm.beam_offset = 20\n\n    menu = [['File', ['Open workspace', 'Save workspace', 'Exit']],\n            ['Export', ['Export Mirror', 'Export Grating', 'Export Beams', 'Export All']],\n            ['Help', 'About...'], ]\n    print(Fore.CYAN,\"Initialising control widgets...\", Fore.RESET)\n    energy_control = EPICScontrol('Energy (eV)', 250.,10., '-ENERGY-', pgm=pgm)\n    cff_control = EPICScontrol(u'Cff', 2.,0.1, '-CFF-',pgm=pgm)\n    order_control = EPICScontrol('Order', 1,1, '-ORDER-',pgm=pgm)\n    line_density_control = EPICScontrol('Line Density (l/mm)', 400,100, '-LINE_DENSITY-',pgm=pgm)\n    offset_defaults = pgm.values()\n    offset_defaults['beam_vertical'] = 20\n    offsets_control = OffsetsControl(offset_defaults, '-OFFSETS-')\n    up_events = {'-ENERGY-_up':energy_control, '-CFF-_up':cff_control, '-ORDER-_up':order_control, '-LINE_DENSITY-_up':line_density_control}\n    down_events = {'-ENERGY-_down':energy_control, '-CFF-_down':cff_control, '-ORDER-_down':order_control, '-LINE_DENSITY-_down':line_density_control}\n    print(Fore.GREEN, \"Control widgets initialised!\", Fore.RESET)\n\n    print(Fore.CYAN, \"Initialising widgets...\", Fore.RESET)\n\n    beam_config = Beam_Config()\n    topview_widget = Topview_Widget(pgm, size=(1000,500))\n    sideview_widget = Sideview_Widget(pgm, size=(1600,400))\n\n    config_frame = sg.Frame('Config', [[\n        sg.Button('Beam'), sg.Button('Mirror'), sg.Button('Grating')\n    ]], expand_x=True)\n    table = ParamTable(pgm, \"-TABLE-\")\n    zoom_config = ZoomWidget(pgm, \"ZOOM\")\n\n\n    layout = [[\n        [sg.Menu(menu)],\n        [sg.Column([\n            [energy_control.frame, order_control.frame],\n            [cff_control.frame, line_density_control.frame],\n            [config_frame], [offsets_control.frame, table.frame], [zoom_config.frame],[sg.B('Update')]\n        ]), \n        sg.Column([\n            [topview_widget.frame]\n        ])\n        ],\n        sg.Column([\n            [sideview_widget.frame]\n        ])\n        ]]\n    print(Fore.GREEN, \"Widgets initialised!\", Fore.RESET)\n    print(Fore.CYAN, \"Initialising window...\", Fore.RESET)\n    window = sg.Window('PGM Simulation', layout, finalize=True,icon='icon.png', resizable=True, return_keyboard_events=True)\n    print(Fore.GREEN, \"Window initialised!\", Fore.RESET)\n\n    _,_ = pgm.grating.compute_angles()\n    _=pgm.mirror.compute_corners()\n    _=pgm.grating.compute_corners()\n    pgm.set_theta()\n    _=pgm.mirror.compute_corners()\n\n    # can remove commented out code\n\n    #pgm.generate_rays()\n            \n    #topview_widget.draw(window)\n    #sideview_widget.draw(window)\n    _=pgm.mirror.compute_corners()\n    _=pgm.grating.compute_corners()\n    #topview_widget.draw(window)\n    #sideview_widget.draw(window)\n    pgm.generate_rays()\n    \n\n    initial_draw(window, pgm, topview_widget, sideview_widget, offsets_control)\n    print(\"Initialisation complete!\")\n    update_events = [\n        '-ENERGY-_up', '-ENERGY-_down', '-CFF-_up', '-CFF-_down', '-ORDER-_up', '-ORDER-_down', '-LINE_DENSITY-_up', '-LINE_DENSITY-_down', '-OFFSETS-_beam_vertical', '-OFFSETS-_mirror_vertical', '-OFFSETS-_mirror_axis_vertical', '-OFFSETS-_calculate',\n        \"Return:36\", \"KP_Enter:104\"\n    ]\n    \n    while True:\n        event, values = window.read()\n        print(Fore.LIGHTYELLOW_EX, 'Event:',Fore.RESET, event)\n        if event in update_events:\n            update_and_draw(window, pgm, values, topview_widget, sideview_widget, energy_control, cff_control, order_control, line_density_control, offsets_control)\n            table.update(window)\n\n        if window.find_element_with_focus() is None:\n            pass\n\n        else:\n            window.find_element_with_focus().set_focus(force=True)\n\n\n        \n\n\n        if event == sg.WIN_CLOSED or event == 'Exit':\n            break\n\n        elif event in up_events.keys():\n            up_events[event].up(window, values, pgm)\n            pass\n\n        elif event in down_events.keys():\n            down_events[event].down(window, values, pgm)\n\n        if event == 'Update':\n            table.update(window)\n            update_and_draw(window, pgm, values, topview_widget, sideview_widget, energy_control, cff_control, order_control, line_density_control, offsets_control)\n\n\n        elif event == 'Beam':\n            beam_config.window(pgm, window)\n        elif event == 'Mirror':\n            configuration_popup('Mirror Configuration', '-MIRROR-', pgm.mirror, window)\n        elif event == 'Grating':\n            configuration_popup('Grating Configuration', '-GRATING-', pgm.grating, window)\n        elif event == 'Export Mirror':\n            pass\n        elif event == 'Export Grating':\n            pass\n        elif event == 'Export Beams':\n            pass\n        elif event == 'Export All':\n            pass\n        elif event == 'About...':\n            sg.Popup(*['PGM Simulation', 'version 0.2', 'Patrick Wang'], 'About')\n        \n        elif event == '-OFFSETS-_calculate':\n            if values['-OFFSETS-_calculate']:\n                window['-OFFSETS-_mirror_vertical'].update(readonly=True)\n                window['-OFFSETS-_mirror_axis_vertical'].update(readonly=True)\n            \n            else:\n                window['-OFFSETS-_mirror_vertical'].update(readonly=False)\n                window['-OFFSETS-_mirror_axis_vertical'].update(readonly=False)\n        # commented out code\n            \"\"\"\n        elif event == '-OFFSETS-_beam_vertical':\n            if values['-OFFSETS-_beam_vertical'] not in ['',' ', '-']:\n                window.find_element('-OFFSETS-_beam_vertical').set_focus(force=True)\n                offsets_control.updatepgm(window,pgm)\n                if values['-OFFSETS-_calculate']:\n                    offsets_control.calcoffsets(window, pgm)\n                    window.write_event_value('Update', None)\n            else:\n                window.find_element('-OFFSETS-_beam_vertical').set_focus(force=True)\n                continue\n            \"\"\"\n        elif event == 'Open workspace':\n            pickle_file = sg.popup_get_file('Open workspace', file_types=(('PGM Workspace', '*.pgm'),))\n            if pickle_file:\n                with open(pickle_file, 'rb') as file:\n                    pgm = pickle.load(file)\n                    beam_config = pickle.load(file)\n                    offsets_control_calculateq = pickle.load(file)\n                    energy_control.write(window, pgm.energy, pgm)\n                    cff_control.write(window, pgm.grating.cff, pgm)\n                    order_control.write(window, pgm.grating.order, pgm)\n                    line_density_control.write(window, pgm.grating.line_density, pgm)\n                    offsets_control.write(window, pgm.values(), calcq=offsets_control_calculateq)\n            continue\n            \n        elif event == 'Save workspace':\n            save_layout = [[\n                [sg.Text('Save workspace as:')],\n                [sg.FolderBrowse('Select folder', key='-FOLDER-')],\n                [sg.Text('File Name:'), sg.Input(key='-FILENAME-', size=(20,1))],\n                [sg.Button('Save'), sg.Button('Cancel')]\n            ]]\n            save_window = sg.Window('Save Workspace', save_layout, finalize=True)\n            while True:\n                event, values = save_window.read()\n                if event == sg.WIN_CLOSED or event == 'Cancel':\n                    save_window.close()\n                    break\n                elif event == 'Save':\n                    filename = values['-FILENAME-']\n                    folder = values['-FOLDER-']\n                    with open(folder+'/'+filename+'.pgm', 'wb') as file:\n                        pickle.dump(pgm, file)\n                        pickle.dump(beam_config, file)\n                        pickle.dump(offsets_control.calculate, file)\n                        save_window.close()\n                    sg.Popup('Workspace saved')\n                    break\n                \n            # remove pass\n            pass\n\n\nif __name__ == '__main__':\n    main()\n", "type": "text"}, {"name": "pgmcomponents\\gui\\mplwidgets.py", "content": "\"\"\"\nFile supplies necessary mpl widgets for\ngui_widgets.py\n\nversion: 0.2.2\n\n\"\"\"\n\n# plt not used\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk\n# Canvas not used\nfrom PySimpleGUI import Canvas\n\ndef draw_figure_w_toolbar(canvas, fig, canvas_toolbar):\n    \"\"\"\n    Method to draw on a given canvas and toolbar.\n\n    Parameters\n    ----------\n    canvas : Canvas\n        Canvas to draw on.\n    fig : Figure\n        Figure to draw.\n    canvas_toolbar : Canvas\n        Canvas to draw toolbar on.\n    \n    \"\"\"\n    if canvas.children:\n        for child in canvas.winfo_children():\n            child.destroy()\n    if canvas_toolbar.children:\n        for child in canvas_toolbar.winfo_children():\n            child.destroy()\n    figure_canvas_agg = FigureCanvasTkAgg(fig, master=canvas)\n    figure_canvas_agg.draw()\n    toolbar = Toolbar(figure_canvas_agg, canvas_toolbar)\n    toolbar.update()\n    figure_canvas_agg.get_tk_widget().pack(side='right', fill='both', expand=1)\n\n\nclass Toolbar(NavigationToolbar2Tk):\n    # no need for this __init__ method as calls it's parent class's __init__\n    def __init__(self, *args, **kwargs):\n        super(Toolbar, self).__init__(*args, **kwargs)", "type": "text"}, {"name": "pgmcomponents\\elements\\__init__.py", "content": "from .mirror import *\nfrom .grating import *\nfrom .pgm import *", "type": "text"}, {"name": "pgmcomponents\\elements\\grating.py", "content": "from __future__ import annotations\nimport numpy as np\nimport configparser\nfrom pgmcomponents.geometry import Point3D, Plane, Ray3D\nfrom scipy.constants import c, h, e\n\n\nclass Grating(object):\n    \"\"\"\n    A class for a simple grating\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    dimensions : array_like\n        The dimensions of the grating in mm [length, width, height],\n        dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    \n    Attributes\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    alpha : float\n        The incident angle of the beam in degrees\n    beta : float    \n        The diffraction angle of the beam in degrees\n    dimensions : array_like\n        The dimensions of the grating in mm\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    Methods\n    -------\n    set_angles(alpha, beta)\n        Set the incident and diffraction angles of the grating\n    energy_to_wavelength()\n        Calculate the wavelength of the beam in Angstroms\n    compute_corners()\n        Compute the corners of the grating in the global coordinate system\n    diffract(*args)\n        A method to diffract rays off the grating\n    compute_beta(alpha, line_density, energy, order)\n        Calculate the diffraction angle beta from the incident angle alpha\n    reflect(*args)\n        A method to 'reflect' rays off the grating\n    \"\"\"\n    # Run a code formatter and linter to fix code style adn syntax errors. Black & Falke8 are good for this.\n    def __init__(self, \n                 line_density=600, \n                 energy=2400, \n                 cff=2, \n                 order=1, \n                 dimensions = np.array([200,40,50]), \n                 borders = np.array([0,0,0,0])):\n\n        self._line_density=line_density\n        self._energy=energy\n        self._cff=cff\n        self._order=order\n        self._alpha = None\n        self._beta = None\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._borders = borders\n        _,_ = self.compute_angles()\n        _ = self.compute_corners()\n\n\n\n    def __repr__(self):\n        # Use f-strings\n        return f\"Grating(line_density={self.line_density},\\n energy={self.energy}, \\n cff={self.cff}, \\n order={self.order}, \\n dimensions={self.dimensions},\\n borders={self.borders})\"\n    \n    def read_file(self, filename):\n        \"\"\"\n        Read grating parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['grating']) != 6:\n            # You could add config['grating'] into the error message\n            raise ValueError(\"Expected exactly five parameters in grating file\")\n\n        # Could use tuple instead of list\n        variables = ('line_density', 'energy', 'cff', 'order', 'dimensions')\n        for var in variables:\n            if var not in config['grating']:\n                raise ValueError(\"Missing parameter {} in grating file\".format(var))\n            \n        # You already check if variables in config['grating'] above and repeat below.\n        # Could use sets to create items from variable and config['grating'] to avoid list comprehension.\n        items = [x for x in variables if x in config['grating'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['grating'].values()):\n            setattr(self, key, value)\n            print(key)\n            print(value)\n        \n        self._order = int(self._order)\n        self._dimensions = np.array([float(x) for x in config['grating']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['grating']['borders'].split(',')])\n\n    @property\n    def line_density(self)-> float:\n        return self._line_density\n    \n    @line_density.setter\n    def line_density(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive line density\")\n        else:\n            self._line_density = value\n\n    @property\n    def energy(self)-> float:\n        return self._energy\n    \n    @energy.setter\n    def energy(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive energy\")\n        else:\n            self._energy = value\n        \n    @property\n    def cff(self)-> float:\n        return self._cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if value <= 1:\n            raise ValueError(\"Expected positive cff\")\n        else:\n            self._cff = value\n    \n    @property\n    def order(self)-> int:\n        return int(self._order)\n    \n    @order.setter\n    def order(self, value: int)-> None:\n        if value >= 1 and isinstance(value, int):\n            self._order = value\n            print(\"order set!\")\n        else:\n            raise ValueError(\"Expected positive integer order\")\n\n    @property\n    def alpha(self)-> float:   \n        return self._alpha\n    \n    @alpha.setter\n    def alpha(self, value)-> None:\n        if np.abs(value) <= 180 and isinstance(value, (float, int)):\n            self._alpha = value\n        else:\n            raise ValueError(\"Expected float alpha with magnitude less than 180 degrees\")\n\n    @property\n    def beta(self)-> float:\n        return self._beta\n    \n    @beta.setter\n    def beta(self, value: float)-> None:\n        self._beta = value\n    \n    @property\n    def dimensions(self):\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value):\n        if len(value) != 3:\n            raise ValueError(\"Expected exactly three values for dimensions\")\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._grating_plane\n    \n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._grating_plane = value\n        else:\n            raise TypeError(\"Expected Plane object for plane\")\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value: np.ndarray)-> None:\n        if len(value) != 4 or not isinstance(value, np.ndarray):\n            raise ValueError(\"Expected exactly 1D array of length 4 for borders\")\n        else:\n            self._borders = value\n\n\n    def set_angles(self, alpha: float, beta: float)-> None:\n        \"\"\"\n        Set the incident and diffraction angles of the grating.\n\n        Parameters\n        ----------\n        alpha : float\n            The incident angle in degrees\n        beta : float \n            The diffraction angle in degrees\n\n        Raises\n        ------\n        ValueError\n            If the wavelength is zero\n\n        \"\"\"\n        wavelength = (np.sin(np.deg2rad(alpha)) + np.sin(np.deg2rad(beta))) / (self.line_density*1000*self._order)\n        \n        if wavelength <= 0:\n            raise ValueError(\"Expected positive, non-zero wavelength\")\n\n        else:\n            self._energy = 12398.42 / wavelength #converts wavelength to eV\n        \n        self._alpha = alpha\n        self._beta = beta\n        self._cff = self.cff\n\n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value:any)-> None:\n        print(\"Input ignored, corners are computed from dimensions\")\n        self._corners = self.compute_corners()\n\n    def compute_beta(self)-> float:\n        \"\"\"\n        Compute the diffraction angle beta from the incident angle alpha.\n\n        Returns\n        -------\n        beta : float\n            The diffraction angle in degrees\n        \n    \n        \"\"\"\n        beta = 0\n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        u = self.order*self.line_density*1000*wavelength - np.sin(np.deg2rad(self.alpha))\n        beta = np.rad2deg(np.arcsin(u))\n        \n        \n        return beta\n\n    def compute_angles(self)-> tuple[float, float]:\n        \"\"\"\n        Compute the incident and diffraction angles of the grating.\n        The incident angle is calculated from the diffraction angle\n        using the fixed focus constant.\n\n        Returns\n        -------\n        alpha : float\n            The incident angle in degrees\n\n        beta : float\n            The diffraction angle in degrees\n        \n        \"\"\"\n        \n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        print(self.energy,\n              self.order,\n                self.line_density,\n                self.cff,\n               wavelength)\n        \n        lambda_u = self.order*self.line_density*1000*wavelength/(1-self.cff**2)\n        sin_alpha = lambda_u + np.sqrt(1+lambda_u**2*self.cff**2)\n        self._alpha = np.rad2deg(np.arcsin(sin_alpha))\n        self._beta = -np.rad2deg(np.arccos(np.cos(np.arcsin(sin_alpha))*self.cff))\n\n        return self._alpha, self._beta\n\n    # Could add type annotations on all your functions\n    def diffract(self, *args: Ray3D | list )-> list:\n        \"\"\"\n        A method to diffract rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be diffracted\n\n        Returns\n        -------\n        diffracted_rays : list of Ray3D\n            A list of diffracted rays\n\n        Raises\n        ------\n        raises ValueError too\n        TypeError\n            If the rays are not Ray3D objects\n\n        \"\"\"\n        diffracted_rays = []\n        \n\n        if isinstance(args[0], list):\n            args = args[0]\n\n        elif len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n\n        for _, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            raydotplane = ray.vector.dot(self._grating_plane.normal)\n            angle = np.arccos(raydotplane/np.linalg.norm(self._grating_plane.normal))\n            alpha = np.rad2deg(np.pi/2-angle)\n            beta = self.compute_beta()\n            diff_ray = self.reflect(ray)[0]\n            angle = -90 - beta - alpha\n            diff_ray.vector[2] += np.cos(np.deg2rad(angle))\n            diff_ray.vector[1] += np.sin(np.deg2rad(angle))\n            diff_ray.vector = diff_ray.vector/np.linalg.norm(diff_ray.vector)\n            diffracted_rays.append(diff_ray)\n        return diffracted_rays\n    \n    \n\n    # rename something like energy_to_wavelength\n    def energy_to_wavelength(self, energy: float)-> float:\n        return h*c/(e*energy)\n    \n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the grating in the global coordinate system.\n\n        Returns\n        -------\n        corners : array_like\n            The corners of the grating in the global coordinate system:\n            [bottom left back, \n            bottom right back, \n            bottom left front, \n            bottom right front,\n            top left back,\n            top right back,\n            top left front,\n            top right front]\n        \"\"\"\n        \n        beta = np.deg2rad(self._beta)\n        # beta_g not used\n        beta_g = np.deg2rad(self._beta + 90)\n        l = self._length()\n        w = self._width()\n        d = self._height()        \n        #Bottom left back\n        blbz = (l/2)*np.sin(beta)\n        blby = -(l/2)*np.cos(beta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        #Bottom left front\n        blfz = -(l/2)*np.sin(beta)\n        blfy = (l/2)*np.cos(beta)\n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = blbz - d*np.cos(beta)\n        tlby = blby - d*np.sin(beta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Top right back\n        trbz = brbz - d*np.cos(beta)\n        trby = brby - d*np.sin(beta)\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Top left front\n        tlfz = blfz - d*np.cos(beta)\n        tlfy = blfy - d*np.sin(beta)\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Top right front\n        trfz = brfz - d*np.cos(beta)\n        trfy = brfy - d*np.sin(beta)\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        self._grating_plane = Plane(\n            Point3D(blfx, blfy, blfz),\n            Point3D(brfx, brfy, brfz),\n            Point3D(blbx, blby, blbz)\n        )\n\n        self._corners = np.array([\n            blb,\n            brb,\n            blf,\n            brf,\n            tlb,\n            trb,\n            tlf,\n            trf\n        ])\n\n        return self._corners\n\n    def reflect(self, *args, zero_order = False)-> list:\n        \"\"\"\n        A method to reflect rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        # Check after determining if list\n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        # se isinstance\n        if type(args[0]) == list:\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._grating_plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect grating, tread with caution!')\n                continue\n            ray_array = ray.vector\n            grating_normal = self._grating_plane.normal\n            if zero_order:\n                \n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, -grating_normal) * grating_normal\n            else:\n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, grating_normal) * grating_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n\n    @classmethod\n    def grating_from_file(cls, filename):\n        \"\"\"\n        Create a grating from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        grating = cls()\n        grating.read_file(filename)\n        return grating\n    \n", "type": "text"}, {"name": "pgmcomponents\\elements\\mirror.py", "content": "from __future__ import annotations\n# List not used\nfrom ast import List\nfrom matplotlib.pyplot import isinteractive\nimport numpy as np\nfrom pgmcomponents.geometry import Point3D, Vector3D, Plane, Ray3D\nimport configparser\n\nclass Plane_Mirror(object):\n    \"\"\"\n    A class for a simple plane mirror.\n\n    Parameters\n    ----------\n    voffset : float, optional\n        The vertical offset of the mirror in mm\n    hoffset : float, optional\n        The horizontal offset of the mirror in mm\n    axis_voffset : float, optional\n        The vertical offset of the mirror axis in mm\n    axis_hoffset : float, optional\n        The horizontal offset of the mirror axis in mm\n    dimensions : array_like, optional\n        The dimensions of the mirror in mm [length, width, height]\n        Dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    theta : float, optional\n        The angle of the mirror in degrees\n    plane : Plane, optional\n        The plane of the mirror\n    borders: array_like, optional\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    \n\n    Attributes\n    ----------\n    dimensions : array_like\n        The dimensions of the mirror in mm\n    position : Point3D\n        The position of the mirror\n    normal : Vector3D\n        The normal vector of the mirror\n    orientation : Vector3D\n        The orientation of the mirror\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    plane : Plane\n        The plane of the mirror\n    \n    borders: array_like\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    Methods\n    -------\n    set_position(position)\n        Set the position of the mirror\n    set_normal(normal)\n        Set the normal vector of the mirror\n    set_orientation(orientation)\n        Set the orientation of the mirror\n    set_dimensions(*args)\n        Set the dimensions of the mirror\n    set_offsets(voffset, hoffset, axis_voffset, axis_hoffset)\n        Set the offsets of the mirror\n    compute_corners()\n        Compute the corners of the mirror in the global coordinate system,  \n    \n    \n    \"\"\"\n\n    def __init__(self, \n                 voffset=13, \n                 hoffset=40, \n                 axis_voffset=6.5, \n                 axis_hoffset=0, \n                 dimensions = np.array([450, 70, 50]),\n                 theta=45, \n                 plane=Plane(),\n                 borders = np.array([0,0,0,0])\n                 ):\n        \"\"\"\n        Constructor for the Plane_Mirror class.\n\n        Parameters\n        ----------\n        voffset : float\n            The vertical offset of the mirror in mm\n        hoffset : float\n            The horizontal offset of the mirror in mm\n        axis_voffset : float\n            The vertical offset of the mirror axis in mm\n        axis_hoffset : float\n            The horizontal offset of the mirror axis in mm\n        dimensions : array_like\n            The dimensions of the mirror in mm [length, width, height]\n            Dimensions are also accessible with lambda functions as:\n            self._length(), self._width(), self._height()\n\n        \n        theta : float\n            The angle of the mirror in degrees\n        plane : Plane\n            The plane of the mirror\n        \n        \"\"\"\n\n        self._voffset = voffset\n        self._hoffset = hoffset\n        self._axis_voffset = axis_voffset\n        self._axis_hoffset = axis_hoffset\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._plane = plane\n        self._theta = theta\n        # Just call method without assigning to _\n        _ = self.compute_corners()\n        self._borders = borders\n\n\n    def __repr__(self):\n        # Use f-string\n        return \"\"\"Plane_Mirror(voffset={}, \n        hoffset={}, \n        axis_voffset={}, \n        axis_hoffset={}, \n        length={}, \n        width={}, \n        height={}, \n        plane={},\n        borders={})\n        \"\"\".format(self.voffset,\n                            self.hoffset, \n                            self.axis_voffset, \n                            self.axis_hoffset, \n                            self._length(), \n                            self._width(), \n                            self._height(), \n                            self.plane,\n                            self.borders)\n    \n\n    # read_file is very similar to read_file in grating.py. Refactor to use common code.\n    def read_file(self, filename):\n        \"\"\"\n        Read mirror parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['mirror']) != 7:\n            raise ValueError(\"Expected exactly six parameters in mirror file\")\n\n        variables = ['voffset', 'hoffset', 'axis_voffset', 'axis_hoffset', 'dimensions', 'theta']\n        for var in variables:\n            if var not in config['mirror']:\n                raise ValueError(\"Missing parameter {} in mirror file\".format(var))\n        \n        items = [x for x in variables if x in config['mirror'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['mirror'].values()):\n            # Don't use exec. Either explicitly assign variables or if you will not know what they will be, use a dictionary not variables.\n            exec(f\"self._{key} = float({value})\")\n            print(key)\n            print(value)\n        \n        \n        self._dimensions = np.array([float(x) for x in config['mirror']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['mirror']['borders'].split(',')])\n        \n\n    @property\n    def voffset(self)-> float:\n\n        return self._voffset\n\n    @voffset.setter\n    def voffset(self, value: float)-> None:\n        if isinstance(value, float):\n            self._voffset = value  \n        else:\n            raise TypeError(\"Expected voffset to be float!\")\n    @property\n    def a(self)-> float:\n        return self._hoffset\n    \n    @a.setter\n    def a(self, value: float)-> None:\n        self.hoffset = float(value)\n\n    @property\n    def hoffset(self)-> float:\n        return self._hoffset\n\n    @hoffset.setter\n    def hoffset(self, value: float):\n        if isinstance(value, float):\n            self._hoffset = value\n        else:\n            raise TypeError(\"Expected hoffset to be float!\")\n\n    @property\n    def c(self)-> float:\n        return self._voffset\n    \n    @c.setter\n    def c(self, value: float)-> None:\n        self.voffset = float(value)\n\n    \n\n    @property\n    def axis_voffset(self)-> float:\n        return self._axis_voffset\n\n    @axis_voffset.setter\n    def axis_voffset(self, value: float):\n        if isinstance(value, float):\n            self._axis_voffset = value\n        else:\n            raise TypeError(\"Expected axis voffset to be float!\")\n\n    @property\n    def v(self)-> float:\n        return self._axis_voffset\n    \n    @v.setter\n    def v(self, value: float)-> None:\n        self.axis_voffset = float(value)\n\n\n    @property\n    def axis_hoffset(self)-> float:\n        return self._axis_hoffset\n\n    @axis_hoffset.setter\n    def axis_hoffset(self, value:float):\n        if isinstance(value, float):\n            self._axis_hoffset = value\n        else:\n            raise TypeError(\"Expected axis hoffset to be float!\")\n\n    @property\n    def h(self)-> float:\n        return self._axis_hoffset\n    \n    @h.setter\n    def h(self, value: float)-> None:\n        self.axis_hoffset = float(value)\n    \n\n    @property\n    def dimensions(self)-> np.ndarray:\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value:float):\n        \"\"\"\n        Sets the dimensions of the mirror.\n        The dimensions are specified as:\n        [length, width, height]\n\n        \"\"\"\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._plane\n\n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._plane = value\n        else:\n            raise TypeError(\"Expected value to be Plane instance!\")\n    \n    @property\n    def theta(self)-> float:\n        return self._theta\n    \n    @theta.setter\n    def theta(self, value: float)-> float:\n        self._theta = value\n    \n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value):\n        print(\"Input value ignored, corners computed from parameters!\")\n        self.compute_corners()\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value)-> None:\n        \"\"\"\n        Sets the borders of the mirror.\n        The borders are specified as:\n        |-----------Top------------|\n        |                          |\n         Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n        \"\"\"\n        if isinstance(value, np.ndarray) and len(value)==4:\n            if all(value > 0):\n                self._borders = value\n            else:\n                raise ValueError(\"Lengths should be positive.\")\n        else:\n            raise ValueError(\"Expected 1D numpy array with length 4\")\n\n\n    def set_position(self, position: Point3D)-> None:\n        if isinstance(position, Point3D):\n            self._plane.position = position\n        else:\n            raise TypeError(\"Expected Point3D instance for position value!\")\n\n    def set_normal(self, normal: Vector3D)-> None:\n        if isinstance(normal, Vector3D):\n            self._plane.normal = normal\n        else:\n            raise TypeError(\"Expected Vector3D instance for normal value!\")\n\n    # Combine with setter\n    def set_dimensions(self, *args: np.ndarray | float)-> None:\n        \"\"\"\n        Set the dimensions of the mirror.\n\n        Parameters\n        ----------\n        *args : array_like\n            Either one or three arguments for the dimensions\n\n        Raises\n        ------\n        ValueError\n            If the number of arguments is not one or three\n\n        \"\"\"\n        # compute length once and assign to variable. Can use this in error msg.\n        # Will raise ValueError if args does not have length, so check that too.\n        length_of_args = len(args)\n        if length_of_args == 1:\n            self._dimensions = args[0]\n        elif length_of_args == 3:\n            self._dimensions = np.array(args)\n        else:\n            raise ValueError(f\"Expected either one or three arguments for dimensions, got length of {length_of_args} instead.\")\n\n    def set_offsets(self, voffset: float, hoffset: float, axis_voffset: float, axis_hoffset: float)-> None:\n        self.voffset(voffset)\n        self.hoffset(hoffset)\n        self.axis_voffset(axis_voffset)\n        self.axis_hoffset(axis_hoffset)\n\n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the mirror in the global coordinate system,\n        in addition to the plane and normal of the mirror.\n    \n\n        Returns\n        -------\n        corners : np.ndarray\n            The corners of the mirror in the global coordinate system\n            [top left front,\n            top right front,\n            bottom left front,\n            bottom right front,\n            top left back,\n            top right back,\n            bottom left back,\n            bottom right back]\n        \n        \n        \"\"\"\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.theta)\n        theta_g = 90 - self._theta\n        theta_g = np.deg2rad(theta_g)\n        a = self._hoffset\n        c = self._voffset\n        v = self._axis_voffset\n        h = self._axis_hoffset\n        w = self._width()\n        l = self._length()\n        d = self._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Bottom left front\n        blfz = tlfz + d*np.cos(theta)\n        blfy = tlfy - d*np.sin(theta)        \n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Bottom left back\n        blbz = tlbz + d*np.cos(theta)\n        blby = tlby - d*np.sin(theta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        self._plane = Plane(tlf, trf, tlb)\n\n        self._corners = np.array([\n            tlf,\n            trf,\n            blf,\n            brf,\n            tlb,\n            trb,\n            blb,\n            brb\n        ])\n\n        return self._corners\n\n    @classmethod\n\n    def mirror_from_file(cls, filename: str)-> Plane_Mirror:\n        \"\"\"\n        Create a mirror from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        mirror = cls()\n        mirror.read_file(filename)\n        return mirror\n\n    def reflect(self, *args: Ray3D | list) -> list:\n        \"\"\"\n        A method to reflect rays off the mirror.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list of Ray3D\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        if isinstance(args[0], list):\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect mirror, tread with caution!')\n                continue\n            ray_array = ray.vector\n            mirror_normal = self._plane.normal\n            reflected_ray_array = ray_array - 2 * np.dot(ray_array, mirror_normal) * mirror_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n", "type": "text"}, {"name": "pgmcomponents\\elements\\pgm.py", "content": "from __future__ import annotations\nfrom matplotlib.axes import Axes\nimport numpy as np\nfrom matplotlib.patches import Patch \nimport configparser\nfrom pgmcomponents.geometry import Point3D, Ray3D\nfrom scipy.spatial import ConvexHull\nfrom matplotlib.lines import Line2D\nfrom pgmcomponents.elements import Plane_Mirror, Grating\n\nclass PGM(object):\n    \"\"\"\n    A class for a PGM setup.\n\n    Parameters\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n\n    Attributes\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n    rays : list\n        The rays to be propagated through the PGM\n    beam_offset : float\n        The vertical offset of the beam in mm\n    beam_width : float\n        The width of the beam in mm\n    beam_height : float\n        The height of the beam in mm\n    \n    Methods\n    -------\n    read_file(filename)\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n    propagate(*args)\n        Propagate rays through the PGM setup.\n    draw_sideview(ax)\n        Draws the setup on a y-z projection on a given axis.\n    draw_topview(ax)\n        Draws the setup on a x-z projection on a given axis, along with the beam footprints.\n    \"\"\"\n\n    def __init__(self, grating = None, mirror = None, **kwargs):\n        \"\"\"\n        \n        Constructor for the PGM class.\n        \n        Parameters\n        ----------\n        grating : Grating\n            The grating component of the PGM\n        mirror : Plane_Mirror\n            The mirror component of the PGM\n        **kwargs : \n            Keyword arguments for the grating and mirror components.\n            See Grating and Plane_Mirror classes for details.\n\n        \n        \"\"\"\n        # It's unclear what is happening here and there will be uncaught errors if kwargs is not as expected.\n        if grating is None:\n            grating_kwargs = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'grating_dimensions'\n            ]\n            grating_kwarg_keys = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'dimensions'\n            ]\n        \n            grating_args = [kwargs.get(x) for x in grating_kwargs]\n            grating_kwargs = dict(zip(grating_kwarg_keys, grating_args))\n            self._grating = Grating(**grating_kwargs)\n\n        else:\n            self._grating = grating\n        \n        if mirror is None:\n            mirror_kwargs = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'mirror_dimensions',\n                'theta'\n            ]\n            mirror_kwarg_keys = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'dimensions',\n                'theta'\n            ]\n        \n            mirror_args = [kwargs.get(x) for x in mirror_kwargs]\n            mirror_kwargs = dict(zip(mirror_kwarg_keys, mirror_args))\n            self._mirror = Plane_Mirror(**mirror_kwargs)\n            \n        else:\n            self._mirror = mirror\n\n        \n        self._rays = []\n        self._beam_offset = 13\n        self._beam_width = 6.43\n        self._beam_height = 5\n        self._energy = 2400\n\n    def __repr__(self):\n        return \"\"\"PGM(grating={}, \\nmirror={}, \\nb={},\\nbeam_width={},\\nbeam_height={})\"\"\".format(self.grating, \n                                                               self.mirror,\n                                                               self.beam_offset,\n                                                               self.beam_width,\n                                                               self.beam_height)\n    \n    def generate_rays(self):\n        \"\"\"\n        Generate rays for the PGM setup.\n        \"\"\"\n        \n        r0 = Ray3D(Point3D(0, self.beam_offset, -1000),\n                   Point3D(0, self.beam_offset, 0)-\n                   Point3D(0, self.beam_offset, -1000))\n        \n        r1 = Ray3D(Point3D(0, self.beam_offset + self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset + self.beam_height/2, 0)-\n                     Point3D(0, self.beam_offset + self.beam_height/2, -1000)\n                   )\n\n        r2 = Ray3D(Point3D(0, self.beam_offset - self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset - self.beam_height/2, 0) -\n                   Point3D(0, self.beam_offset - self.beam_height/2, -1000))\n\n        r3 = Ray3D(Point3D(-self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(-self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(-self.beam_width/2, self.beam_offset, -1000))\n\n        r4 = Ray3D(Point3D(self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(self.beam_width/2, self.beam_offset, -1000))\n\n        self._rays = [r0, r1, r2, r3, r4]\n\n\n    def read_file(self, filename):\n        \"\"\"\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        \n        self._grating.read_file(filename)\n        self._mirror.read_file(filename)\n        pgm_config = configparser.ConfigParser()\n        pgm_config.read(filename)\n        self._energy = float(pgm_config['beam']['energy'])\n        self._beam_offset = float(pgm_config['beam']['beam_offset'])\n        self._beam_width = float(pgm_config['beam']['beam_width'])\n        self._beam_height = float(pgm_config['beam']['beam_height'])\n    \n\n    def set_theta(self):\n        \"\"\"\n        Set the angle of the grating.\n        \"\"\"\n        self.mirror.theta = 0.5 * (self.grating.alpha-self.grating.beta)\n\n    @property\n\n    def theta(self):\n        return self.mirror.theta\n\n    @theta.setter\n\n    def theta(self, value):\n        self.theta = value\n        self.mirror.theta = value\n\n    @property\n\n    def energy(self):\n        return self.grating.energy\n    \n    @property\n    def wavelength(self):\n        return 1239.8419843320025/self.energy\n    \n    @energy.setter\n    # need validation for energy value, e.g. non-zero\n    def energy(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 0:\n            self.grating.energy = value\n        else:\n            print(value, type(value))\n            raise ValueError(\"Expected energy to be a positive float!\")\n    @property\n    def grating(self)-> Grating:\n        return self._grating\n    \n    @grating.setter\n    def grating(self, value: Grating)-> None:\n        if isinstance(value, Grating):\n            self._grating = value\n        else: \n            raise TypeError(\"Expected Grating instance for grating!\")\n    \n    @property\n    def mirror(self)-> Plane_Mirror:\n        return self._mirror\n    \n    @mirror.setter\n    def mirror(self, value: Plane_Mirror):\n        if isinstance(value, Plane_Mirror):\n            self._mirror = value\n        else:\n            raise TypeError(\"Expected Plane_Mirror instance for mirror!\")\n    @property\n    def rays(self)-> list[Ray3D]:\n        return self._rays\n    \n    @rays.setter\n    def rays(self, value: list[Ray3D])-> None:\n        self._rays = value\n    \n    @property\n    def beam_offset(self)-> float:\n        return -1*self._beam_offset\n    \n    @beam_offset.setter\n    def beam_offset(self, value: float)-> None:\n        if isinstance(value, (float, int)):\n            self._beam_offset = -1*value\n        else:\n            raise TypeError(\"Expected float for beam_offset!\")\n        \n    @property\n    def b(self)-> float:\n        return self._beam_offset\n    \n    @b.setter\n    def b(self, value: float)-> None:\n        self.beam_offset = value\n\n    @property\n    def beam_width(self)-> float:\n        return self._beam_width\n    \n    @beam_width.setter\n    def beam_width(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_width = value\n        else:\n            raise TypeError(\"Expected non-negative float for beam_width!\")\n    \n    @property\n    def beam_height(self)-> float:\n        return self._beam_height\n    \n    @beam_height.setter\n    def beam_height(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_height = value\n        else:\n            raise ValueError(\"Expected non-negative float for beam_height!\")\n\n\n    @property\n    def mirror_intercept(self)-> Point3D:\n        return self._mirror_intercept\n    \n    @property\n    def grating_intercept(self)-> Point3D:\n        return self._grating_intercept\n    \n    \n    @property\n    def cff(self)-> float:\n        return self.grating.cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 1:\n            self.grating.cff = value\n        else:\n            raise ValueError(\"Expected cff to be a positive float bigger than 1!\")\n\n    def values(self)-> dict:\n\n        dictionary = {'beam_vertical': self.beam_offset,\n                      'beam_width': self.beam_width,\n                      'beam_height': self.beam_height,\n                      'line_density': self.grating.line_density,\n                      'energy': self.grating.energy,\n                      'cff': self.grating.cff,\n                      'order': self.grating.order,\n                      'grating_dimensions': self.grating.dimensions,\n                      'grating.borders': self.grating.borders,\n                      'mirror_voffset': self.mirror.voffset,\n                      'mirror_hoffset': self.mirror.hoffset,\n                      'mirror_axis_voffset': self.mirror.axis_voffset,\n                      'mirror_axis_hoffset': self.mirror.axis_hoffset,\n                      'mirror_dimensions': self.mirror.dimensions,\n                      'mirror_theta': self.mirror.theta,\n                      'mirror_borders': self.mirror.borders}\n        return dictionary\n\n    @classmethod\n\n    def pgm_from_file(cls, filename:float)-> PGM:\n        \"\"\"\n        Create a PGM from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        pgm = cls()\n        pgm.read_file(filename)\n        return pgm\n\n    def propagate(self, *args: Ray3D | list)-> tuple:\n        \"\"\"\n        Propagate rays through the PGM setup.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be propagated\n        \n        Returns\n        -------\n        grating_ray : list of Ray3D objects\n            A list of propagated rays originating at the grating intercept\n        \n        mirror_intercept : list of array_like\n            A list of the mirror intercepts\n\n        grating_intercept : list of array_like\n            A list of the grating intercepts\n\n        \"\"\"\n        _ = self._mirror.compute_corners()\n        _ = self._grating.compute_corners()\n\n        mirr_ray = self._mirror.reflect(*args)\n        grating_ray = self._grating.diffract(*mirr_ray)\n        mirror_intercept = [mirr_ray.position for mirr_ray in mirr_ray]\n        grating_intercept = [grating_ray.position for grating_ray in grating_ray]\n        \n        # _mirror_intercept and _grating_intercept not defined in __init__\n        self._mirror_intercept = mirror_intercept\n        self._grating_intercept = grating_intercept\n        return grating_ray, mirror_intercept, grating_intercept\n\n\n    def draw_sideview(self, ax: Axes):\n        \"\"\"\n        Draws the setup on a y-z projection on a given axis.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes\n            The axis to draw on\n\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        grating_corners = self.grating.compute_corners()\n        mirror_corners_y, mirror_corners_z = mirror_corners[::2,1], mirror_corners[::2,2]\n        mirror_corners_yz = np.array([mirror_corners_z, mirror_corners_y]).T\n        # ConvexHull sp?\n        # ConvelHull method used to ensure the entire region is filled regardless\n        # of point order.\n        hull_grating = ConvexHull(mirror_corners_yz)\n\n        grating_corners_y, grating_corners_z = grating_corners[::2,1], grating_corners[::2,2]\n        grating_corners_yz = np.array([grating_corners_z, grating_corners_y]).T\n        hull_mirror = ConvexHull(grating_corners_yz)\n\n        ax.fill(mirror_corners_yz[hull_mirror.vertices,0], mirror_corners_yz[hull_mirror.vertices,1], 'r')\n        ax.fill(grating_corners_yz[hull_grating.vertices,0], grating_corners_yz[hull_grating.vertices,1], 'b')\n\n        self.generate_rays()\n        grating_ray, mirror_int, grating_int = self.propagate(self.rays)\n        #print(\"Side view r3 int:\", mirror_int[3])\n        for index, ray in enumerate(grating_ray):\n            r_z = np.array([\n            self.rays[index].position.z,\n            mirror_int[index].z,\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            self.rays[index].position.y,\n            mirror_int[index].y,\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='green', linewidth=1, label='Dispersed Rays')\n            ax.add_line(line)\n        \n        zero_order_rays = self.grating.reflect(self.rays, zero_order=True)\n\n        \"\"\"\n        for index, ray in enumerate(zero_order_rays):\n            r_z = np.array([\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='gray', linewidth=1, label='Zero Order Reflections')\n            ax.add_line(line)\n        \"\"\"\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n        ]\n        ax.legend(handles=legend_entries, loc = 'lower right', fontsize=16, fancybox=True, shadow=True)\n        ax.axhline(y=0, color='black', linestyle='--', linewidth=1.3)\n        ax.axvline(x=0, color='black', linestyle='--', linewidth=1.3)\n        \n    def draw_topview(self, ax: Axes)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        \n        self.generate_rays()\n        \n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        _, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        _, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        _, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        _, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n        #print(\"Mirror footprint width:\", mirror_footprint_width)\n       # print(\"Mirror footprint height:\", mirror_footprint_height)\n        #print(\"Grating footprint width:\", grating_footprint_width)\n       # print(\"Grating footprint height:\", grating_footprint_height)\n        \n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        ax.fill(mirror_corners[:,0], mirror_corners[:,1], 'r',alpha=1, label='Mirror')\n        ax.fill(grating_corners[:,0], grating_corners[:,1], 'b',alpha=0.5, label='Grating')\n        ax.fill(mirr_footprint_corners[:,0], mirr_footprint_corners[:,1], c='black')\n        ax.fill(grating_footprint_corners[:,0], grating_footprint_corners[:,1], c='green')\n        ax.grid(axis='both', which='both', alpha = 0.5)\n        ax.set_xticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xticks(np.arange(-1000, 1000, 100), minor=False)\n        ax.set_yticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xlim(min(mirror_corners[:,0]), max(grating_corners[:,0]))\n        ax.set_ylim(min(mirror_corners[:,1]), max(grating_corners[:,1]))\n        #ax.fill(mirror_rect_borders[:,0], mirror_rect_borders[:,1], 'r',alpha=0.5)\n        #ax.fill(m_corners[:,] , 'r',alpha=1)\n        #x.fill(grating_rect_borders[:,0], grating_rect_borders[:,1], 'b',alpha=1)\n        #ax.fill(grating_rect[:,0], grating_rect[:,1], 'b',alpha=0.5, label='Grating')\n        #ax.fill([mirror_blz, mirror_blz + mirror_l, mirror_blz + mirror_l, mirror_blz], [mirror_blx, mirror_blx, mirror_blx + mirror_w, mirror_blx + mirror_w], 'g', alpha=0.5, label='Beam Footprint')\n        #ax.fill([grating_blz, grating_blz + grating_l, grating_blz + grating_l, grating_blz], [grating_blx, grating_blx, grating_blx + grating_w, grating_blx + grating_w], 'g', alpha=0.5)\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n            Patch(facecolor=(0,0,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Mirror): {mirror_footprint_width:.2f} mm x {mirror_footprint_height:.2f} mm'),\n            Patch(facecolor=(0,1,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Grating): {grating_footprint_width:.2f} mm x {grating_footprint_height:.2f} mm')\n\n        ]\n\n        ax.legend(handles=legend_entries, loc = 'upper left', fontsize=12, fancybox=True, shadow=True)\n\n\n    def topview_trace(self)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        # use your _width and _length setters\n        \n        self.generate_rays()\n        \n        # _, mirror_intercept, grating_intercept\n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        grating_ray, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        grating_ray, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        grating_ray, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        grating_ray, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n\n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        return mirror_intercepts, grating_intercepts\n        \n\n    def calc_footprint_size(self, intercepts: list[Point3D])-> tuple:\n        \"\"\"\n        Calculate the size of the footprint of the beam on the grating or the mirror\n        when given the intercepts of the beam with the grating or the mirror.\n         \n        \n        Parameters\n        ----------\n        intercepts : list of Point3D objects\n            The intercepts of the beam with the grating or the mirror\n            [r_1, r_2, r_3, r_4]\n\n        Returns\n        -------\n        size : tuple\n            The size of the footprint of the beam on the grating or the mirror in mm\n        \"\"\"\n\n        r_1, r_2, r_3, r_4 = intercepts\n    \n        width = r_1.distance(r_2)\n        height = r_3.distance(r_4)\n\n        return width, height\n\n\n    def centre_of_footprint(self):\n        \"\"\"\n        Calculate the centre of the footprint of the beam on the grating or the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the footprint of the beam on the grating or the mirror\n        \"\"\"\n        _, mirror_int_0, grating_int_0 =  self.propagate(self.rays[0])\n\n        return mirror_int_0, grating_int_0\n        \n    def find_offset(self):\n\n        mirror_int, grating_int = self.centre_of_footprint()\n        mirror_int = mirror_int[0]\n        grating_int = grating_int[0]\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        #print(mirror_corners)\n        centre_of_mirror_top = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        #print([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]])\n        #print(centre_of_mirror_top)\n        mirror_offset =  np.array([mirror_int.x, mirror_int.y, mirror_int.z]) - centre_of_mirror_top\n        #print(mirror_offset)\n        mirror_offset = np.linalg.norm(mirror_offset) * mirror_offset[1]/np.abs(mirror_offset[1])\n\n        grating_offset = np.linalg.norm(grating_int) * grating_int[1]/np.abs(grating_int[1])\n        return mirror_offset, grating_offset\n    \n    def centre_of_mirror(self):\n        \"\"\"\n        Calculate the centre of the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the mirror\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        centre_of_mirror = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        return centre_of_mirror\n\n\n    def mirror_corners(self)-> tuple:\n\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.mirror.theta)\n        theta_g = 90 - self.theta\n        theta_g = np.deg2rad(theta_g)\n        a = self.mirror._hoffset\n        c = self.mirror._voffset\n        v = self.mirror._axis_voffset\n        h = self.mirror._axis_hoffset\n\n        w = self.mirror._width()\n        l = self.mirror._length()\n        d = self.mirror._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        return ((tlfz, tlfx), (trfz, trfx), (trbz, trbx), (tlbz, tlbx))\n\n    def grating_corners(self)-> tuple:\n        \n        l = self.grating._length()\n        w = self.grating._width()\n        beta = self.grating.beta\n        \n        beta_g = 90 + beta\n        beta_rad = beta_g*np.pi/180\n\n        blbz = -(l/2)*np.cos(beta_rad)\n        blbx = -w/2\n\n        brbz = -(l/2)*np.cos(beta_rad)\n        brbx = w/2\n\n        blfz = (l/2)*np.cos(beta_rad)\n        blfx = -w/2\n\n        brfz = (l/2)*np.cos(beta_rad)\n        brfx = w/2\n\n        return ((blbz, blbx), (brbz, brbx), (brfz, brfx), (blfz, blfx))\n    \n    def corners(self)-> tuple[dict]:\n        \"\"\"\n        Calculate the corners of the mirror and grating.\n        \n        Returns\n        -------\n        corners : dict\n            The corners of the grating and mirror in the following order:\n            bottom left back, bottom right back, bottom left front, bottom right front,\n            top left back, top right back, top left front, top right front\n        \"\"\"\n        positions = [\n            \"bottom left back\",\n            \"bottom right back\",\n            \"bottom left front\",\n            \"bottom right front\",\n            \"top left back\",\n            \"top right back\",\n            \"top left front\",\n            \"top right front\"\n        ]\n        grating_corners = self.grating.compute_corners()\n        grating_corners_dict = dict(zip(positions, grating_corners))\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners_dict = dict(zip(positions, mirror_corners))\n\n        return grating_corners_dict, mirror_corners_dict\n            \n\n    @staticmethod\n    def undulator_size():\n        pass\n", "type": "text"}, {"name": "pgmcomponents\\shadow\\__init__.py", "content": "from .tools import *", "type": "text"}, {"name": "pgmcomponents\\shadow\\analysis.py", "content": "\"\"\"\nA collection of functions to help with the analysis of the data\nproduced by SHADOW.\n\n\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndef calc_ratio(df:pd.DataFrame , column = 'Intensity')-> np.ndarray:\n    heading = {\"Intensity\": 'Intensity_dict', \"Height\":\"Height_dict\", \"Rays\": \"Ray Dict\"}\n    E = df['E'].to_numpy()\n    vals = df[heading[column]]\n    evaluated_vals = [eval(row) for row in vals]\n    #print(evaluated_vals)\n    vals_list = np.array([np.array(list(row.values())) for row in evaluated_vals])\n    offset_vals = np.array([np.hstack((row[0], row[:-1])) for row in vals_list])\n    ratios = (vals_list/offset_vals)[:,1:]\n    if column == 'Rays':\n        return E, vals_list\n    data = np.array([np.hstack((e, ratio)) for e, ratio in zip(E, ratios)])\n    \n    return data\n\n\ndef draw_ratio(df:pd.DataFrame, \n               ax:plt.Axes, \n               column= 'Intensity', \n               return_lines=False, \n               title = None, \n               xlabel=None, \n               ylabel=None)-> tuple | None:\n    labels = {\"Intensity\":\"Relative Intensity\",\"Height\": \"Relative Beam Height\",\"Rays\": \"Relative Ray Ratio\"} \n    if column == \"Rays\":\n        E, data = calc_ratio(df, column=column)\n        labels = [f\"OE{i+1}\" for i in range(0,9)]\n    else:\n        data = calc_ratio(df, column=column)\n        labels = [f\"OE{i+2}/OE{i+1}\" for i in range(9)]\n\n    lines = []\n    \n    for i, label in zip(np.arange(0,10,1), labels):\n        lines.append(ax.plot(E, data[0:,i], label=label, markersize=1, marker='^', linewidth=20-2*i))\n    #lines = [l1, l2, l3, l4, l5, l6, l7, l8]\n    if title != None: ax.set_title(title)\n    if xlabel != None: ax.set_xlabel(xlabel)\n    if ylabel != None: ax.set_ylabel(ylabel)\n    return (lines, labels) if return_lines else None", "type": "text"}, {"name": "pgmcomponents\\shadow\\test.py", "content": "import Shadow\nimport numpy\n\n# write (1) or not (0) SHADOW files start.xx end.xx star.xx\niwrite = 0\n\n#\n# initialize shadow3 source (oe0) and beam\n#\nbeam = Shadow.Beam()\noe0 = Shadow.Source()\noe1 = Shadow.OE()\n\n#\n# Define variables. See meaning of variables in: \n#  https://raw.githubusercontent.com/srio/shadow3/master/docs/source.nml \n#  https://raw.githubusercontent.com/srio/shadow3/master/docs/oe.nml\n#\n\noe0.FDISTR = 1\noe0.FSOUR = 1\noe0.F_PHOT = 0\noe0.IDO_VX = 0\noe0.IDO_VZ = 0\noe0.IDO_X_S = 0\noe0.IDO_Y_S = 0\noe0.IDO_Z_S = 0\noe0.ISTAR1 = 5676561\noe0.PH1 = 2000.0\noe0.WXSOU = 6\noe0.WZSOU = 8\noe1.ALPHA=0\noe1.CZ_SLIT = numpy.array([0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\noe1.DUMMY = 0.1\noe1.FWRITE = 3\noe1.F_REFRAC = 2\noe1.F_SCREEN = 1\noe1.I_SLIT = numpy.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0])\noe1.N_SCREEN = 1\noe1.RX_SLIT = numpy.array([10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\noe1.RZ_SLIT = numpy.array([10, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\noe1.T_INCIDENCE = 0.0\noe1.T_REFLECTION = 180.0\n\n\n\n#Run SHADOW to create the source\n\nif iwrite:\n    oe0.write(\"start.00\")\n\nbeam.genSource(oe0)\n\nif iwrite:\n    oe0.write(\"end.00\")\n    beam.write(\"begin.dat\")\n\n\n#\n#run optical element 1\n#\nprint(\"    Running optical element: %d\"%(1))\nif iwrite:\n    oe1.write(\"start.01\")\n\nbeam.traceOE(oe1,1)\n\nif iwrite:\n    oe1.write(\"end.01\")\n    beam.write(\"star.01\")\n\n\nShadow.ShadowTools.plotxy(beam,1,3,nbins=101,nolost=1,title=\"Real space\")\n# Shadow.ShadowTools.plotxy(beam,1,4,nbins=101,nolost=1,title=\"Phase space X\")\n# Shadow.ShadowTools.plotxy(beam,3,6,nbins=101,nolost=1,title=\"Phase space Z\")", "type": "text"}, {"name": "pgmcomponents\\shadow\\tools.py", "content": "from pgmcomponents.elements import *\nfrom pgmcomponents.geometry import *\nfrom Shadow import OE, Beam\nfrom colorama import Fore\nimport json\nfrom scipy.interpolate import CubicSpline\n\ndef make_pgm(grating_params, mirror_params):\n    \"\"\"\n    Create a PGM object from the given parameters.\n\n    Parameters\n    ----------\n    grating_params : dict\n        Dictionary of parameters for the grating.\n\n        line_density=600, \n        energy=250, \n        cff=2, \n        order=1, \n        dimensions = np.array([1,1,1]), \n        borders = np.array([0,0,0,0])\n\n    mirror_params : dict\n        Dictionary of parameters for the mirror.\n\n        voffset=20, \n        hoffset=0, \n        axis_voffset=0, \n        axis_hoffset=0, \n        dimensions = np.array([450, 70, 50]),\n        theta=45, \n        plane=Plane(),\n        borders = np.array([0,0,0,0]\n\n    pgm_params : dict\n        Dictionary of parameters for the PGM.\n\n    Returns\n    -------\n    pgm : PGM\n        The PGM object.\n    \"\"\"\n    # Create the grating.\n    grating = Grating(**grating_params)\n\n    # Create the mirror.\n    mirror = Plane_Mirror(**mirror_params)\n\n    # Create the PGM.\n    pgm = PGM(grating=grating, mirror=mirror)\n\n    return pgm\n\ndef shadow_dict(pgm: PGM)-> dict:\n    \"\"\"\n    Create a dictionary of parameters for the PGM object.\n\n    Parameters\n    ----------\n    pgm : PGM\n        The PGM object.\n\n    Returns\n    -------\n    pgm_dict : dict\n        Dictionary of parameters for the PGM object.\n    \"\"\"\n    keys = [\n        'line_density', \n        'energy', \n        'cff', \n        'order', \n        'grating_dimensions', \n        'voffset', \n        'hoffset', \n        'axis_voffset', \n        'axis_hoffset', \n        'mirror_dimensions',\n        'theta', \n        'alpha',\n        'beta']\n    values = [\n        pgm.grating.line_density, \n        pgm.grating.energy, \n        pgm.grating.cff, \n        pgm.grating.order, \n        pgm.grating.dimensions, \n        pgm.mirror.voffset, \n        pgm.mirror.hoffset, \n        pgm.mirror.axis_voffset, \n        pgm.mirror.axis_hoffset, \n        pgm.mirror.dimensions,\n        pgm.mirror.theta, \n        pgm.grating.alpha,\n        pgm.grating.beta]\n    \n    pgm_dict = dict(zip(keys, values))\n\n    return pgm_dict\n\ndef config_oe(pgm: PGM, grating_oe:OE, mirror_oe:OE, slit1_oe:OE, slit2_oe:OE, T_SOURCE = 0, T_IMAGE = 0)-> None:\n    \"\"\"\n    Configures the given OEs appropriately \n    for the given PGM object.\n\n    Parameters\n    ----------\n    pgm : PGM\n        The PGM object.\n    grating_oe : OE\n        The grating OE.\n    mirror_oe : OE\n        The mirror OE.\n    slit1_oe : OE\n        The first slit OE to handle blockage\n        by upstream edge of grating.\n    slit2_oe : OE\n        The second slit OE to handle blockage\n        by downstream edge of mirror.\n    T_SOURCE : float\n        The source distance relative to the centre of the grating.\n        Default is 0.\n    T_IMAGE : float\n        The image distance relative to the centre of the grating.\n        Default is 0.\n    \n    Returns\n    -------\n    None\n    \"\"\"\n    \n    pgm.generate_rays()\n    delta_y_mirror, delta_y_grating = pgm.find_offset()\n    \n    alpha_rad = np.deg2rad(pgm.grating.alpha)\n    beta_rad = np.deg2rad(pgm.grating.beta)\n    theta_rad = np.deg2rad(pgm.theta)\n    a = pgm.mirror._hoffset\n    c = pgm.mirror._voffset\n    v = pgm.mirror._axis_voffset\n    h = pgm.mirror._axis_hoffset\n    b = pgm.beam_offset\n    \n\n    print(Fore.YELLOW + f\"Initialising grating, \\n alpha= {pgm.grating.alpha}, \\n beta= {pgm.grating.beta}, \\n offset = {delta_y_grating} mm, \\n line_density= {pgm.grating.line_density}\"+ Fore.RESET)\n    #grating_oe.ALPHA = 180\n    grating_oe.DUMMY = 0.1\n    grating_oe.RULING = pgm.grating.line_density\n    grating_oe.F_MOVE = 1\n    grating_oe.F_GRATING = 1\n    grating_oe.OFFY = delta_y_grating\n    grating_oe.T_INCIDENCE = pgm.grating.alpha\n    grating_oe.T_REFLECTION = np.abs(pgm.grating.beta)\n    grating_oe.RWIDX1 = pgm.grating._width()/2\n    grating_oe.RWIDX2 = pgm.grating._width()/2\n    grating_oe.RLEN1 = pgm.grating._length()/2\n    grating_oe.RLEN2 = pgm.grating._length()/2\n    grating_oe.FHIT_C = 1\n    #grating_oe.F_RIPPLE = 0\n    grating_oe.ORDER = -1*pgm.grating.order\n\n    b_prime = np.abs(delta_y_grating + b)\n    d = b_prime / (np.cos(alpha_rad - (np.pi/2 + beta_rad)))\n    grating_oe.T_SOURCE = d\n    grating_oe.T_IMAGE = 0\n\n\n    print(Fore.GREEN + \"Grating initialised\"+ Fore.RESET)\n\n    print(Fore.YELLOW + f\"Initialising mirror, \\n theta = {pgm.theta} \\n offset = {delta_y_mirror} mm\"+ Fore.RESET)\n    \n    #mirror_oe.ALPHA = 0\n    mirror_oe.DUMMY = 0.1\n    mirror_oe.T_INCIDENCE = pgm.theta\n    mirror_oe.T_REFLECTION = pgm.theta\n    mirror_oe.F_MOVE = 1\n    mirror_oe.OFFY = delta_y_mirror\n    mirror_oe.RWIDX1 = pgm.mirror._width()/2\n    mirror_oe.RWIDX2 = pgm.mirror._width()/2\n    mirror_oe.RLEN1 = pgm.mirror._length()/2\n    mirror_oe.RLEN2 = pgm.mirror._length()/2\n    mirror_oe.T_INCIDENCE = pgm.theta\n    mirror_oe.T_REFLECTION = pgm.theta\n    mirror_oe.FHIT_C = 1\n    mirror_oe.FWRITE = 0\n    mirror_oe.F_G_S = 2\n    #mirror_oe.F_REFLEC = 0\n    #mirror_oe.F_RIPPLE = 0\n    mirror_oe.T_IMAGE = 0\n    mirror_oe.T_SOURCE = 0\n\n    print(Fore.GREEN + \"Mirror initialised\"+ Fore.RESET)\n\n\n\n\n    slit2_oe.F_REFRAC = 2\n    slit2_oe.F_SCREEN = 1 #any screens 1-yes 0-no\n    slit2_oe.I_SLIT = np.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) #Aperature 1-yes 0-no\n    slit2_oe.N_SCREEN = 1\n    slit2_oe.RX_SLIT = np.array([pgm.mirror._width(), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    slit2_oe.RZ_SLIT = np.array([1000, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    slit2_oe.T_INCIDENCE = 0.0\n    slit2_oe.T_REFLECTION = 180.0\n\n    slit2_oeT_SOURCE = delta_y_grating*np.cos(beta_rad) - (h - (a-c*1/np.tan(theta_rad))*np.sin(theta_rad))\n    slit2_oeT_IMAGE = -1*slit2_oe.T_SOURCE\n\n    \n\n    slit1_oe.F_REFRAC = 2\n    slit1_oe.F_SCREEN = 1 #any screens 1-yes 0-no\n    slit1_oe.I_SLIT = np.array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) #Aperature 1-yes 0-no\n    slit1_oe.N_SCREEN = 1\n    slit1_oe.RX_SLIT = np.array([pgm.mirror._width(), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    slit1_oe.RZ_SLIT = np.array([1000, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    slit1_oe.T_INCIDENCE = 0.0\n    slit1_oe.T_REFLECTION = 180.0\n\n\n    \n    B_prime = delta_y_grating*np.cos(beta_rad)\n    D_y = -(pgm.mirror._voffset / np.sin(theta_rad) + (pgm.mirror._hoffset - pgm.mirror._voffset*1/np.tan(theta_rad)) * np.cos(theta_rad)) + pgm.mirror._axis_voffset\n    delta_z_2 = B_prime - D_y\n    #print('correct?',-(pgm.mirror._voffset / np.sin(theta_rad) + (pgm.mirror._hoffset - pgm.mirror._voffset*1/np.tan(theta_rad)) * np.cos(theta_rad)) + pgm.mirror._axis_voffset)\n    slit2_oe.CZ_SLIT = np.array([-500+delta_z_2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])#Centre of slit (z)\n    B_prime_z = -1*delta_y_grating*np.sin(beta_rad)\n    D_z = -((a-c*1/np.tan(theta_rad)*np.sin(theta_rad))) + h\n    print(D_z)\n    slit2_oe.T_SOURCE = D_z - B_prime_z\n    slit2_oe.T_IMAGE = -1*slit2_oe.T_SOURCE + T_IMAGE\n    print(Fore.GREEN + \"Initialisation complete\"+ Fore.RESET)\n\n    s = (b + v - c*np.sin(theta_rad))/np.cos(theta_rad) - a\n    delta_z_1 = (pgm.grating._length()/2)*np.cos(beta_rad) - (v - c*np.sin(theta_rad) - (s + a)*np.cos(theta_rad))\n    s = (np.abs(b) + v - c*np.sin(theta_rad))/np.cos(theta_rad) - a\n    \n    slit1_oe.T_IMAGE =  (pgm.grating._length()/2)*-1*np.sin(beta_rad) + (h - c*np.cos(theta_rad) - (s + a)*np.sin(theta_rad))\n    slit1_oe.T_SOURCE = T_SOURCE - slit1_oe.T_IMAGE - grating_oe.T_SOURCE\n    \n    slit1_oe.CZ_SLIT = np.array([500+delta_z_1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])\n    \n    distances = {\n        'grating_oe.T_SOURCE': grating_oe.T_SOURCE,\n        'grating_oe.T_IMAGE': grating_oe.T_IMAGE,\n        'mirror_oe.T_SOURCE': mirror_oe.T_SOURCE,\n        'mirror_oe.T_IMAGE': mirror_oe.T_IMAGE,\n        'slit1_oe.T_SOURCE': slit1_oe.T_SOURCE,\n        'slit1_oe.T_IMAGE': slit1_oe.T_IMAGE,\n        'slit2_oe.T_SOURCE': slit2_oe.T_SOURCE,\n        'slit2_oe.T_IMAGE': slit2_oe.T_IMAGE,\n        'delta_z_1': delta_z_1,\n        'delta_z_2': delta_z_2,\n        'mirror_oe.OFFY': delta_y_mirror,\n        'grating_oe.OFFY': delta_y_grating,\n        'd': d,\n        'b_prime': b_prime,\n        'B_prime': B_prime\n\n    }\n    \n    \n    \n    return delta_z_2, distances\n\n\ndef intensity(beam:Beam)-> float:\n    \"\"\"\n    Calculate the intensity of the given beam.\n\n    Parameters\n    ----------\n    beam : Beam\n        The beam object.\n\n    Returns\n    -------\n    intensity : float\n        The intensity of the beam.\n    \"\"\"\n    return np.sum([beam.getshonecol(7,nolost=1)**2,\n                   beam.getshonecol(8,nolost=1)**2,\n                   beam.getshonecol(9,nolost=1)**2])\n\n\ndef get_eff(file, order, E, cff, polarisation='s', interpolate_energy=True, return_interpolate=False):\n    \"\"\"\n    Reads the grating efficiencies from a JSON file.\n    \n    Parameters\n    __________\n    \n    file: str \n        path to JSON file containing grating efficiencies\n    order: int \n        1, 2, 3, 4, or 5\n    E: float \n        Energy 50 to 15000 eV\n    cff: float \n        cff value from 1.2 to 3 in steps of 0.2\n    polarisation: str\n        's' for sigma polarisation\n        'p' for pi polarisation\n        'd' for diagonal polarisation\n        'c' for circular polarisation\n    extrapolate_energy: bool\n        True to return cubic extrapolated efficiency at given E\n        False to return an array of energy and efficiency as supplied by file\n        \n    \"\"\"\n    with open(file, 'r') as f:\n        data = json.load(f)\n    \n    order_index = int(np.abs(order))-1\n    cff_index_dict = {f'{x:.1f}': y for x, y in zip(np.arange(1.2,3.2, 0.2), range(0, 11))} \n    cff_index = cff_index_dict[f\"{cff}\"]\n    energy = data['order'][order_index]['cff'][cff_index]['energy']\n    eff = data['order'][order_index]['cff'][cff_index][polarisation]\n    \n    if interpolate_energy == True:\n        energy_interpolate = CubicSpline(energy, eff)\n\n        if return_interpolate == True:\n            return energy_interpolate\n        else:\n            return energy_interpolate(E)\n\n    else:\n        return np.hstack(energy, eff)\n\n\ndef initial_read(file, polarisation='s'):\n    with open(file, 'r') as f:\n        data= json.load(f)\n    order_len = len(data['order'])\n    order_list = [order + 1 for order in range(order_len)]\n    cff_dict = {i:[data['order'][i-1]['cff'][j]['cff'] for j in range(len(data['order'][i-1]['cff']))] for i in order_list}\n    #energy_dict = {i:data['order'][i-1]['cff']['energy']}\n    master_dict = {order+1: \n                   {cff: \n                    np.array([data['order'][order]['cff'][cff_dict[order+1].index(cff)]['energy'], \n                              data['order'][order]['cff'][cff_dict[order+1].index(cff)]['s']]) for cff in cff_dict[order+1]} for order in range(order_len)}\n    return order_list, cff_dict, master_dict", "type": "text"}, {"name": "pgmcomponents\\geometry\\__init__.py", "content": "from .geometry import *\n#from .light import *", "type": "text"}, {"name": "pgmcomponents\\geometry\\geometry.py", "content": "\"\"\"\nA module containing classes for simple 3D geometry\nused in ray tracing of X-ray optics.\n\nAuthor: Patrick Wang\nEmail: patrick.wang@diamond.ac.uk\n\nVersion: 0.2.2\nDate: 2023-09-15\n\n\"\"\"\nfrom __future__ import division, print_function\nimport numpy as np\nfrom colorama import Fore\n\nclass Ray3D(object):\n    \"\"\"\n    A class for a simple 3D ray\n\n    Parameters\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n    \n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the ray\n\n    Attributes\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n\n    \"\"\"\n    def __init__(self, position, vector):\n        self._position = position\n        vector_mag = np.linalg.norm(vector)\n        if vector_mag == 0:\n            raise ValueError(\"Vector magnitude cannot be zero\")\n        self._vector = vector / vector_mag\n\n    def __repr__(self):\n        # use f-string\n        return f\"Ray3D(position={self.position}, vector={self.vector})\"\n    @property\n    def position(self):\n        return self._position\n    \n    @position.setter\n    def position(self, value):\n        self._position = value\n    \n    @property\n    def vector(self):\n        return self._vector\n    \n    @vector.setter\n    def vector(self, value):\n        self._vector = value / np.linalg.norm(value)\n\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\n\n\nclass Point3D(object):\n    \"\"\"\n    A class for a simple 3D point.\n\n    Parameters\n    ----------\n    x : float\n        The x coordinate of the point\n    y : float\n        The y coordinate of the point\n    z : float\n        The z coordinate of the point\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the point\n    __add__ : Point3D\n        Adds two points together\n    __sub__ : Point3D\n        Subtracts two points\n    __eq__ : bool\n        Checks if two points are equal\n    __ne__ : bool\n        Checks if two points are not equal\n    __getitem__ : float\n        Returns the x, y or z coordinate of the point\n    __setitem__ : float\n        Sets the x, y or z coordinate of the point\n    __iter__ : float\n        Returns an iterator over the point\n    __len__ : int\n        Returns the length of the point\n    __hash__ : int \n        Returns the hash of the point\n    __copy__ : Point3D\n        Returns a copy of the point\n    __deepcopy__ : Point3D\n        Returns a deep copy of the point\n    copy : Point3D\n        Returns a copy of the point\n    distance : float\n        Finds the distance between two points\n    \"\"\"\n\n    def __init__(self, x, y, z):\n        self._point = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        # f-string\n        return \"Point3D(x={}, y={}, z={})\".format(self.x, self.y, self.z)\n    \n    def __add__(self, other):\n        return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other._point)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._point, other._point)\n    \n    def __getitem__(self, key):\n        return self._point[key] \n    \n    def __setitem__(self, key, value):\n        self._point[key] = value\n\n    def __iter__(self):\n        return iter(self._point)    \n\n    def __len__(self):\n        return len(self._point)\n    \n    def __hash__(self):\n        return hash(self._point.tostring())\n    \n    def __copy__(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Point3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def distance(self, other):\n        # use point property rather than accessing other._point\n        return np.linalg.norm(self._point - other._point)\n    \n    @property\n    def x(self):\n        return self._point[0]\n    \n    @x.setter\n    def x(self, value):\n        self._point[0] = value\n\n    @property\n    def y(self):\n        return self._point[1]\n    \n    @y.setter\n    def y(self, value):\n        self._point[1] = value\n\n    @property\n    def z(self):\n        return self._point[2]\n    \n    @z.setter\n    def z(self, value):\n        self._point[2] = value\n\n    @property\n    def list(self):\n        return self._point.tolist()\n    \n\nclass Vector3D(object):\n    \"\"\"A class for a simple 3D vector\n    \n    Parameters\n    ----------\n    x : float\n    The x component of the vector\n    y : float\n    The y component of the vector\n    z : float\n    The z component of the vector\n    \n    Methods:\n    ----------\n    __repr__ : str\n    Returns a string representation of the vector\n    __add__ : Vector3D\n    Adds two vectors together\n    __sub__ : Vector3D\n    Subtracts two vectors\n    __mul__ : Vector3D\n    Finds the dot product of two vectors\n    __div__ : Vector3D\n    Finds the cross product of two vectors\n    __abs__ : float\n    Finds the magnitude of the vector\n    __neg__ : Vector3D\n    Finds the negative of the vector\n    __eq__ : bool\n    Checks if two vectors are equal\n    __ne__ : bool\n    Checks if two vectors are not equal\n    __getitem__ : float\n    Returns the x, y or z component of the vector\n    __setitem__ : float\n    Sets the x, y or z component of the vector\n    __iter__ : float\n    Returns an iterator over the vector\n    __len__ : int\n    Returns the length of the vector\n    __hash__ : int\n    Returns the hash of the vector\n    __copy__ : Vector3D\n    Returns a copy of the vector\n    __deepcopy__ : Vector3D\n    Returns a deep copy of the vector\n    copy : Vector3D\n    Returns a copy of the vector\n    dot : float\n    Finds the dot product of two vectors\n    cross : Vector3D\n    Finds the cross product of two vectors\n    norm : float\n    Finds the magnitude of the vector\n    normalize : Vector3D\n    Normalizes the vector\n    angle : float\n    Finds the angle between two vectors\n    rotate : Vector3D\n    Rotates the vector around an axis\n    rotate_x : Vector3D\n    Rotates the vector around the x axis\n    rotate_y : Vector3D\n    Rotates the vector around the y axis\n    rotate_z : Vector3D\n    Rotates the vector around the z axis\n\n    \"\"\"\n    def __init__(self, x, y, z):\n        self._vector = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        return f\"Vector3D(x={self.x}, y={self.y}, z={self.z})\"\n    \n    def __add__(self, other):\n        return Vector3D(self.x + other[0], self.y + other[1], self.z + other[2])\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __mul__(self, other):\n        if isinstance(other, (int, float)):\n            return Vector3D(self.x*other, self.y*other, self.z*other)\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def __div__(self, other):\n        # np.cross returns np ndarray but Vector3D expects x, y, z params\n        cp = np.cross(self._vector, other._vector)\n        return Vector3D(cp[0],cp[1],cp[2])\n    \n    def __abs__(self):\n        return np.linalg.norm(self._vector)\n    \n    def __neg__(self):\n        return Vector3D(-self.x, -self.y, -self.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._vector, other._vector)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._vector, other._vector)\n    \n    def __getitem__(self, key):\n        return self._vector[key]\n    \n    def __setitem__(self, key, value):\n        self._vector[key] = value\n\n    def __iter__(self):\n        return iter(self._vector)\n    \n    def __len__(self):\n        return len(self._vector)\n    \n    def __hash__(self):\n        return hash(self._vector.tostring())\n    \n    def __copy__(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def dot(self, other):\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def cross(self, other):\n        # Vector3D expects x, y, z\n        return Vector3D(np.cross(self._vector, other._vector))\n    \n    def norm(self):\n        return np.linalg.norm(self._vector)\n    \n    def normalize(self):\n        return Vector3D(self.x/self.norm(), self.y/self.norm(), self.z/self.norm())\n    \n    def angle(self, other):\n        return np.arccos(self.dot(other)/(self.norm()*other.norm()))\n    \n    def rotate(self, axis, angle):\n        axis = axis.normalize()\n        return Vector3D(self.x*np.cos(angle) + (1 - np.cos(angle))*axis.x*axis.x + np.sin(angle)*(axis.y*self.z - axis.z*self.y),\n                        self.y*np.cos(angle) + (1 - np.cos(angle))*axis.y*axis.y + np.sin(angle)*(axis.z*self.x - axis.x*self.z),\n                        self.z*np.cos(angle) + (1 - np.cos(angle))*axis.z*axis.z + np.sin(angle)*(axis.x*self.y - axis.y*self.x))\n    \n    def rotate_x(self, angle):\n        return Vector3D(self.x, self.y*np.cos(angle) - self.z*np.sin(angle), self.y*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_y(self, angle):\n        return Vector3D(self.x*np.cos(angle) + self.z*np.sin(angle), self.y, -self.x*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_z(self, angle):\n        return Vector3D(self.x*np.cos(angle) - self.y*np.sin(angle), self.x*np.sin(angle) + self.y*np.cos(angle), self.z)\n    \n    @property\n    def x(self):\n        return self._vector[0]\n    \n    @x.setter\n    def x(self, value):\n        self._vector[0] = value\n\n    @property\n    def y(self):\n        return self._vector[1]\n    \n    @y.setter\n    def y(self, value):\n        self._vector[1] = value\n\n    @property\n    def z(self):\n        return self._vector[2]\n    \n    @z.setter\n    def z(self, value):\n        self._vector[2] = value\n\n    def to_point(self)-> Point3D:\n        \"\"\"\n        Converts the vector to a Point3D\n        \"\"\"\n        return Point3D(self.x, self.y, self.z)\n\n\nclass Plane(object):\n    \"\"\"\n    A class for a simple plane\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    *args\n        Either a point and a normal vector, or three points defining the plane, np.array_like\n\n    Attributes\n    ----------\n    point : array_like\n        A point on the plane\n\n    normal : array_like\n        The normal vector of the plane\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the plane\n    __eq__ : bool\n        Checks if two planes are equal\n    intersectQ : bool\n        Checks if the plane intersects another plane or ray3d\n\n    \"\"\"\n\n    def __init__(self, *args):\n        if len(args) == 0:\n            print(\"No arguments given, plane at origin with normal (0, 0, 1) initialised! Tread carefully!\")\n            self._point = np.array([0, 0, 0])\n            self._normal = np.array([0, 0, 1])\n\n\n        if len(args) == 2:\n            self._point = args[0]\n            self._normal = args[1]\n\n        elif len(args) == 3:\n            v1 = args[2] - args[0]\n            v2 = args[1] - args[0]\n\n\n            self._normal = np.cross(v1, v2) / np.linalg.norm(np.cross(v1, v2))\n            self._point = args[0]\n\n        self.d = -self._normal.dot(self._point)\n\n    def __repr__(self):\n        #f-string\n        return \"Plane(point={}, normal={})\".format(self._point, self._normal)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other.point) and np.array_equal(self._normal, other.normal)\n    \n    @property\n    def point(self):\n        return self._point\n    \n    @point.setter\n    def point(self, value):\n        self._point = np.array(value)\n\n    @property\n    def position(self):\n        return self._point\n    \n    @position.setter\n    def position(self, value):\n        self._point = np.array(value)\n\n    @property\n    def normal(self):\n        return self._normal\n    \n    @normal.setter\n    def normal(self, value):\n        self._normal = np.array(value)\n            \n    # rename intersect_q\n    def intersectQ(self, other, atol=1e-6):\n        \"\"\"\n        Checks if the plane intersects another plane or ray3d\n\n        Parameters\n        ----------\n        other : Plane or Ray3D\n            The other plane or ray3d\n        atol : float\n            The absolute tolerance for the dot product of the normal vectors\n\n        Returns\n        ----------\n        bool\n            True if the plane intersects the other plane or ray3d, False otherwise\n        Point3D or None\n            The point of intersection if the plane intersects the other plane or ray3d, None otherwise\n        \"\"\"\n    \n        if isinstance(other, Plane):\n            return not np.isclose(self.normal.dot(other.normal), 1.0, atol=atol), None\n\n        elif isinstance(other, Ray3D):\n            if not np.isclose(self.normal.dot(other.vector), 0.0, atol=atol):\n                w = other.position - self.point\n                fac = -self.normal.dot(w) / self.normal.dot(other.vector)\n                plane_intersect = w + fac * other.vector + self.point\n                return True, plane_intersect\n            \n            else:\n                raise ValueError(\"The plane and ray are parallel\")    \n        # return type is different to return type from if and elif above\n        print(Fore.RED + 'Not handled!' + Fore.RESET)\n\n\n\n# Image class already defined\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\ndef calc_beam_size(electron_size: float,\n                   electron_div: float,\n                   wavelength: float,\n                   distance: float,\n                   length: float,\n                   num_of_sigmas=3,\n                   insertion_device='undulator') -> float:\n    \"\"\"\n    Calculate the beam size based on the electron size and divergence.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n    electron_div : float\n        The electron divergence in urad\n    wavelength not photon_energy in params\n    photon_energy : float\n        The photon energy in eV\n    distance : float\n        The distance from the source to the image plane in m\n    length : float\n        The length of the insertion device in m\n    num_of_sigmas : int\n        The number of sigmas to use when calculating the beam size\n    insertion_device : str\n        The type of insertion device, can be 'undulator' or 'wiggler', default is 'undulator'\n    \n    Returns\n    ----------\n    float\n        The RMS photon beam size at distance in mm\n\n    \"\"\"\n    if insertion_device == 'undulator':\n        source_size = calc_source_size(electron_size, wavelength, length)\n        source_div = calc_source_div(electron_div, wavelength, length)\n        return np.sqrt(source_size**2 + (source_div*distance)**2)*1e3*num_of_sigmas\n    else:\n        raise NotImplementedError(\"Only undulator is currently supported\")\n        \n\n\ndef calc_source_size(electron_size: float, wavelength:float, length:float)-> float:\n    \"\"\"\n    Calculates the source size based on provided parameters.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source size in m\n    \"\"\"\n    return np.sqrt((electron_size*1e-6)**2 + (wavelength*1e-9*length/(2*np.pi**2)))\n\ndef calc_source_div(electron_div: float, wavelength: float, length: float)-> float:\n    \"\"\"\n    Calculates the source divergence based on provided parameters.\n\n    Parameters\n    ----------\n    electron_div : float\n        The electron divergence in urad\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source divergence in rad\n    \"\"\"\n    return np.sqrt((electron_div*1e-6)**2 + (wavelength*1e-9/(2*length)))", "type": "text"}, {"name": "static\\pgm.png", "content": "iVBORw0KGgoAAAANSUhEUgAAA0gAAAHuCAYAAAClPSwBAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAPuESURBVHhe7J0HYBTF28afhFQSCKGE3qv0pnQRG9hQVOyKWLH9Rex+KmCvYBcrYMWKWEFUqgLSe5ESSugQUkggbb9953Zze8nd5ZLcJVeeH+ztuzOz5fY2u/PsO/NOmKYDQgghhBBCCCEIN+aEEEIIIYQQEvJQIBFCCCGEEEKIAQUSIYQQQgghhBhQIBFCCCGEEEKIAQUSIYQQQgghhBhQIBFCCCGEEEKIAQUSIYQQQgghhBhQIBFCCCGEEEKIAQUSIYQQQgghhBhQIBFCCCGEEEKIAQUSIYQQQgghhBhQIBFCCCGEEEKIAQUSIYQQQgghhBhQIBFCCCH+SO4/+PnJi3H38FboG9MKPWekQDOyCCGE+A4KJEIIIcQfieyLC5+agEubHsKik93Rq20thBlZpeWMM85AWFhZ1yaEkNCCAokQQgjxMuPGjcOUKVOMpXKgHcTBXSeBjt3Qp0m0kUgIIcSXUCARQgghXmb8+PHeEUgZ67FhdQ7C+3XCabFl9wDVqFFDzZOTk9WcEEKIayiQCCGEEL9EQ87W+fhzS1M06dMGLcrRQu6SSy7BwIEDcezYMSOFEEKIKyiQCCGEEL8kC/s3rMYaNEPnlkmIMFLLwo033oi5c+eia9euRgohhBBXUCARQgghXmbOnDl47bXXjKUyom3D6vnbkJnYBX1axwMZf2P26+fh2t6xCGt1OS6ZtRsnjKKEEEK8BwUSIYQQ4mUkaly5vTVZq7H6nyyEDe6FS3PexeiL/8aW09/G8y8Px9AD3+HHKX9jPeN+E0KI16FAIoQQQvyQgn0rsXwDEI0VePCDdrhl1oO4q1sLNOncG+2qAWEJ8dBnHiFR9STMtzSzI4QQ4h4KJEIIIcTLiAdp9OjRxlJZOIlD6xZjnhaHsDoD8cwTZ6NjpERp0JCzbTEW7mtW7sANhBBCnEOBRAghhHiZefPmYdWqVcZSWTiE7au2IjXxejz00GB0UuJIyMSe1cuwBh3Qv3ODcgVuIIQQ4hwKJEIIIcTfyFmGpb8fAU45Bd2TLDJI24H1i3Yhs2M/DG4bZySWTLNmzTB27Fg1J4QQ4h4KJEIIIcTP0PYtwaLFGuKG9ET/KEs7uox/sXReVqkHjpUw39IPiQKJEEJKhgKJEEII8TKappUjIEIeMneswSqtA9p1boJEI1X1P1IDx7ZAqwHt0frEavy+KU1PJYQQ4k0okAghhBC/IhXbl6/BpvjTcE7XOrD7icyBY6ujVv4WfD7yZ2ytFmPJd01ycrISbMeOHTNSCCGEuIICiRBCCPEntO3YNLcxhr44Etc1iDQShUhUa9YRA2IKcHDtIUS//gDubBht5LlnypQpGDRoUDkDRxBCSGhAgUQIIYR4EREhEuZbREmZCOuFK3/6BzPu7I8OhdHrhCgk9v8cv2avwtaXr8fwup6JI0IIIaWDAokQQgjxItKMTcJ8S7M2QgghgQcFEiGEEBLkiEeLYb4JIcQzKJAIIYQQL1KjRg0MHDjQIzGSt/+QYZWe/GPpKMg8joKsbCPFNSKQGOabEEI8I0yTWKSEEEIIqTBEGGn5+dDy8hDVtJGRWjpykncjZ2cKols0QXi1eIRFRSK8aqyRSwghpKzQg0QIIYRUEOLxyU3Zj32PPY8NTXoiderXRk7ZOD7vH2xodhqSL70Z2SvXQTtxUnmWisIw34QQ4jkUSIQQQoiPMYVRyv+eUMLoaDmFUVEy5y3C1tOHYfv51yF79QYUZJ9AfnqGkcsw34QQUhrYxI4QQgjxIuKpETHy1GP/h8cefAgFGZnYP/YVp6IoqlljRDVtaCzZyUneg5yde4yl0iPbbTBxHBKGDlbi7KlXXsb48eMxZ84c1R+JEEKIa+hBIoQQQnxAlbx8VKlRHRlz/lYeHmdIP6LMeYuLTfnH0hA/sHeJkwihosg+a44YjmqD+qm+TuHxcUYOIYQQT6AHiRBCCPEipgdJwmpL5DjpExQWHYWsf1fhwPhXdQFkF0v1xo5B3SfHGEul58BTE7B//ARlizCqc+8tqHPfbSg4no2IenVUuiB9kGTq2rWrirJHCCHENfQgEUIIIV6kaJhvES7hsTGI7dIeLX79DK3mT0fCxUNUnjeQ7YvQar9rGWrdeaOKaGcVR4IcizStozgihJCSoQeJEEIIqUBk3CItJ1f1TTq5fZdqKldWJCBDdKtm0HLzlFAihBBSfiiQCCGEkEpCAiiUp4+QNN/zRBhJsz+ZbrzxRg4WSwghJcAmdoQQQogXkbGGRIxIn5+SKG8ABU+9RnI8EsXOk2MihJBQhwKJEEII8SIy1pAEaZCxhwghhAQeFEiEEEIIIYQQYkCBRAghhAQ50vdIBomVMN+EEELcwyANhBBCiBeRfj7SvE7CastECCEksKBAIoQQQgghhBADNrEjhBBCghzToyUBJAghhLiHAokQQgjxIqUJ811RyLHMmzdPHRshhBD3UCARQgghXoRhvgkhJLChQCKEEEIIIYQQAwokQgghJMgZN24cJCYTo+oRQkjJUCARQgghXqRZs2YYO3YsxQghhAQoDPNNCCGEEEIIIQb0IBFCCCFBDsN8E0KI51AgEUIIIV5EQmpLnx8J9e0vMMw3IYR4DgUSIYQQ4kVEjIwfP96vBBIhhBDPoUAihBBCghwJHDFw4EDUqFHDSCGEEOIKCiRCCCEkyLnxxhuVR6tr165GCiGEEFcwih0hhBDiRaSfjwRDEK+NTIQQQgILCiRCCCGEEEIIMWATO0IIISTIkah6YWFhDBxBCCEeQIFECCGEeBF/DPNNCCHEcyiQCCGEEC/CMN+EEBLYUCARQgghQQ7DfBNCiOdQIBFCCCFBDsN8E0KI5zCKHSGEEEIIIYQY0INECCGEEEIIIQYUSIQQQkiQwzDfhBDiORRIhBBCiIesWrVKiQ13SJkzzjgDU6ZMMVIqH7PvEQUSIYSUDAUSIYQQ4iGjR49WIbzdcezYMcybN0+F+/YXGL2OEEI8hwKJEEII8ZBA9cRImO+xY8cqzxYhhBD3UCARQgghHmIKJGlGF0iIQJKmgRRIhBBSMgzzTQghhHiINJsTcSRCSUQHIYSQ4IMCiRBCCAlypF+UCDsRdRR2hBDiHjaxI4QQQoIcEUeDBg3yq8h6hBDir1AgEUIIIaVAAjRccsklLvshSb6MOVRSOHBCCCH+CQUSIYQQUgpEAM2YMSPgAjUQQgjxDAokQgghpBSYkeD8aZyjkmCYb0II8RwKJEIIIaQUlDQWkgzKOnDgQL8KhiDHwjDfhBDiGYxiRwghhJQS8R4xGhwhhAQn9CARQgghpSTQxJEIOvEgufJ6+QKJmCceq4rcJyGEeAMKJEIIISTIEYE0fvz4ChUrIiLnzZtHgUQICTgokAghhJBSYg666iyUtwgChvm29cUSAimYBSGECBRIhBBCSCmRyv/OnTsZ6tsNZjALQggJNCiQCCGEkFJi9kEKFIEkYmXOnDm48cYbjZSKQeJASV8kQggJJKqMC/U2AIQQQkgZOHbsGE6cOOFUdIiHSQIU+Eswh5iYGHUsZrM3QgghrmGYb0IIIYQQQggxYBM7QgghJEB47bXXlBeotE37KiPMtyDN6yRghRw3IYQEChRIhBBCSBkR4VFUrEjTOxEivojeJttOS0tT89JQGWG+BbOJYWmPlxBCKhMKJEIIIaSMNG/eHKNHjzaWbIhgGjRokE+CEwRacAjzeDkWEiEkkKBAIoQQQspIly5d1GCoFYUIDtlnoARbkOMdOHAgLrnkEiOFEEL8HwokQgghpIyYY/1UlEdHIuPJvkobrlvWk5hMpQtcm4mDS5/BMxeciSFjRuL6DudiyCdrcbCUoZ3Ee1TUy0YIIf4MBRIhhBBSRkSojB07trApmSC2pIkoCVi0FKx7dyDaTWiEntNmY+aED/D2awVYdeNrmLgrxyhECCHBCcN8E0IIIQGGBF2wijLvkoPUhdfi0oG5aLT0E3zavbqetg+rXu2L7u9fh7f+GYc7a1WxFfUACdAgXi/xtnEcJkJIIEAPEiGEEBJAiGdKgkOUBhEosp5HgSNy5+K7F3/EvCuuwuhuujg6sQmrvrwBNz97Jm6eeg9GlUIcCdLEToJWMNQ3ISRQoEAihBBCyoEIAGvfHl+G+RZMz1Fp+j3JMUkwiZKPSUPu1h/x8y+5iMZa/HpnX3S+6RN8EPY03k+ehA96J5W64mB6jRjqmxASKFAgEUIICQHykL3nZ8ycdBPGXNMZl/aOVQOYhoVVQ0zfS9Fj5Djc/eV8zD2QrUuE0iHiSMYYMsWHCBdfhfkWTIHkG8GRg6ObV2C+1hYtBl6CS1+ahzVfPIe3r+qNHtUjjTKlw+yLVRpBRwghlQkFEiGEkCBGQ96R3/DDUz0w8JSLcN6DmzG73f9h2AcbsG7dOmzfPhcrXuqH26tNwcxrBmJQvS6oe+0XmJtvrO4BpgDwlceoKNKXZ8SIET7qz3MSaQcOIhVxSGrRHB2qlU0UFUWCVjCSHSEkUKBAIoQQEqTkImPDePzfsIsxbOwaLMV5GPLdNCx98kpc30mv/HfogObNe6B9//tx2xtrMX/mRRgU/x8O/bYCK495rpDMUN8VNRiqjCkk3ilzv54gIs6zMN/RSKibhEQcQfK+o8gzUoEM7P3tVoz462CpPWyC7JdjIRFCAgVGsSOEEBKUaAfexGMXjMYLywv0pWZo+t4v2Hhbe8Tasp2Qim2TB+LUm1rg0jVf4MNOVY109xSN0mYuS1M430Wa8x1aynO464zH8W7YjbjuxRtxS9W12Lf4W7yVNBHfj+qKpDCjICGEBCkUSIQQQoIPbS1m/m8gznsr1bbc8Tl8uuQRXFe1hNr98U/xdN2X8PfP8zDzjJpGov8h3ioRY6XxInlOBvbOfwJvvjQFL27oilZnDME1d9yIR06thxijRGmR5ofi9RJPltkkkRBC/BU2sSOEEBJkaMhd9wYmmOIIiah583kYVpI4EuLOw9VfXY+hdUoXyrqikQFqSyM0RFBJUIqSm9gJ1dDg9Nfw/M/HULB9LrZ8/AjGlUMcCSKQJJBFRTVDJISQ8kCBRAghJMg4hi1zZ2O2sQS0w6ldmyDOWHJPbbS64CHc2SHBWPaMH374QQkWaVonYkCEiC/FgDTdS0tLM5b8n7KEJieEVDDaPqyftxcnjEX/QEPu7n+wJL0UkXO8AAUSIYSQIGMHNi3Zb9hCO3RrUc2wfYM5zpCIoorwlgSa4DCPl2MhlYfj2LvwBbz3/PnocfMMrDdSCfEKWjJWThyOGzccRLpfdb7Jw8nUr3H3WR9jZkbFiSQKJEIIIcFF3jbsWHzSWBCiEB3h28gCFS1YpInd5MmTC/dbEtJfaeDAgR6X9wVz5szx2dhQAcPJHzHp3A4qgqJMQy9sjJ7VZDyuNkgafBX63vEKHp21EXvynNVQs3SBNAGjHvsNK/Iq9m16hZO3D8kLJuL95y7AbUOt5+gy9Bj5KG559Qu8M28TtmVLABZ/4wQOzrkC58f2Qs9PNyIw/LyHsPnjy3HWuvsw6ZYulkAsB7Hq7X6F1+uAAe1wXudIY/y4Yeh07QO4edKfmHs01yhfAmX6XSMR3/kpfPfAFFwz6mv84+GuygsFEiGEEFJOKjrwgOxPRJKnYyFJMAfxaMk6viY9PV3Njx49iuzsbGULcsyVKdD8gionkbl9AzZs2IXtXW/DwEdm4f0125G8Yypm39cJ1xa8ireGnIbWV7+OD1OsIl+ojoYtGisrskkd1FNWsJGJg4sexEPnt0Tzm5fg+/iR6D32T0xZvhm7NryGL2+si/OOvoWPHrgWd51xClq1fBzvpFWCSNLSkZLialDp//DvFz/jtxP/YvnE2Zjn91q2ACfWPI77R/XA7U9egB6R1pdJYcjL+E+/XvVrNrcXmo2Zgoe/34b//vsba94ciqd7LML2B8/GoN4jceVfe9w0zSvv71odTS59Bq9ljcLVk1ZXjOiUKHaEEEJI0FAwX/vkokipuxjTEO26FZlGpu9JTU3V5syZo+3YscNICS0yMzM1Xbhpl1xyiTZlyhQtIyNDS0tLU1PIU7BY+/LyKP2abKm1/3qXkWghd6n2412J6roNv/IzbWGOka44oe39qrvKi35xqb4UZBTs0da+21VrjXgt5roPtR8OO3x5O7nbtbVfnK0Nitf/tq+cpi0vMNIrhFwtfdkj2iOX19Zqv7VOc36EOVr66vHa/84Yqd3yx24t20j1W7J+1N4+L0ZLfOFf7aiRZCdL2/lZJ9t99IbvtHVGqp10LeX7gVo7yU8cqd235biRbsFrv2u+dnzxlVrvsGu0Ozf6/n5ODxIhhJDgIqw5WnW3elbWY8Hqfaio98zi1akIb4kEgvDHJmtxcXGqr5EErhCPVbVq1TBixAh88MEH6Nu3L9555x0cOnTIKB1ihEUiMtpNc8+IHjj3hnPQRTcLvvoGkzdl2dKDHmniNRSX3rEKWy96AdPeuREX14o08ooQ0Rwdr/4en007F7Wb10dT37aeLUIats39BC98m4CkpOpwfoSRqNb5Sbw+52N8cFajckV/9D3Z2PvjU3hk5jW4/aouSDRS7YQjMtLF76Cohgbn34mbOuk/QuoP+OT3HXBsAefN3zUcVU+9A3de+C0mvTgLa0W2+RAKJEIIIUFGA3Q5px86GkvAbuya8Q8W+2N3hXIggSA8EUgnTpxQzes8D/NdNqT/lezngQceQKNGjYxUGyKWJH3RokVYu3atEk3EGWGIbnSKEkjAOizadERZwY2G3I3j8fDoFfgPQ3D5/12Hi6uVFGZfr5hf8D5mDGqF0sWbLC8FyMutoE4wFUHOLHz7+gpkXnkOLm8SZSSWkuhWaNFZ1k3FkX83Y4stVccHv2t4Twy8oh2qTvkYL63KNBJ9AwUSIYSQICMcVU+7A/deaH/gaz9MwdPzDuqPbA/IO4pDWaVXUyIQRISMGjVKeZB87d1p2rRpiUEhJBR4TIz33mGbIkiE1ujRows9ZfK9u3XrhkGDBuHVV1/Fnj17jDXsXHDBBWq+Zs0arx5T8FIDSQmxhh3EaFsw/6MvMUOv74ZdNQIPn+ap5GmKvuc2QISxFNLkHcL+HcuxZv5X+HHij5ib4cn9qwBZS6fig0UN0WRwT3Tzgicuom4NFA6v7ZPfNQ6N+5yFszAP039ei6NGqi+gQCKEEBJ8RJ6Byx4eikHxxjLmYNbTU/DZUfc9prWMP/Dt/d3R5d2VMIeZ9RSzSd3ixYtVyG8J9+1LZH+uxkISr5Hw2muvKU9TaZq0eSKCZJuvv/66+p7SnE4i5EkzurFjx+K9995zCAYhTQ5FLH777bdq+fjx42pOnKHhxI5VmC9mYn8M7uJZEA6FdhQp/zyNl27taos0Vq0nGl85Bjd8vhz/5Tp7NbAC310Xo/+urdDhm936ch6y93yDr58+C9f2jtXT2yDpsv/D3fNTXHS+z0Xmf+/hwwd64UIV2UzKP4Abvt2Ig6Vp/nT0V/z0sVR166PemV3RpbwV9b3jMEK/VsPCRmHc3jz9b/o3fPlAW/QIr4daLyyxVKrN73s2bhyUgGphDZAwaATOfOZbzDhQNEBGDo7+PhinhCXh1Eflb2kbNlzRRP1NSES3+KcXWbZ7CMteSLLljfi+SDj28p7zbBzb8C4+uL8vhqvysn99ikxC/RY90WXgVbh4zK8eCqSD2DB/MdahO87u0aDsguDEBmz6W85XR3Tp19YePMTbv6tBWLOBGNT1OI5/9zf+POnDdnZGXyRCCCEkuCjsHKwcR/oUr8VcPkF7e0emVqz/b8ERLWXe/doDZ1TXkh77XVubU7ae302bNtXi4uLU/nSxYKT6hpUrV6qpKLoY0tauXat17dpVHYcucFTQCF3EaJMnT1ZlZD1Jk2O89957VZ4cu+08FZ8SEhJUGV0EqXWmT5+u1neFBGeQ9WTfe/bsUcdEhOXat9dG6+fGRZCGgjXab3dLkIbGWr1XlxXpNO8uSMNObelLrbWW6Ka1f/FnbcbGndqujdO1X1/opF//jbWk//tT21Lskt6ozbwr3nYsX63Vtn5/sXZ+dD0t6YZHtJtuH6Y9MrymFi+/f+Id2tjdRTvWp2spMy/SBoXV1RJGvqW9tWK7tnvrr9psY3/1nl+s7fPwTyh38XD9uOU666GdMcsL18nhCdq9ibK927WxOzZo391cXZ0zoLXW8etk428/V0tffIN2YdNwLeaa17QJS7ZoO3b8ra344Trt+lZhWtigZ7QPDuSqkjZytaxDm7SdOxdovz1aU99WM63lpKXaunXr9GmrtjXNen4OaytfaWDbZ7HABt445121jq/P15bp+yzI3qyt/eY82+9w19fab7t2aduXb9S2Znlw8vN+1d7tF67v635twuE8I7Eo9mvOeZCGbO3Az4NUkIaws9/Qfjhu36/Xf9dCzHM4XLtzo+9CYFAgEUIICWL0SsW8u7T/9bNEtYvvq7V/9C3tkTfe0F555XFt0nPnabf0idHQ8mJt0JQV2s5cD2t2ThCxMXjwYLUfXwukomRlZWnHjx/Xxo0bZ/+u+lSvXj1t1KhRXhdB7hCB9tprr2nZ2dkqqh0xMQWSVLBXawfNay33gLZnzWTt8web65VKXdA4FenuBNJRbd0brbUmryzTDlhXK1it/XirCPYLtOtWZBiJJge1pc/X0fPqa7UHn6XVO/d57ZX1R+zbLVil/XSbVEStwkIo0HK2PKKNFCFx0VvaD+mWynXOHO2Ty+X7DdGGLz5mJLrDUgHHGfo6RY+xDOR+rb3cUrY3XLvlgXO1M6esUn/TuUdWasuP2EVP/pqbtdoD3nQ8fv149k/voyUiUas5caVW/Mo1z5kLgatw9zuV9ZzrHHhFG62fc5z7kTYn30hTbNBm3l1NX6e/NnjOYSPNAw48r90uEeNavqx9bdWCDlh+n+EfaTPTTdGWraXv+lNbOPk87aLmIiif0t7aYxUrPvhdCzHPYRetz8/7jTTvQ4FECCEk6CnI2qJt+ON57c2HB2nXXNBI6yEVA3l4x/fQGl0xWhv+1k/aj7udeJYChKJeI1eTN0VQSdBr5AxTIMVrUTWjbN4Cc9KvxSa3PKs9POs/7aDTC9FdxTtfy1q7QFtZTFSZYZqdVejNiqaEX56s/eYgFAR7iGfH/W3X5j1aS0/vpvX9ZV+Rv5k0bfOklmqbcU/9ox0xUl1Ttop0wYFPtVeGD9eGD79Tu2vefsdjKBRI8Vrsg39oyUZyMbJWanO2ZRkLdgp2PqJdKcfj1GPiLYFU2nOeox35eYAu3Jxt01wnUavlMvR4cfI33qmd6/J7mlh+n2YttZbmfVNN9bXqZ9+pDX//L+2fYt/DB79rIea2G2tNJ/+nX/m+gX2QCCGEBD1hsa1xylmP4O4X/sLnP+/Gsgz1ghBaxjLs/moivr7rQlzUKA5eaiZfIUgfp0suuQQffvihCsX7xBNPuAza8Omnn0IXQoX9i6RPkPQxkvWlj5EvqF27tmHZkf1LnyRfRtMLDOqi1aT/kJq2DevWrcO6rYeRlr4MOz94DC+c2wp1Sn0hhiO2Y390dRjk8wQy9i3Hjp0lRfuqixZDz8KQYhHGXIR4TvsNv0yR6Hod0LVeLjasX4/1xrR9+3ZkaRIcJRPHF27EmhK7wkSielJd2Ia/TcWew571TwvL24o133yDb76ZhTkHclz83Q7EZVf3QlNjqRixXXFGC2sQDA156VuwfetO/eh9TSnPuX5s+bk5RUJom5jr5CInN0+pF08oSDuEbYbtEae/hBmp6UiR63VdMnZn7UHa7Lfx9a2D0KfY9/Dl72qyG/sPHnNxTsoPBRIhhBDiRUQEuBIq3mbGjBn4+eefVUftqVOnIiMjQ4kfET5WJJCCBFfwdWQ9T5DAEr4OYBEYhCGiegt06NABHVrWQnVvqPO8XfjvzxfwturEn4iEC1/Cu38cNjK9Q8G+9Vi1T6zP8E6PJujYsWPh1LJlN3S7Y6MqFxYmLyGU6YZwVG3cDt2VvQ1r1+/2TJwkNEZTVftujA5Nio/eY6MRWtYtKVpiNlI3f47vJlyCO86vizY1rsbFExZgr5HrP0ShVse+ODseOPnPRqxwOK+HkLxBAj70xKCeTfWSPiSiGhrI9dqhKRrFupMQvvxdKwYKJEIIIcSLSKS3Xr164amnnjJSfIMZNU/ET/Xq1dUUHx+Piy66CB999JHykJmDtaakpKiylU3Xrl3VnALJ2+QiY8PTeOKidmj7yH+Y2+5xXPFBMo4t+wrPXd/QKOMdCj0PLV/G17mGJ9bJVDDzZgwqadgbnbDmF+Oyi2xep8wZi/BXjgc+kGj9ei+nEpCIld891AE9TnkH4zIuRceH52P28aVY+/pwNDHK+BPhLcdg7LPt0XLGRNz23r/4L7tA/xJHsXfBE3h9wmHE3nM/nunl+ahQ4Ql10NKwfYHvf9f6qJkYDw8usTJBgUQIIYR4AWm61qlTJ2Xn5OSokNciWiTUtq9wNhZSzZo11SSce+65KiT34MGD1bI/cPHFF6tmdsR7aCkv4+GLx+LZvKcwdeYkfHPr+RjeqS6qh2Xi6AHvDjYbXrW6XjXVObofe9Lch833iPA+uODuM9BO7H+m4bV5hzxuJlZmtBX4ecxluPzdzug5bzqWjb0Bdw1sh5ax4cg/vAfrjGKuiURMVAVXocMaoesdb+Dxi4+iwZSBaFO1CsLCa6HR6BNIfWYBlr56ATo5NLF0T3idVjhFnDR/b8eGPFuaV/HZ75qOlO3iMUtA/aRqPhsHiwKJEEIIKSfiqZEmbNKfxIo0ebvvvvvUeEK+QDwx4kFyRWxsLJo0aaK8TSLYfNXfqDTIuZKJeIt0/Pfzx3h3ayM0ufYSXFvLWR8W7xHeYiAGd9Ar4qlL8fuaY16o9Eah5pnP4qW7pLb+D+b83/v4uITxyspLweaP8NaH6cBZl+G+/kmINtI9JxF1KnoQ39yl+OX+2zDx2vmYuTgDWYc2YV1KOrKXf4lZ/+uHDqUQR4rEzujcXZcX3hK6xfDV73oER/Zk6/O26NbCd83wKJAIIYSQciAC5YYbbjCWnCODqoqHqbIQgSSBEfxBIBFvk4usTKkw5uHk8ROwD3GqIe/ALPyzPEO3s5B67LhewgvEnY0LRzZFPOZj1tNv4sX/0h1FkpaGg8uexAUP/ImdRlKJRPTEhc9PxYfXVgOWvoi7b38D7yQfdy2+8k7ipKprH0fKkYxSizQtOx1q6OSsLKTnWdbO3YQVC9baBn3dfwyHXAaZ2Iftujgpvzj0nIJN7+GFN+uifp146b2G2Npt0aFBtTKIO4PwDuh8Vm1d6G7F+r1FB8b1Er74XfN3YMeqLKBLfwxu4zuRSoFECCGElAPxhoinqCT8IUCCvyCer5Dsh5S3DTsWS2V0G7btOGARM56QVdhcLjflCPYrS0hEm/4D0EevtO9/ZAzOmvA9Pv/jQ0x/9Uyc3fZn7K6bpIsZPe/LL/H0X3Pw+dqjRsUzHemH5QhciSf7/vIPp9tEg6I+ut75Ad67qRbi5ozHo93PRLORD2L49dfj/jFDcMe5TVD/wXycelPPUvXlCat2EW764A/MfqElOs0cg7vOvgb9n/0Ub/++AouSd2Lr1jXY/O83mP31GDx/42g80+ZB3PXH1/j1vPqO0c6OH8Ihvf4MXZ5tO+D8DFdpeyGu6aVXgWc/i+v/9w5e+PVP/PnVrbiv/0CM3NMTfeP1Qv98ixemzcVn367DnsKaelUkNaqvn89kbP3oXdz97SzM/OoJPPjzNohEtWE/bznb92OXskzKes7185PYCK0TF+H3B0dj8P0P4oorrsDjt/dFHxU04RIM+t/juOXdmZh10NOrKgntT++NjliBP5bvhXMtaDZn0yljUzyv/a4GWvJszPy7KuIu64ezokvpNSsNGiGEEFLB7NixQ43DY06ybDJ58mQ1Vo85rVy50sixDcRqzbNizRPbinUdd3mybxPZr6s8OWZ5hJZmkm14GxnDSMY2mjhxopHiGilrPZeVhRyHnA85hyFH9qfaM81s10PU04u0dCPZM8wxdPT1i45dU7BP2/rLXdoDw5to3cPCtOg+12qDnv5G+2H/Ca0g/Vft8/s6an2i62lJNzytPbb0sDF2jDkmk7OxdQQ3+xNyk7WNP43W/u/6NtrA5mF6udZanUvv167/bLG2Nqs8o9Pkalm7f9J+e3ekNuaa9tqQThHqGMK6n6+dMvQ27eKn39demb1Z2+1qQOeUsdoNcsxux9/J0TK2vKu9fU9X2/ZbDtLa3/GyNv7f/VpOwR5t7ZQLtatPi9Wi+92iXTx5ubbTuqus+dqMx9pZzvNX2tcOY6i5O2/lOefpWsrskdqtMqi1+n4upta3a/dt8HBg1pPTtdf7hGthV32pLXN6OlO0ReNkzCt9u82e1T7NdnHOPaKcv6siU9v5aWct3unAx96FAokQQkiFY1aSzUmWTYqKD2ueiAxrnhVrXlExYl3HXZ610l70GM281NRU7eWXX1bbkalGjRoO5VxNRffrDUojNnx1DKVFxLC/HAshAUPBYS159n3aFfd/o/122HE42IKsHdq2Jc9qLw6LV39b4f+b6XqAXAeytJRpPbVqYTdpjySfNNL8mIJ/tC+HR2vhN36nrSmPVvMANrEjhBBS4Ui4Z71yXziZ4Z8F6SujP5/UlH88C/3bdTBybJHizDyZrFjzivb3sa7jLs86gKn01zHT9Uq9ihYnfXkSExORmZmptiPTk08+aazhHut39BZmqO+KGnfJG1jDkxNCPGEfVr/ZD23HNcO1T1+GIUUCcYTFNkOL0x7FmJdux5XxQMEva/GvR83hYtFg6JN4YcgXeG/aaqQaqf5JAbL+fR2vf3serrnnbHTyYes6gQKJEEJIhSNhnkWAmJOrsM/5qWmIqFfHWPI9IngkLLeMHWSNPCfHJ4OySqV+4MCBhZV8QaLUNW5sGzPeHb6IZCfHUfR4AoGJEycWG8yWEOKCtOn44oXNwNC+GBzrShmEIaJRV3SqrZsta6KOpzX82Atw0ws3oO/jH+Kl5BNGoh+Suwgz3vgNyc89gpe7VTcSfUeYJq/GCCGEED8jb/8h7HvsecSd0Qc1Lj0f4fFxRo53EK+LTCKGTERo7Nxpi72VkJDg4OWQsq68QJI3YMAA5VlyxuTJkx32UxmI+BOh5wtPFiHEhxyZiNGtx+CN/m9h+uejcHE1J8Ojakew65thGHxlFuKnT8eSSxqXwguSim2fDcapfz2M2e9dih6lDRnuczKwd/pQdPr6Jnz78XUY5FIkeg8KJEIIIX5JQUYm1tZoh6hmjXHKtkVGavkRD5F4fUxWrlxZKBok0pyIIvFqlVZISFQ2aaI3depUIwXKu8Pw2oSQ8nEImz8agotu2YLdlz+Ee68fiEGtmqJ5RAYisrdi2+b5WDZ9Kv7vq+7oM3Uipl/XEUml1RBaCta9czVGhr+BX0Z1Lf36PiMXGWsewPVDa+LCf/8PtyT5amhYRyiQCCGE+B3iPTry/qfYP36CWm48eSIShg5GlRqeNa0QsSJiR7wm4t0xm80JYsskAujMfv1x/Q03ILFuksoLVOT7infIVVNFf0NEqIRHF48dxSMhHqAdRco/H2L6TzOxdOU6/P37IWxDa9Q5txMaN+iE3v17Y8jgAbiwUZzT8Ngeoe3D+vkaWg5sgBgjqfLRkLt7EVYk9EKv6k48Zz6CAokQQojfUXA8Cxua9ET+sXS1LF6ktuvmIDzWs8e2CKNBgwYpW5rKWQWSldx9BxFZP7DFkXioxo8fr4JduBMbUk4ESWU39RPM3+fee+9Vvw0hhPgTDNJACCHEr8g7fBSHXp1UKI6EnOTdyPp3lUOaO0QoTJ8+XUWfE2+FK1EQkZiAA09NgHaidEN2eoJ4sMRLJWLAl5gBGsRT5g4RUf4yWK0p5Eo6ZkIIqQwokAghhPgV4iU69PqHxpKdA+NfRVh0lLFUMhIlraTobnmpaaoZ35H3P0P+Ue+GnZbmbqtXr64wgWQNKBEIiGdPmgYSQoi/QYFECCHEb5C+R0c/+tKppyhz3iJkr1jrNW9PQfYJZMyep+yU+8Yid+8B5B06opa9gRnkwddeEhFII0aMKHVQicpG+iD5i0eLEEKssA8SIYQQv2V1lUaIH9gbLf/61kgBtPx8hFUpf2dd6X+0//9ewNGpX6tl1c9p9R9AeDjCq8aqtPISFhbmN/1sxJPFMN+EEFIyFEiEEEL8FmcCyVuIJ+q/fkORvWq9kQJ9X33Q/JdPPQ4GQQghJPhgEztCCCEhiXiirOJIkGZ8h15+x6tN7SoCacYnTdYCCel/NHr0aDazI4T4HRRIhBBCQpKMPxcYlh1pZpe9agPCoqJQkHncSC0/vg5GIE34hg0b5jYghESOE0HiL0hQiddffz3ghB0hJPihQCKEEBJySCjxE6vWqyZ1SQ/fpdLi+p+GduvnotH7LwGahvD4OJVeHkSwSD8kGYPIl5QUrU+YN2+eX4XVNvtCBVr0PUJI8EOBRAghJOQIj4lG3SfHoOkX76DOfbcholUTHF/4L8L09IjaNVGlRnWjZPkwx/vxtQfJFEi+Dinubbp06aKEGyGE+BMUSIQQQkIO0zsUUa8OIurUQvW+vdRy0T5J3qAiRIAIsYkTJ7ocENdfkeZ1jBVFCPE3KJAIIYSEPDFdO6h59mrvCyQZsFZCffsS8SBJ/yJ3Te1EiPibh8mTpoGEEFLRUCARQggJeWINgXR87iI19ybS/8gfxkEihBDiGRRIhBBCQh4J1iBkbtqi5oGIhMv2dTAIbyNBI6R5YKAdNyEkuKFAIoQQQnRiu7RHzr+rjSXvIk3bfD3ej2x//PjxxlJx/C3MtyBN7KR/VqAFlyCEBDcUSIQQQohOnOlFmuf9ZnYSPMHX4qSkSHb+FuZbqFGjhpoz1DchxJ+gQCKEEEJ0zH5IvohkJ+IlLS3Np+G+AzXgwcCBAwuFEiGE+AMUSIQQQohObBffBWqoiPGQxEu1cuXKwn05wx9FlHi82MSOEOJPhGkcgIAQQoifsrpKI8QP7I2Wf31rpPgW2V+VNs3QceNCI8U7SNM2EUddu3YNWE8PIYSECvQgEUIIIQYixvK3JCP/WLqR4h1EGMl4SBRHrvGldy3QMb1sEu2P54kQ30OBRAghhBjEDeyr5pnz/lHzQENEmL9FqisJqfiHhYWFdKhvET1yHsxQ7fI7SlPJWvWaqnMzaNAgNUmUQgokQnwPm9gRQgjxWyq6iV3ajJlIvvQW1H1yDOqNHWOkegep/P7www9q8hXiodq5cyecPdqloi0BEfyxv48/H5u3kGaWEq1PvqPMZTnjpIYVi+cbJYpTt9O5iKvTArGJDdXy+u+ewMSJEwNOBBMSaFAgEUII8VsqWiDlJO/GxpZ9fLJPqdS+/vrrmDNnjttACuVBtivhvANNIImwE9EQyOG+TdEjHh7rtHbTDhw9sMsoVZwWZ45S8xrNuiEiKg6xtRqhSmQsYmrUV+kmxw9tx7xnz8DYsWM5sC4hPoYCiRBCiN9S0QJJWFO3o6gJdN6/1kjxDuJBGjlypE89ABLJburUqSqanfR7suLPAknOh4T69veKv9ULJMi8NF6g6IQkVK3VBFWiRAA10IVQjFGqZHKzjmH2Y52D3tNGiD9AgUQIIcRvqQyBlDzsZqT9OAunbFuEqGaNjdTyI5Va6UcyYsQIJZYqGvEuiWh67bXXjBRSFNMLVNQbtHbjVhw9mGKUKk7j3lchsmoN5QUSqtVv69QLVF5+Hd2EAomQCoACiRBCiN9SGQJp//gJOPDUBDT+eAJqjrjCSPUOUtlmJLvKxSqArN4gaZroioQmXVCrVZ9CL1B0tTqIiq9Zai9QeVk77SHsXjzNaRNKQoj3oEAihBDit1SGQMqctwjbzhyO2v+7GQ0njjdSiS8xBYs0syvaNLC0uPIC7TpwDDs2rTZKFaeivEDlYdOPz2H7X5OQmpqqzhUhxDdQIBFCCKlAMrB3/gP4v0v+wbp3v8f8K1sjVqXnIHXhSFx39t9Y9+TnWPBoPzQJqxyBJGMgravVvsL36y3EQyVTIDXDEgHTvHlzXHzxxR5F+TNFT1FvkCdeoMjY6oir27LQCxQVV1MJo0AgZem3WP35GJ8G+iCEUCARQgipMHRxNOtaXHbFPJwsSMfKzm9gxpy7MTRKV0IowIk1d+DKfu/jpwu/xNIvrkKPShJIwvq2fZG3dRe65O8xUryDOc6NTBJQwRe4Csbg76G05fi6dOmixI4gx1nUG+SpF6ha/TaoEh2nvECCBEkIBvav+Q0rPr4d06dPV2MlEUJ8AwUSIYSQCkE78jHuvycJ137YFHtH98HQb2/B8xtfwSN1I2wFCv7ER2ddhKevXoaNt7VXnqXKEki7R96Ho598gzbLZyG2awcjtfxIpV8CNfgyVLOrsZD8TSAV9QJJ8Ii0tDQj1zUSFjuQvUDlgaG+CakYKJAIIYRUMOnY8l53tB3VDtetmIZPu8UbyR/i8QazkbrsY7zdLk4lVZZAOvT6h9g7ZhwaTBiHOvfeYqSWHxECiYmJPhUqEjJbREfR7VeGQDL3JXPTC+RpWGzTC2SGxQ4WL1B5MAVSZUVCJCRUoEAihBBSweQhffYQtDv3ABr8MBNLL26IMOTg6O/D0HPZE/jn0d6oJ63udCpLIJmBGmreMByNJ080Ur2D9B2RDvae9LXxJuJxEO+SN5v2mV6got4gTwZHNb1A5uCooeIFKi8M9U2I76FAIoQQUuFoOx/FNc0nY957c7Hr1naIyPoOL/XZhPpzHsH1NasYpSpPIAmy76jTuuCURb8YKaGJKXrK4gUqOjgqvUDl5+8JF6FmVWD7RltfLUKI96FAIoQQUvEc/xTP9BqB8ef/gX0vtsGu50bgpbO/wZe9asJwHikqUyBt6X4usldv8HqghopAvDmCJ2MumaKnqDfIEy+QIGGxTS9QecJi52Ydw5Gti5SYqt7Qe/2+gg0z1Derb4T4DgokQgghFY+2CNOuHISr017Gb/csxsu7HsKXd3RBklUd6VSmQEq5bywOv/GRvu9v9GPoY6R6h9IImNIinp6igSBEAEn6pk2bUK9ePWWX1Qvkq8FR83NPYNaDbZTwajf0MSOVFGXngqlY/90TWLlyZbnHjCKEOIcCiRBCSCWwB4vGdUff8TFIeuwj/DnubHSMLKKOdCpTIB2d+jV23zQGdZ8cg3pjxxip5UfEUWnG/PEEqxdI5q+//rrq5xQeFYejB1OMUsXxt8FRpflYTEJd9Lj5QyOFFMUM9c2xkAjxHRRIhBBCKoEcHF1wI86YPgJfvHiuU3EkVKZAyl61Hlt6DEbC0MFoNv0jI9U7SES5pk2bFnqSPEGEjymEzD5BgieDo4oXSLwODXpcgtZDRvvMC1RezOZj57/mumlfqJO6YxkWvX4pJk6cqCIWEkK8DwUSIYQQv6UyBZIg+6/Sphk6blxopHgHefMvwiY1NVV5egSr+DG9QTJ5Ojiq1Qt0aMMcxCQ2QL3O56k0QaKf+XvztRPH9qlmfIxm5xqOhUSI76FAIoQQ4rdUtkDadublyJy3GB2PbECVGtWN1LJjip73338fe/fuRV5eHiIiIjzyApV3cFRpmiXrJjbvaaSQQMTsq8VQ34T4DgokQgghfktlC6T94yfgwFMT0Oz7D5Fw8RAj1T1SaS3qDfLUC2QOjipeIIFhsYkzxBvYpUsXdW0RQrwPBRIhhBC/pbIFUtqMmUi+9BaHQA2mF8gqgGTuzgskWAdHLasXyFMkZHZ2aorqexRIzdXEO/LfbxNUc0Fr80DiyNppD2H34mkM9U2Ij6BAIoQQ4rdUlkAymy7tnvEbOr/xOQ7XiMOttSOwY8sGle4MMyy26QUqaXDU9JT1yMk4gtrtTjdSvIdse+HL56H7Te8VCo1AaWIXCH2lKhszmIW1DxshxHtQIBFCCPFbfCWQTC9QUW+Qs8FRl1RtCoSHo1fmDgcvkDk4alm9QKYXwBcR28yO/FaBFCjCY/lHt+DA2t8Zyc4NDPVNiG8JN+aEEEJIUCFeIJkk0peEQ5aKZI8+A1WIbRmHSAZTHTlyJMaPH48ZM2aoJnKRSe2UiOhw2dNKXPR/8DeknHYeorNycPNza5S4aHnO3Up0iOdHvENlbcJWvWEHNZfIbd5GwngLx5JXqnkgIedUvHGkZETcE0K8Dz1IhBBC/BZ3HiSz/09Rb5AzL5AVEUCC9HMxvUDuBke9ZM0snDZlHGbd8xbmNe9hpJYf0wvQ597vfdLs7fCm+Yiv17rwe7HpWhnJ/Q8p3/wPq1cnofVtr6B1yzpGRuXBUN+E+BYKJEIIIX6LCKSwLqfg+6H91LJ4hDJOalixeL5adobZF0gCFEQnJBX2BSrr4KidDu3A1c9fg9VXP4SvTh1mpJYfCUhw4tjeChu0VSrV7oRgwKPtxL7PbsHK5ZuNBBdEd0JS51OR0OxU1GrTD4l1asD5MMVCPnI3vYj5kybhpL5Upe9kDLriLETZMisN8Tr+Na4XRowYgSlTphiphBBvQYFECCGk0nDpBdq4FUcPpmBVeEPsQh6GFhww1rDhbHBUX1X+q+lC5tGHB2HfGcPw5tCHjFTir2hZK7Hzi7uwYd0eI6U56l/6Etp2bY4q+rWUd3g+dkx/Frt2p+l5HdDo6glo3+sURNgKO6Ltwr5Pr8XKFTv1hb5o/b+30bpFLVteJSMeQY6FRIhvoEAihBDiU4qGwzYrdJ4Mjvr93J+wp0NXPHvmzSosdkV5W4py/7T/Q61//8JjExYZKf6PeIwy9m22DTIbYKG+ZSDUsjcHzEHWsgcx97PpxnJvtLt/Mlo0jjOW85H730QsevsNZKrlU9Hqfx+iTYtEtWRF2/8Zlr7wGA4jAQmDP8Bp5/VGpJFX2fw94SJUOXEYRw6YQpAQ4i0YpIEQQki5MEXPDz/8oPpD3HjjjSogQotTuqqACN26dVMBEe677z4VEEGEkUziBZJKsARDkGng/83FmeOWqOhl/cb8VFg5rlKnueqjI83mKkMcCYcbtlPzlsf2q7m3SN2xTIVslnGLvI2II+njlHP8qFqWfUm/J3/H/I3Lfk6qoEpUVcN2RhVENu6LpOrGIpZiz+b/dNlUlHSkrf1RF0f6Gm1Ho+Og0/xGHAkifMXLSgjxPhRIhBBCSkSavYkIeu2115QIEgEkkwigxMREJYCGDRumBNDUqVOVADqaZQuI0PaCh5QAkmAEIoLOeW6NEkGdrnpJiSCJCCeTCCB/7R9zoE4zNW+9/z819xYnMw6p8WxkUFdvI32vBBFKgoTOFsEUCMh1IyHQfUZUPKIsHYlOHD2CPMMuJGsl9i1YDESfi9YXXoaEGP+qMkkfO0E8s4QQ70KBRAghRGH1AplhsU0vkBkW25UXqMu1Ewq9QDJZvUBmWGzTCxRIzb1MUmo1UvO6h7wbVtkUMVlHvD/mjwSmCFRksF0R1j4jJxM5OYaNBCQ2blLEO5SL7M0/Y1d6fdQecheaNPa/a1YCkAjiwSWEeBf2QSKEkBBHBJGIHmeYfYHMwVGjq9VRfYHKOjhqaXluTB+/CY4gx3LktDPx6lXPGinlR5qRzX6ssxp3qemAEUaqkIOslU/g36lfIstIcU4SEtoP0Cv43ZDYpj9qN9cFqPHqU/ry5B5PLfTKSVM+8VYF/wCs+Ti55nH8+fHnxnLRPkh5yNn0ChZPesfWB6nOLeh5z2NIqm4J06Btw+73rsSGiDHoN+JqxEe6jnNXWUiTyUWvX8pQ34T4AAokQggJccRzJN4h8QRJVDgzLLZ4eyobfxJI9/z4EurPnV6xgRoKjiJt4f9h8fe/FPaRiez2NHpeOBhV9Uq7dmIHDs17CWv/XqbnVEXcac+gx2WXIj46lBuIFBVIPdFq1EQ0bRCrn88MZO+ciR0/v4l9h3TpWWcY2l31KJq3rFck1Hc6MtcuRE7Ts1GzemUH9XYOx0IixHf4/g6qHcGu2Q9g3GVJqHnzt/gn10gXtG3459lWiIm5FFcuPAQqNUIIqXhq1LB5gqRPgzSFq96wg1+II9+Tg5yU35H801PYNHsiNnz+MP5btbl4XxSDg/Vbq7mMi1RhhNdEQodzUNtYFCIbd0ONWvUQXb0uYpJ6o/EF96NlkgQlyMLxfx/Hir+WuvwOgYSM9SNT+VmGrZMG4M8ne+LPcYPwz+QXbeII9VGr8wDUqO4s8Ed1xHc632/FkSARHQUzKiQhxHv4ViBpq/Dr7b1w9vcnsPfAMaR+PQPf7pSh1gzCElGrdgQiT67Bqp0ZFEiEEFIJdO3aVc19ESjAf0lH5pKxWDYvHbXPfRztzvkfWnWNRfKXH+JQqvVNnp39tW39hVru26LmFUZkrPMxekyqnoLanVoaC1n69/oH6Tm2J2rK0m9V07pARAZCTZ4/2VgqD9LEbqNqWnj+a8kY8txC9LvpYdSvk4Yjf47B4meHYcXs+cjOLTDKBwZmtD8ZOJkQ4l18K5DCOuOsNzdhy7tv4LUXL0DHzFWYv/6wRQjVROuBZ6Ev2uG09kmMGEEIIZVEzbpNVJOd0ED6oLyDFX/EotWFlxjN0QqQn3McaNISsS6ap+0xooYlHfDueZLzLoN+Ht4030gpLdGIiDP71+gcO4icE/bKvvQ7kn0EmliS/m9Htnq7OWM4wqs2QULnO9Dp2nth851uw4FfHsSaBasDzvMmQVJWLC7rdUMIcYWPNUk4oqPlvVc4qna6AMNab8CmNbuQasvUycGxXVvx95BhuKmj5eZOCCGkQunUrrkKAx0S5G/F/rk/Ap3PQmJhx/xIxHZ5CmfefhtqVK1ipDmyrUY95DRqhNq71hop3uV4mZvunUTecV3cmTRvg6pxtu9QJdr+bM3Yt0WJpUBBgoOk7VptLHmbcEQ0PQ9NO5lh5ffhyB+/IDUrsLxIZqAURrIjxLtUnNOmWge07xqJ7JQjOGy6kLR1WPD+Hpz9f0Nxhh9GiCGEkFChWTPbOD/e6fPh3xQcWISUTVVQvVFjx9DO4bGoEuH+sXik1amIX78S1XJPGCnlx+zvlZ6yXs1LTeYaHFy7zVjohKZnD0Z1Q+OZYcRzMm2DxQYSDXpcrELHSzQ+nxBWB/HNmxoLOllrkHEk21gIDCSoisCxkAjxLhUnkMIao2n76ijYcRB7lUDKQerCFzC61st4qV+dItFjCCGEVCSmQMrP9a8KYmaHbqi1damx5A3ykZe6E5mojpj4eCPNc3Y366Lm7Q96t5mdhPmW4BieoJ1Mxcn0g/q0F8eTf8G2757HjoMSdOAU1L/4CbRqZ+u8L8g2pe+NjEEVaMixS9AQs6+N74lBeJXAqo1ERNk8hDKQMyHEe1ScQEIiGraqj7DVW7EhowBa+rd494ZaGPHomWhDdUQIIZWKKZAy9m1Wc38ho04zRO3ZYyx5gzzkZhyA8zAMJbOvVmM1r39kt5p7CxkDyXEcJNdkz7oef0lEtid7Y95rd2Dzyo0qvUrrQUhqkoRwF89UGbQ3+MdAKgXafqRvsQjd6h1RrWZFiTHvEGsMYEyBRIh3qUCBFKsGsGt9RNxHaVj97ouY/sKDeKRZYN2MCCEkGDEFUvATgchqdRGJVBw/csQSNCgTWRu+wK5k903RdiXavDONk33VN6Zkqg79GeepiGz69MoanHH/e2jb7RTk//cOVr95Pv7++B0cTnU/vGygIIOhylQ68pGfU9L3z8HJzdOxa9NBY7kR6g6+CIkxFVgt8gJVImPVnAKJEO9SgXeCcMTUaoBmeRsx59PbcOXyJzDp0uagPCKEkMrHDPV9LHmlmgcvVRDV/Bw0STqKA3++h50blyNt+2zs+ulZ7MzqjgbNahrlnLOvag0fNPuzUaZxfyJqoGrj89DyyufQtlmCnpCFrHUvYPkXXyDtpC3gwLbZb6koeYHIotcvLXXwEC1rEw6vt/bJOYC0XZuRrZolHsCJQ2twaPELWDn5DaSpfGmaOAEde59SkZWiciFRCaXP2rFdtu9JgUSId6nQe0F4YmM0D1+CnyY1xNUvXYgeDMxACCF+gTlYbG5WCETDqtoHLW96Fa0absbmKU9i6+qdiOp+P9r1bOd+vCGDw006qWZ/9b14riQQQbnG/YnphPr9zzQW9O399w1Sdti8YbnZ6WoeiGMiSRhrjyPvaTuxf9ol+P2xC7FupTUi4A7s++YSzFHNEk/FX89eiBV/b0dsjzvR7urJ6PvE1+g6qDeinQcvrBTk71BEkIR+37/mNyVy5bcToSvTvGfPwMKXz8OKj29X5RmkgRDvEqbpGLbvSXsHD9WehL8+/wELr2hB7xEhhPgRPfoMVGOq+FM/lXt+fAn1507HYxO8PR5O2blkzSycNmUcZt3zFuY172Gklp/lH92CE2kH0G/MT0aKQfpvWP3k7TCH8ZUmdgPP7FwsuJG2+z3Me/VZmI3LzHJ7dWG0+vMxaNznKuxeNC2g+iGJKBCBNPjlLRUYrKFiEAGUn5ONrCO7kH/yuArDLmnuPGbN27RHk/p1lMdXXmqcccYZKt2cE0K8QwUKpFykLxmJLm9egm8nX0bvESGE+BlSyZo3b55fVUb9USB1OrQDVz9/DVZf/RC+OnWYkVp+TDFwznNrCse3UZRJIFVF9Uu/R7/T2+PYjmWq0p13MhO7/v4soASSeFJyjh8tDIUeSJjHLiHWT2YcwvED25Q3rySP2MCBA5X4MUWQzKWPYOj0EySk8vGtQNKOIz0rFtXjwqEdnYzHz9iJ5n88jluSPGnEQAghpCIZN24cxo8fj4H/N9dvKqT+KJBkDKRHHx6EfWcMw5tDHzJSy494D7KP7EFiy9McBapHAukkji8ejXnTfjGWO6HFXZ+iXWt7nyppYideColmR7yD/GaCRH80vUAijHYvnqbSndG8XRc0qesogKzeIEJI5eM7gaStw8x7+uP8Jddg5JhT0fyDnUj89BHc1ZAN6wghxB8xBVKfe7/3m3Fz/FEgCfdP+z/U+vevijmuI99j+dOjccBYdCaQtPS52PLhPdi2yxZ2oErHF9BvxNWIZ2uNcuHKC3Rk6yKk7XIdyVC8QIKIHnqBCAk8fCiQNmL+c5dh9JNVkfnog3j5nktwcd1oI5MQQoi/MXfuXAwaNAjdb3pPDdDpD/irQBqx4FO0nf4OPnpyOrbVqGek+oCCVKQvGo8l33xfOHZTZLfncNrQcxAjg5oWZOLE/iVI+eM1JG+VCHhVEdftQXQadj1qVo+yraAjQSByj6cipkZ9IyVw2LlgKiJi4tDw1MuNFO8ikQNlgGRzDDCJ5OipF8gUPUW9QYSQwKZigzQQQgjxWyQSVrdu3dDhsqc9HrTU1/irQBqyaQFOf/8hzL/tJcxsN8BILT8StSwv57guUM9C1upnsPKLKUg7aWS6IroTkjp1QXyDbqjZ4jQkNmmKyCIxaiXyWYszRwVk8zo59rqdzkWPmz80UkqHiMMTx/YWeoFOph1EdmpKmbxA5pwQEtxQIBFCCCkkLCzMryrS/iqQzEANm4fdiakDrjdSy4+voratnfZQoUckkII0SB+ftV8+hKPb/1XLddoPUqG/65wyyOH8lMULVDOpITqd0opeIEJIMSiQCCGEFFKrbiPkx9QuHmq6kvBXgSQ8N6YPjpx2Jl696lkjpfxIIAUJye3tQBmm8BICRSCl7limBop1Ro2m3ZDYvIcKke0uLHb33qejWnRYYQAEqzeIEEJcQYFECCGkEKlASqhvf6lE+7NAMo/t+RfnIMNL3h5TFJw26jPUbne6kVp+0lPW47+ZE5WY8FeBZHqBJJKfeI7Wf/ekkeOamnWboFO75oVeoKLeIEIIKQsUSIQQQgq58cYbMXXqVJw5bkmldOiPzziCOgd3ocXWFWr5tM1/o1ryRvw5+Ba1vL1Vd6Q0boecqFi1XJlcuXQ6unz5Er589AusrdPcSC0fvgym4A9hvkX4mIOjmn2BJM2dF8gdK1eupDeoEkhOTjas0OXEiRPYv3+/sRS6HDt2TE3BBgUSIYSQQvxhLKTqaYfwyPihxpIjLz75A9Jq1DWWKpeBO5Zj8Jt3498bx+GHzoONVP9D+uKk7VqDw1sWquXYxIao3W6AT35fMyy2eIEk2IQng6OaXiCz6Zt4gB588EEcPnzYKOEaKde+fXtjyfdIhfjkyZKiZhBCAh0KJEIIIYVMmTIFI0eOrNRQ37FZ6bhgxhvovtQc9NTGilMvwM+XjMaJ2HgjpXJpeWw/bn5qGJLPuwHvn3OHkepfSJO99d8+jvSUDUaKnS7XTihT6GyrF8gcHLUkL5DZF8hs+mbtE+SMxMREj95KX3/99WjZsqWx5HsSEhLYdE+nXr16iInhuJYi5kMduQ7kegg2KJAIIYQU4i9jITnzIr13z3vY27AtcqP8Z0y9cROGIyehDp67+R0jpfyIqBGx0ez0keVqaid9ev4a18tYco6z39nV4KjuvECChMU2vUBWb1BpKpHioVm8eDFeffVVLFxo83i5Y86cOS5FFiHexvQgxsXFoXbt2kYqCUYokAghhBQib+3l7X1lh/qOPnEcF02fWOhFkr5Hn4180W+8RyZmoIY3n/kN+6p6x7Owf81vWPHx7ehz7/dIbN7TSC09MsDq+u+eMJacU7VWY7Qecp/yAnk6OKpVAFm9QWVF+nLIGFwijNLS0lTavn378N577ynbFY0bN8auXYETspwEBzJWnIh3EUkkeKFAIoQQ4oCMhSRjzXS66iUjpeKJzDmJqnqF/eGnLlHL4j1KadQWeZH+4z0SLlkzC6dNGYcZ93+EJQ290xdGmqvNe/aMMjeBE0TsLHp9GDIPbDNSPMMbXiBP2bRpkxJGmzfbxi4S2rZti3bt2qn9mgFDnBEfH48FCxaocv6OiL2cnBx6HQIc8R7NmjVLXZfSV/P2228PyqZlxAYFEiGEEAf8JdR3THYmLp/2tJpPuW0i8iKijBz/oVfKBlz86s1eDdQgkexmPdimRIFUlsFRnTFx4kRV6RNB5GvEQymiSCbTWyT9ekTomKLMilREpbldZmamkQL069cPb731VkCII5PmzZsrr4N4Z6tWrWqkkkBDfkeJ4CfXaWpqqpFKghEKJEIICSHk4W4N0WttHiWVVqnAjh49GqtXr8Y5z61BpNFsTLwaJlUiYx36xljzouJqFq4jFf0Tx/YqW3CXF1Ojgb5dW6dvsw9MVG4OGh1IRkzVRBxo0kE1rzNFgYk1Eps1z90xWvNKc4zWPPMYG2Vn4MHXRmHv6RfhrUtsTRLNPBNXxyhY84oeY2Rcotq/9AVK37NOzU+kHcCx3auR4STogol4gYTly5c7CAtXFBVI5nVg4uwaEUwPk4n0XzMpmjdt2jRs27YNBw4cUAIhNjYWXbp0QZMmTZCenm6UsnV6N71V1mtV9tuqVSs0atRIbdeT69jEWZ4cq+xHvreJiDETa57sR4KXmMj2zG0WzZN1zOOXfcyePRvbt29X3793796qz5R0apd1rMdv3be7PFfHKFjz3B2jNU+O0fq7FT1+V3meHr+7Y7TmuTvGonmeHmPRPFfHKFjznHH06FH89NNPDt9FtnHRRRehZs2aRgoJKkQgVQTTp0/XdLVtLBFCCKkMxo4dKy/FCicresXaIW/g/83Vzn9tl5qs6S3OHFWYXjSv+03vFabL+p7mWfcl5cz0agjXzn7498I82bd1PTO9aJ67Y7TmleYYrXnWY5xfvaX2b4PuTvNkMtNlKnr8Z45bovZTdB13U2RMVfVbjRgxQk3WPPl9TQYPHuyQ527SK+7GWsWvAyvWPLGtWNeRvH379mm//fab9vzzzzvkPfzww1p2drZaR/ZrzbMef9FrVa+gaitXrtR0QaclJCQ45Fnx1vGbuDvGonnW81j0+GX64YcftCNHjnh8jEXzrOnujt/dMbo7x+6O35rn6fG7O0ZrnrtjLJrn6TEWzbPi7vhdoQsvh3VkmQQvFeJBEpUub3wuueQSh7cAhBBCKhZP3qpKZ3lpa28NEiCBA0yiq9VxCB5gzatWv22hV0Q8KUe2LlK24C6vVqs+Dt4qs9lYVH4e6jTtjvyaDdWyRHiTyGom1ghs1jx3x+iN47ce42OrZ6PVykX46Mnp2FajnkNeQV4uEhp3LAyLnbp9mZpLftZh+xvsojRtdQqaNUxSz07xxsjvYobT9fTN+5o1a3Dqqaeq/i+uuPLKK1WfH+ubd3dv16151uMQpFxUVBSOHz+OrKysQo9UdHQ0UlJSkJSUhPz8fLfeAWte0WtVxucSr5OcE+mbdPHFFxd6qTz1Dph5cuyyrrm+YN2X1QMmHifxPJnIuua5Kpon65jfW/Yj/asuv9zWTLJ69eq47bbboFfcPfJymVjzXB2jYM1zd4zWPDlG67kqevyu8jw9fnfHaM1zd4xF8zw9xqJ5np7joogX9rvvvnO41k3kepLr0NwnCR4qRCDJBSvNNYTp06croUQIIcQ/kUqMP4T6DhQuWvQV+nzzGn4ceit+qFlf9QUSPBkc1awImpNZwTN/A6lMWyv4pUUqgkOHDsXu3buNFBsS5ODNN990WukrC1IRlX1J4AVzINW6deuqZmUiwLwxZo5Zl9ixY4fqC9K0aVOHCrA/I4FP+vTpgx9//FFVuM3KfyBghrauVauWum5CEbPvUVHkmvznn39Uk1ESXPhcIMmNXd76mEhnTLmJBtLNgRBCQgm5R0so27YXPISW59xtpIYuZl8k0wt0Mu0gslNTlKdIxisaGVYN94ZVxyKcxB0Fh421nA+OKnNZLgmpjEmlTN5O//DDD0Zq2ZFtyO8qyDGIMCrvW29n4bnFWyTfT4RRebdfFHm5OmPGDCWQTI+X1fvkz4hAGjhwoIMHJVAQ71///v3VeQ91zDrtHI6/FfT4VCCZb8BEFJk3TyFQbxKEEBIqSIWuRSWPhVSRmIEVso/sQV7OcY8GRzW9QN3ja2DEb8uQ17Y5Mt55utAbVF7kN/BHL0lJ4bl9hSnyTHEUSASqQBLv0YsvvojXXnuNzcl0KJBCB58JJGnbKTfKnTt3qmZ1w4YNUzcHSRcXeXmbDRBCCPEdLU7piqNZQL8xPxkpgY94fEwvUP7J45DBUU0vkCuceYGEopWjjX0uQM6/q9Elf4+RUn4kmqAgldPKxuwHIpMn4bmJI4EqkDIyMlSkQfn9RZRu2LAhpJuTUSCFDj4TSKYr/N5771U3d/PmIG8g5GYqN9iVK1cqm5BAQx4Wcl3LDZI3SRKMyHXtD2MhlYayeIEEeTZJBd+s6Mu8tF6g3SPvw9FPvkHLv75B/MA+RmrgY4oiedlpIoESxFskU2Ui92HxKsncFJP+iNmaxqwPBQpyXl9//XWHl9nyXeT3D1VBTIEUOvhEIIkIGjlypPojkj8m+UOyvj0x86XpgNx4+eaJBBrmA2/EiBEB0waekNIgzZgkUtjA/5vrMFZPZSMeH0GiwJleIBFG7gZHbd6uC5rUdRRAMvdmBefQ6x9i75hxaDBhHOrce4uRGphIsypTGJkBF8RbJP2K5Nx5I+BCWZF7rzQ5lOvT9GoIYvsr5vMi0FrOSDRCGXfKem7lb+a3336r1GugMqFACh28LpDkxiU30KIeoqLuZdPDxAomCVTkmpaXAFKJICTYMCsCFS2QTC+QDIoqIbtNL5CE207bZYuG6gxveIHKQ+a8Rdh25nDUvGE4Gk+eaKSWH3lmSgXV19FfJeCC9C2SgAsymKsgARfESyTCSMKL+wPy28pk9ssyhfzkyZOV7Y+Il0u6GQSSQBKR/N577zk93oULF6JHjx4hKZIokEIHrwskeShJHyMZmdvq8i4qkOSGL2XNPkoM/U0CDbk5ShMkHzhhCal0zEqdL0J9nzi2D/m52WXyApmixxRC/lRJWV2lEaJO64JTFv1ipJQfX7+IEaEh2/ZleG5vUvS+K8fvzWh/vsCsVAdSXceZ98hEfoNQ9SJRIIUOXhVI5oVjFUImRQWSILYZ5U5u0BX1po8QbyDXrFTQeN2SYMS8P3e5dgIanmob6NJTzLDYphfIDIvtiRdIkIqH6QUy54HAtjMvR+a8xeh4ZAOq1KhupJYP86WjN1/ESKXX9BZVRHhub2J6jKwVVLkX+/M1Ii+LpS9PoFSqZWBhGfDXROpvAl8GUiCFEl4TSFaxI290it5gnQkkwZ2oIoQQUjlIJToxMdFlqG+rF0iQwVHL6gUy54FOyn1jcfiNj7waqMEUBN4IauQqPLdst7IDLniKWU8IpGtGKtKB3NqAAskOBVLo4BWB5ElzOVcCSZB1GfqbEEL8C7lv1+10LhqeepnHXiAzwpVZeZC5KYKCnaNTv8bum8ag7pNjUG/sGCO1fMgzU56x5nksLbKueIpEHAV7eG45V6b49ifkHMtk9psKNCiQ7FAghQ5eEUhmVDp3ISzdCSS5aZg36kC9gZDQRJpOyPUvlRBCgg2pAMibbys1jcFRzYqoOQVbZbss5CTvxsaWfZAwdDCaTf/ISK0cxFMkU9Hw3PI7+ZuA8AZmPcTfXrSafaQCuZUMBZIdCqTQwWtN7KRzpLs3XO4EklDS+oT4I87awxMSLEilUyp45r1ZKtfEPWvqdUJ4YgI6blxopFQcEnnM9BZZAy7I7yZTsHSqNwWQVQiZTULFO+ZPL6wCMYJdUSiQ7FAghQ7hxrzcSLO68oib8q5PSGVg3iDlTS0hwYa8AJAKgVznFEeeEde+LfK3JCtvkrcQoeoq+pmE55b7z6RJk1RYZmmuLoi36Pbbb8eoUaNU4IVgijgm50MqqVak/iDDhkgzQsn3F8yXwqxMExJYeE0gERKKSKXR395YEkIqj7iBfdU8e/V6NfcGUuGXcQOtTdDFFu/Eiy++qPJk7CIZfF3CXUvTXxFU/jJ2kbcxmwgWve+KmJfxkFyJycrADD1OgURIYEGBREg5EIEkD+lAbTpBCPEusV3bq3n2qg1q7g2snmppQid9faVpr3iLJDx3r169VB9g8fgFU1M6V7jy3ItwknPgL61RRMRKHzDpXkAICSwokAghhBAvEW94kI7P+0fNvUGLFi3UfNq0aZg1a5ZqRibhua+88ko88sgjGDJkSEg1URcRlJqa6nuvjHYUe+c/ivv7XYgrx5yDy9oMxZA3FmJ9rmd9cUzvkT95tAghnkGBRIgXkDeF1uYvhJDQRAaIrdKmGY5vsI81VBbEMz1z5kzlLdqyZQsefvhh1ZdIvBHiLbrqqqsCZuwibyOeIneCUDz6EligXPdkLQXrJp2DTl/1xY1zf8JXE2bhsy8TkT/6Xtz4yx4UGMXcYfaFokAiJPCgQCKknEgnXAnjymZ2hBAhvl1baIdSkb2q9P2QpNmYVKxff/11LFmyRHmLevbsqYItSN8i8ZowoJFnlD1YQwGyVzyGu+7vjwcfG4JOkRLFLRyxrXqhe70VWPXPfzhgK+gSEWfSBFKCZQRjWHVCgh0KJELKiav28ISQ0CSmawc19zRQg4TnluZYL7zwggq4IP1WJDz34MGDledIPBCuKtkSxS4rK8tYCh3kvuuqiZ0IScHVuIwloq3CH5NmYOndQ3F1w0gjUU8+thu79jdHiy7NUNdIc4UpzqQ5ICEk8KBAIsQLSLMXeVvIaHaEkPgz+qi5Ow9SacNzS4VbRFLRsQRFXFWtWjUkRVLRQYxNxMMmzRBFWJblnqzt+gZffNQI7fu1QxMjDTiKLTOn4+tB/8PTFzUtsfJEgURIYEOBRIgXkIegDARICCHxA20C6YQTD5I0vSpreG7xLDnzVMt2CgoKkJ6ebqQEP2YzQ1eee/EeiUgpfXPEkzi4ch5+QS+c07UOjCFSkbv1VTwx4Vq8+ckduKJ6FZXqCtmv/FYyLhObQxISmFAgEeIFRCBJHyQ+DAkhQtRpXZA5b7GyxYtR3vDcZhO7ooJA7jlSIR8wYAB27dqFo0ePGjnBjZwv8bZ5nz1Yv3A9Mvp0xSXh7+KhFtVQ99JL0e7GJAxf+hjubBhtlHMNvUeEBD4USIQQQoiXiW/XRs1/eflVFXChvOG5pb+NDErtrLwIMBFOIpL27t2LzMxMIyd4kRdS8p1FKLlDypUqgE7OWqxdkIXYQV3QtNH1GPXGXPw15TVMu3gS7n7kJyzKNcq5QJpAStM/aXbtqo8UIcT/oUAixEvIg5GR7AgJbczw3EuQoZYz1q5VwkYCLpQ3PLdsu2jgAasYysjIwOeff474+PiQEEmeIN6c8ePHe9wXSdu3BIuXtkX7U1uiblhNtLiwBzpUb4qeV1yCMyeNwY1fb3cb4tt8BvBZQEhgQ4FEiJcwH8RFO1ETQoIbM+CC3APM8Nz7ato8PV1j4lXfIgm44IsmuHl5ecqL0r9/f+Tn5yM31+biEJEUCpQkfMxmbp5FtLP1P5qlNcMpTRKM/kc2wmo0RpN6O7B9dTJchfiWvmX0HhESHFAgEeIlzAeiq07DhJDgwgzPLZVva3huCbhw67PPqDLa2h1q7i1EEFgHQG3QoAGef/55fPHFF8pT9eGHH3rsLfEOGnIP/ICvnz4blw5oh95JF+GSWbtxAvlIX3IdBtQ9F6e+thT7NaO4FxHBWdIYQ2bIb88GjT2E7au2IrVjPwxuG2ekGZxIR3pmGKKrxcJVLyRzX/QeERL4UCAR4iXMtvD0IBESvIi3SAIuuAvPbQZciB/YGzn/rkb+Me9El5N7S2JiooM3JCoqSu2rcePGqoIu/ZzMirrvycTBxXfghlNmYN750/Dlgk1YvGkIWl43Fd8eW4Gvn/kGf3c+Dw/e1B31rO4YLyHnWb6vO0REpaamFgZOcEvBNmxdkYbwfp1wWqz1gAuQtXUJFmb0wWm9WyLRSLUiokgEsohjeo8ICXwokAjxEvKwnjNnjmcPYkJIQGENzy0BF6zhuSXggrPw3DFdSjdgbEmYL2FcealFGMkxSaQ837+oKcCJjeNw/6B/sfvTZ/Bmj9o2z0riAAw84xPMHXczXvzlPAx/ZgSGlxAWu6x4+lLK46aNhxbh71/qoEmfNmhh1Ufaf1g0fT7WtTsTl3ev5dD0TpBrQ0SrePA8a8pHCPF3KJAI8SLy5tAX/QwIIRWPNFWTyrdUes3w3FIJLhqe2xWxXW0CKXPuIjUvL3JvEQHkSiBJvllB97kXKfcPfPbQm/h88N14+twG9spEWBzimx7AR69nIOf18Xi/V81igsJbyLmXsYZKamZnIgLXdVM7m5fo74LW6NwyCRFGqmpCuOlNvDmhDfq9MgqjahUXe3IdiCdLvEieHgsJTMy/Pf7OwQ8FEiGEEGJh06ZNmDZtmgq4IJ3ureG5RXh4Gp67cMDYVd7xIAlSGXcnfsSTJV4tEXO+6wuji4kVH+Pjn9ug+8jBOCOyuAQKu+gRvHdLZyQYy75AzoV47D2prEq5YcOGuTknR/Df4mVYhwyk7D2KEypNF0cpb2LcZV9i27uT8P35DYtVmkSQyjUiTSwrrmkjqSzM/n0USMFPmKZj2D4lLCxMRXZh/wwSzMjbSXloy82TTe0ICRyk4iN9i+QN8cmTJ1WaeIsk+pyE5S6rZ3hNvU4IT0xAx40LjRTfI/ch8a6IsJNmv97vE3MIq1/tjq7jzsUj697F802jjHRdUhx4FaOb/4Z9c77D1718KY9Kj/yGck6kT1Kx31Nbg59u74uLU/6HF7ouxNcpp+Gc6ssxe+9ZuPDhW/DIqfVQdBhfuVa6deumrhOxg7XSLPU3oYKqi36N/C2JIOa5CH7oQSLEi8gDUm6erprAEEL8B2fhuUUciTdAmm6JR6C84bnj2rdF/pZk5CTvNlJ8j/UFjbyw8XpUO20rNi45BFSri8Y17I3RoG3D4ndfw8fZNVEnwVWsN+8iL109vd+aHh6nL68y/sW/f5xE4jlX4K5n52PZlFfw/BtzsOzbxzHOiTiScyreOkG8SPQoEBJcUCAR4mXEUyrNW7xeKSGEeAV34bkffvhhVfH1VoU3bmBfNfdWoAZBjr0kD7V8BxF58t3MirxvOYGDcx7ANbuvxagkWwM1GVcoPd02LpOvENEjXhxPELE4efJkJ03hNORsnY+/dvTGqV0bo0iAb6fIOZVzK+dYtksICS4okAjxMtK0Rd5Au+4MTAipaEoTntubxHZtr+bZqzaouTdw35fGjghA+X7i1fZqJT6sNToNaIj4fcvx+7pUXV5kI3XZQ7jg4fPx7oSr0aPfXPz4xTf4ZsIVuOpXGRPJd5jePU/utyJ6nZ+Hw9g4Zw7+SeyBM04puVmgbMPsd2QGxSCEBBcUSIR4GXlgSpMPd9GtCCEVg1ScSxue25vEGx6k4/P+UXNvIF5q8V6U5KUW8SBN0KSPjETh816/yNroMOp7/PRsJo4MOwOtz74SF846D6//dROGJDTBqVd0RvWXp+C1Gk9jypUtijVP8yZm/6rSvpByKJ/1F2Z/sxdhg3vjnCRLk0EniDCVcynXkJzb8jS/JIT4LwzSQAghJKgQ4SAvKWQyBxIVkSDBFsrbp6gsrDulv+qH1CV/j5FSPqSJmPSZ8jQAg5wHKSfnQpqYBVOTMLMPknwnT39XKSsiZ+XKlejatT2O/nUrLv7rTNx4wzDc1Ka6y7DkIjBHjhypriXZb6i8BGOQBjsM0hA6UCAR4iPoRSKkYpHw3PJ3t3nzZiMFKjy3/B2KOKoskofdjLQfZ6HN8lmFYyOVB/M5Kt/LU1EgXjRpmicEm0gqLabQkf5DnnrVQlUcCRRIdiiQQgcKJEJ8gPmG0jchdgkhJuItchWeWyqx3u5TVBb2j5+AA09NQOOPJ6DmiCuM1IrHrOQLoS6SRFi6DPldBNNjF4riSKBAskOBFDqwDxIhPsAURVJpI4R4FzM8twRcMMNzC0XDc/uDOBLiz7ANGJvtxQFjy4IIIhFGggglT70n/o70+yztoLhSfuzYscaSa+SchbI4IiRUoQeJEB8glTcJPSsdwaVpCyGk/Eh4bvEWSVM601sk4bnNwVz9RRA5Y3WVRojt0h5tVvxupJQPETcyleWZKvckqfiLB+Xee+8N+EhsvnirL55J2a5EO5SADHLOQlUc0YNkhx6k0IEeJEJ8gDxI5U12xYw/QkjwYobnlkq8NTx3r169fBqe29tEndYF2au9F+pbhJFU1MripZb7kqwvXhHxjshyII/bZo5Z5S2PvZwb2aZca+KVlO3Sc0RIaEGBRIiPkLe7odzGn5DyIF4ia3hu8XZYw3MPGTLEp+G5vU18uzZqnjlvkZqXl/KKAqnwy7oiAGSwXHM5EDHPRVlEnjTHtL7IkqZ3gwYNKvSuyTmp6KiHhJDKhwKJEEKIXyAVXHl7L96ir776Sr3BFy+HNM+Wyqq8cAjUN/kxRvQ6b/VDMvs5lmdAahEWcr7F2y3jKkmz4NL25fEH5LqQkN3mOSkN8v1FIP7666/q2ho/fry65qZPnx7wTQ8JIWWHfZAI8SFmJ2h6kghxjbylF4+Rv4Xn9iYijLb0GIyaNwxH48kTjdSyI2LSm54NuVeJN0U8J+JVkuVAFaPukL5r0dHRxhLwzjvv4K677jKWbIPwync3vVKEfZCssA9S6ECBRIgPkevebMNOCLEjFXx/D8/tbSRQQ0SrJuiw+R8jxb8Qb5S8zJEKoCBeO/EoBUsTs6NHj6JmzZqF4tIqCkU0SVREvswqDgWSHQqk0IFN7NxQnqYLhAjyUkCaCZWlbTwhwUaghef2NvEDeyNv6y7kH0s3UvwLs8mdhAI3AzhImogkf7+HybXjromdiPCIiAgV3vzLL79U30tss6+RREikOPICWjqObv8TC766FRdMWoXjRnLIw/MScFAguUAeBnKzlYlCiZQVs4kKPUgklJHKpwRckD4d0t/jwIEDKjy3BFwwO8mHQpOmmC5GP6TV3umHJB4Qebvv7aEERCjIc0/GCRIBIf1y/F0oyT1W3uw7O76srCzk5uYWNp+78847VZ8rEeU7duxQ1yUDMXiB3H/w8/ir8cgN5+H0qzYhv11jxBlZIU2pzss+rHq1OcLDh+H6Ff75IiVUoEBygzwQ5IYrlVyvPoByN2PF5zfg9o6N0fPTjUgzkpGxAL88OwAXta2FpuP+wLpcunADHan8lbXzMCGBTLCE5/YmsUaghsy53olkZ1bqffECRrYtgkgEhAgJq1CS+5q/vTh09TJKxFFBQQEGDBhQmCdl//33X4e+RiKsZJkvs8pBZF9cOO4NXNU7Fohvg27NqxkZIU4pzou25z288WwyNO0ETrIOWKlQILlAHg7S1MB8gzZs2DD1Vq28b8+0o5/gme43Yfy/yTh6MgXLX/oBP2XpfwS58/DZhWPwfuJNuOjyDkgKi0B0hK3dLwlc5OFrPrgJCXZEFP3222/47LPPgiY8tzeJH9hHzU94KZKdK1HgTeQeJsJBhJI0RROk6V3z5s3V/iWvIr1Ksq/Dhw9jz549RooNU+gUpWrVqvjzzz+Vl1ImeVklx92xY0ejhA0RfNLkTsQfKQcFyUhelQV07oo+9SONROLZecnAjtlf45vURCT83yN45bQEI51UBgzS4AHy8JEbq7jkyz2itnYc6VmxqB53DJvf64ueo+rjzAVT8OzS4bijzXTMu6AhVSshxK8RISTN5sz57t27kZKSUhhsQZA+LHKflInNl+ysqddJfw5o6HxgnZFSPsym4BUVnlsEitlc0vQKCvJ8twoQXyDX29VXX62OQfYjoqhHjx7FxE5RpHxmZibi4+PVXPoiORPpsj15zosYdCW4QpFSBWk48ALuaP0Ypv5vLrY/czqC7VWIXHdlCtLgyXnJ+QFvnHEZRse9gmnf/Q9XVK9iZJDKgALJQ+QGK2+Wpk6dqpbFs1TeB5K281Fc0/xF/HDWBWjRdTR+eOkstKbTKOiQyoRcK1KhkJsrIf6GvD03720ibJwJGrkHijeoJCIjI9V4Ouedd56RYiUD27+6ADc9uhDzdrh59MT3QKOBp6BVp9MwsHc/DD+3KzrEBsero21nXo7MeYtxyrZFiGrW2EgNTOS6kfuaPNetYskUx6ZYErFRVtEk+5BJ9iFNNhctWoT0dFvfDLlOFyxYgAYNGqjodOVFvGHiRfLG8z2Y8FwgFSDr78vQq/9WRP8wE0svbohgq9KUTSB5cl7ykDH3YvQ8MxJdF32Mab1qBt25CzQokEqJVHalqZ1UFMwOn2V+06StwU+398XQb2/A2DWvY1wjuqODEfOhO3HiRDbfIH6JeIFmzpxZaFs9QSYSBlneuufk5Ki38NK3Iz8/38iFeisv98T+/fsbKW7QUrDuzXNw+r0bkWokofUtuOXDB3FvPaB6eApSNvyG2VPexdjpmQjreTOueeJhTLyoNeoEeK1h//gJOPDUBDT7/kMkXDzESA18RMTI81Ge8TI5E9PSAsN8Xsq86LNTRLjZXFC2J96copheIBFcUlHNy8vzijgSZP+yX195wAIVzwVSOra81x1tR7XDdSs+xzvRk/DGKx/jpy8jsO+6UXhi3G24paF9DKpApGwCyZPzsgMz7+qLkY1/w8qHe6Ee1VGlQ4FUBuQGKiJJ/kjkTZlUgKVpQanJnYdpN12Eqz/rhEG/T8ef5yTxjUEQIg98eaMufTCkAkFIoCFNm2QgV3mDLxHohCpVqhQKJBnUVe6BpQm4oG0bg2GtJmKGsRz5+Hzse3oAahnLitxV+OOJCzHsxRRkojGSHvsIf447Gx0jA/dOmTZjJpIvvQV1nxyDemPHGKnlQ+4x4k0p88s6HyDPSTkuczLFjydeSBOpMwhSKZXvJsJFpkGDBuGnn35S3krroK9yDUqUxAqq1oQMHgsk86Xvov/h7UcOYHbGTXh6RA8k/XUhBl64BDsf/AEbXzoLTY3igUiZBJIH52Xbi2cgfvMqHGzZHS0D+P4WTLC7SxmQG7UIvfIFcDiETZPH4c3Wt+L6aouwePZa7DJySHAhD3QR0oQEGqZXQJpRmeG5k5KSUKtWLSWOpHIqwv+qq64qdTS6sNjqsP5VhFeLRbxhFxLZFWc//TEmXhilL+zGweduxjmv/ov9AVz/jR/YV82Pz/POYLHyLJIXMP7WJEyekyJY5LhMz5I8I6ViKZNE95wzZ06xycyXSdaRSbYhz1i5l4qHU8qFh4c7iCMrct2WFxFzpJRkrcbqf7KAzGX4Nu5JfDmqHzrGxiCp/6UYWj8T2at3YkeBUTaU8OC8bNaqoFq7HhRHfkSFepDMdsnBhNyIzWYAngdwyEXGilE49e1LMfuDxlg1qi+GLrgPby8chztrsVMeIaTyEG+RVA7FW2S+7ZeKqNzXWrZsiV9++UWlyzhGIozKHIBh7ziMaDgenxiL0S8uRdpDPVG8ypuDI7+ci04XzsM+WYy/BNfNm4pPu1dXuYHIulP6I39LMrrkO0ZiKyvyfJXBdkOhUp+dna3Ek0SnK4oIKQlFLgJK3vSXFWkKLZH6pk+fXrbWIUGGZx4kDTkrRmBQj7nY/vw3js3E0t7Bw6fchVeG/oSN716INgGsAUrvQQqN8xKMVJhAkjeQ9913n7EUnLhvbleAE/+9iRcf342C09Ow/73m6D/3YVxfMw8HfhiEU4bloMUnb+DtI8/i7T5f4JNe9DgQQioOaUInFezNmzcbKbamc+3atVPiSF4GTZs2TfVPksq4hOsu1xhGHgsknSMTMbr1GLxudFiKuHcm/ps4GM0CtEKRPOxmpP04C22WzyocG6k8yO8jQRIq6HHut5jeThE45RE24rWSZnzB0i2gvHgmkE4adZmauGDFNHzazfQHmwJhE/DLDCw8v35AdyUovUAKjfMSjFRYEzu5YckFFUyTdLo3m07JjVQqEK5vyvnIzUrBoQ0fY9LSzjj1t/t1cSTeomgknX4HnrggGVunfoG3272NNxn7Pmhhsw3iT0iTJ6kASqXyq6++UuJI7mlyP5Mxb8RDJJVvuW4lyp2Io8GDB6v7XIUO8JrYGZ27RxgLQN4nszH9qD1ARKARY4ii7NXeGQ9Jnq/yPAp15LqU67k84kiQSrC0CJGKsDea64UGe7H53y1IbXcqzmhp9e6lYsfSf7H4zGtwb/9Q7GfN8xKoVJgHKZiQSoW0h5Y2+QKjkxFPCKVmMMS/kWtQJmuUMLk2xVskkxUpZ97rpL9RyU2IPaQ0HiSsxc+39sJFH2Yby0Nw3Ypv8Wm3OGM5sMictwjbzhyO2v+7GQ0njjdSiT8h3ih51ovYCvVxvDzyIBlj+NzXeYaluZiG3OTxuLv9Ehz4/RNM718n4IVAqT1IIXJeghEGaSgl8nZKOp9KhUEqFNLRlOKIeIK8lZdmMKUL5kGIdzBDeb/wwgvq/iXiSLxF4hF6+OGHVUXQlTiSPki3336798RRqamHei2tIRySsWFX4P4dxQ/so+bHdaFEvIvpFS0v8vcgL0JDXRx5irZvCRYtjkONdo3Q0Kjtaxk/Y8r9H+Cft17F1BAVATwvgQsFUikQISTtkqWDsjQ/kZtw5VUYSKBhXiveeHgT4glmwIVJkybhvffew5IlS1S6vNwRwSP3tN69ezttLmcVR1JRlDGQ/IdcnMgJ7HBYUad1QfbqDcrO238IeYeOKLusSP9XmUIdETbynCaVSQGy93yCty57EF8O/wN/jmzvELEydOF5CSQokDxAKgpSuZWoNvLGVSLbSJt9vlkipUEe3CKs/WmsEhKcSL+JouG5JeqcNJETUSTXojvB49/iSIhHQlUJ/R14iBASQRTfro1aPvDcGzj40ts4+PybyD+WrtLKgkRwY2sGW3hxwVsvouT65z27ZMKa3IOxn5+N01+9Dl3OPh/9XzyOiLf/xZ9XnYKkIHKRyL1R+qd5Sqicl2CEAqkEpIIhbU6laVTJgRgIcY1cR3I90etIfIF4iyQ0t1xjElBB7llCr169lDAfNWqUuvY8Ca4ggkheBvmPOEpH+uGThi00Q/sm1Qw7MNBO5qj5kXenYuc1d+LYtz+r5f1PvIRDr3+obO2E9TuWDqnES+uGUA8qYIoZbzVllu1Ic1R54UDcENYA7a7+HtN3r8PWP2Zi+Zt34I7W1YOu+Zj8jZVKMIfIeQlGKJBcYHbOlNDk8gchgRjkjRS9RiSgyfgbs187H9cMaYqk9v/DA2uOgVFaAhsJzy3ht1988UXMmjVL3a8kPLd4ix555BEVjru09y0RReKN8BvPUUEykldlGQs69duje5MKjKLnBcKio5CfloHIZo1VkIaCLDPghI24M/ogol4dY6n0yAsYIdQFkoh6GcTdW14f0yvH5ouEhBYUSG4QQcRADMSbSOVF3vBXRiVGy/gJ7w27BRPav4ePZ27Dptc2453eL+PdI4EbLjlUMTuiy7XkLjx3sFCw5Xt89WeesRSP2JuG4NKEwHt8VUmohsQrhqLmiCuMFDvVzhpgWGVDAmz069dP9b+RqGOdOnVSze5CDRFG8r29df2L8JR6AF+OEhJaMMy3G6QSKzdF3hiJt5C3kCNHjqz40PC58zBtxKW4r+fv2DCmBxIlLe0dPFT7dfz17V9YenFDuvwDAGn/LpMn4bn9Hk/DfGub8eeDfXH2q0dty4kjcd+StzChtXVMkcCiIPM4tg68FNmrbOMgyWCxrf/+EWExzoOcl4QIgvHjnYcL79ixIxYsWMDnGCkzng0UGxrIuZAXUQy2FPzQg+QGeRPFhwrxJuZbzYq9uaZi21cPYOTsUXhiRFebOBKqtUWbAcnYseMQLI2XiJ9RlvDcgYCWnY40wxYKMrKRadiFaClY995VuMMUR/HnYci08XgugMWREBYRgSZT30CVGtXVsoT9ztdFU1mQe4krcSSsW7fOI09S/poxuG5wElrpFUCpBHo2NUGzKVvhb/EE5ZyEoveMEOI96EEipIIxRbe3OhGXyNG38XCH+/HV+BXYeFt7xBrJKPgTH587BLd3n4VdL52J+kYyqXwk4IL0LZKgCxKBTpCIciKEJCy3/0WVKyV527D0tcE488FtdlGUeC2u++ox3NcqFtXzM/Tr9i/89dlreOnNndiGeESffz8eee5uPNqltovBZAOLvMNHcfyfpUgedjOaTf8ICUMHGzmlQwSyCOeSSE1N9eCFXx6yd4zHmH7PYNI+IwlnYND3b+GNDpEIy81FZKSGqJzFmPvOE7jn3f3IdTvAb+VgDubp2Xf2DLlfm0F2Qi1Qk4hhgdVFepBCCQokQioYaSIlD21vdSJ2Tzb2fnU62l3dBtdveB9vt4sz0nUokPwOadYr14cZgU6QkLJSKRNx5EkEOv8mA9u+OgdX3rIEy4u5i4rQ8gy07NYBHbv0xLnnnoNrT22IhCBrByphvQ88NQH1nnoQ4fGWv81SYFZeS2LOnDmFgRzcoi3BtCtOx9Xf2qLuoeXL+HrTAxgeYVs00dI/wfPnjsRTly7xO4FkNjn0+Dt7gPxtNm/eXP09VkYf0sqEAskOBVLowCZ2hFQwUtmtGHGko63C/O/WInPoWbi8ZZFmSRmbsWkeUKd1A5Q9dhYpL/Jmumh4bvEWmeG5JSqXXDOBL46Eamh55WIsy9BUZcvttHUOtn7zFn54/EbceVrwiSNBmtg1mDBONbnzFKmY+dT7HBaJyOiST3ZY9ctw3d0dkbNuJ7Yaaf6C6TWSlw3eQu7ZEhlSmriyckxI8EOBREgwc3Ae5n6Xi8QzuuO0SMdKT8G+9Vid1w4NkqqhipFGKg4zPLcMQG0Nz33llVeWOTw3CTwk3HeBMUaSFasIkoq+VNDl7bVEqRMxbVK7dm3Dco/3r6U4NL7sF6x//hy0MlL8BXmpIN4jbzeFk+0KHBOJkOCHTewIqQTMB7dvH7R5yJh7MU4b9B+OnNsRdfZsNtKB2FgNTSJ2YPqSs3Ddimn4tFu8kUN8iektEnEkgkiQgAviIZKJgii0kQq42cRSvBXm/cFs3iVNe+Q6kfuH2XTMXQQ7Ewn/vXDhQmOpJFbgu+v64vLPjUFrXTSxC1Xk95HfIJRgEzs7bGIXOtCDRIKcXGT+Nwnv3H0qhvWqi/p3fo6ZGZU/7o9UlKVjtU+byiAV25evwabE8zHmk6+xfv36wmnZst/x4JBqQN/BGN6hbH0fiOdIpUpCvIu3aMmSJUocSXjuESNGqHDvUtmlOAoN5Dpw9ZuLIBJxJNeGtRmu2FI5lUqZeI+s/WpkWxLK2xXx8fF46623jCXvkL/yelS/+jvYgpSHFqEmjggJVSiQSBCTi4w1D+C6c/ZBe3QBpi+ej89i78WlT8+FfRSZysF8yPr2LVQ6juxLB05pifaJRRrRHZ+DP79MRc3hA3BWVBB27vADJDy3VHit4bnr1q3rEJ67wvqikQpFPD4ihMS7I2LG2qlfrgkRyhJlrahAEiEtQkjm1mZ07pBtyDhHIraLYo6B5L1KvYa8jHn49bNZyPDz+4acf6uQ9DbyO/r2BRchpDKhQCJBiobc/57EXb13oNr39+OuhjFAWEucOqQrqr76I748YI7KXznIg1uaVvn0AVuQjORVWUB8HKpHWCszJ3Fw7seY+t8VuGpIa9B/5D0kPLdUbidNmoT33nuvMBqdeARuv/12jBo1SoXpDo6AC0R+a6koixCyvuwwB4SWpm8ihKwCSYSP9I8RIVQ0GlpZBbOIJNnnjh07cNddd6k02ffatWvLL462PYgrIs1xj8IRWf0MDJ1wyMj0X+R3kXMvv5G3kd972LBhah+EkOCEAokEJ7nz8e34d/Dt3ffime62wRiBCMQ3boseBduwfu8JI61yEO+BiCOz069PCKuKqjWdhF/I/h3fvbEU6WPvwMNtKY+8gVR0pbL04osvKm+RjF0k4YClH4k0gZLfO+DHLgph5PcVAWStEMtyt27dVEVZxIhVIMnf9dixY5UQkrF4rJ4MEUG+8mzIti+//HJlHz1qDK5bXhrfi/vm/4Ovv/4av/zyBf6YdhP+1y/SyPRfTGHoi5dQ5n1bhBIhJDihQCJBSA6OznkO4764ECNv6o2mRqqd/dhzqHIFUoUQ1hhN2+vicO8B7Dlhdq5NxbbvnsL96U/glXv6oAlb15UZqXiFTnhu/0CEitl0zVfNU4t6HMQ7IwESikaPk99WBLAIoenTpzu87BChYjavK9qMzteYwsBrnpOoRujTpw+GDx+O88+/Gmdd+QGee+ZsRBYY+X6KeR58cZ3I7ysd9aXZrC88VISQyodR7EjwoS3DdyNOx/D0t/DnNyMxyBLeumDTXTjvlCXImTUTc871LDyuL5EKn1SgfFOJKkD28pEYeup+xC34AtP7RePQ4gdw21V1cc7fj9qaHZJSIxHopFK0ebM9KqCE55YKmQzmSryP6W0V75yVatWq4ZNPPimMCllWxMsn3iGp8ArWx6Lp7RWxI79xefdVEcgxyrGWzcNRchQ7LXsPNh2tjhYNq/vVALEVidwDZLIK42CFUezsMIpd6ECBRIIObeejuKb5F1g06TdsvK09Yo10CXudPnsI2p1bE8M2foK321WuQDD7KUycOFFV0HxDBvb+cS8euvlPLG7dB00G34Anbj4Hg2r6fxMZf8L0FjE8d+XQqVMnrFu3zlgqjnhwShIuUqERD5C8lBBvnzR/M5u6SSVXBJL5e3oaICE4YZhv4ggFkh0KpNCBTexIkHESB1fOwyytEwac2sQijoQs7N+ejH2JDdA4sfKf9lIRE3x7o62GBmd/jM927sTWP6bhrwfPpzgqBfKGWIQsw3NXHiJW3Ikj4e6771ZzEbLiNRHBI7+NVeiIMBIPlIgjqeBYfzf5jWVdU0QRT9FwcsOLuPbpv7DOz5vcEUJIaaBAIkHGXmz+dwtSWx7HogcvQYcOHQqnc8/thtte3O487HUlIAJJvBB8E+VfMDy3f2ENjOCKlJQU9XckIkgCJkifMIlgZkV+t5UrV6q34FLWfEERrMh39H3/mH1YO+MNfLH1GML8sDYhLzF8/QJDrivZhwhsQkjwQIFEgouc1Vg1NxXhZ9+PX2f/4TA46u/Tx+HsyCp+NfaPvOl21bwuOztbhY0mvofhuf0T+U2KCh1XmKJn8uTJhWG0rX9bUokNdlFkIkJRgkr4NspaLjKWP46nn9uLqNYN0MRI9TfE6+vLl1ByXck+PBHyhJDAgX2QSHCR9g4eankPPnp8OXaN7moZ46cAWX9fhl79c9F1xTR82i3eSPctubm5aqpataqR4jlZWVmqvXNsrGNDQeI9pCIplXBTEAkSnlsq0qFSmfYH5DcwfwuZjm7fgQVr1xi5nuFJP6RQQu4dci3LefUcDXl7nsY9p43FpH1GUvxQXPztS3imeRjC9HuZUD16P3YufgtvjZ+Br7Y2QtPJf2H7ja387o2rCETxKIpo9lUwBTm/EuWw9Oc6cGAfJDvsgxQ6UCCRoMIWpW461r7/F3bd2g6FPY20dZh5T3+cv2dCsch2vmTPnj2oXr068vLyULNmTSO1ZA4dOoR33nlHNeWScVYKCgpUxdG8KcuD2HwYSxmZzDfkZsdz4hxpCmNWxK0BFyQCnXiJfN0kJ5Qxr1u5jmUuv4FVnFoZWSUB9cOqYLOWg+/yM41U18ggqWz6aEfuA+J9k3GYPLmm89eMwYgHP8Pi3w9hm5HmGX0weM7PmHmG5/e3ikKuM/EiyuTLaHOybbn2fOuxqzwokOxQIIUOFEgkqLBFsJuMee/NtQikApxYcweGd9uNKvOmYnr/OqioBnbSn+Xqq69WlZUHHngAJ0+eLCaUpGmGVBbN5kAywOPGjRvRv39/JCUloX79+i4rka6Q8VnkbbovKwWBBsNzVxxWESqTXN+umspdGlENjcIi0DwsUp9Hor7+V5sgFTLjyXRMy8eAnN22BRdI0AwJtEDsyH1FfgezjwwhZYUCyQ4FUuhAgUSCi+Of4tnTbsTzVy3Erif6QEmR3HmYNuJS3Nt2BpY+2b/CBkc1K4nnnXee6uMSERGBVq1aqYqc9G0x+7NY3/RGRkaqh1Djxo0dOv1KkImzzz5bVeat3iLBvFGblVFZNsdzEc+I+QY1FCtJcg4lPLecFxGngpwT8RSJKGLFsfzI9WaKIJlvX7EKuzNsnjkrZ1aJQ7PwSHQOj0FDXRAlhoWjrj7XL3ijhE6hqRuGren/VhWcxA25+20JRejYsSMWLFjA35IQH0GBZIcCKXSgQCJBxj6serUvun87Cp/MegDXxf6HpW9fj+H7n8XPT5+Djj5uWicVcnlzK1PRQS1NfvnlF+UdkqZ3gogXCSMtfSiGDBmiggTI+mbTuejoaDzyyCOqrKdIRVXCFUs0L0Hax8tyKPTREDFqeotMoSiIKDUFJik9UiEQESST2Knbk7Fmt/38mnSsEoPTqsSic5Vo1EIEaupCqKkujOzip0hFywOBJP/TUIBfC45jgy6W5mrZSNMKfNq3hAQPci8wXyj5Crn3SxM7ub+YrQGCBQokOxRIoQMFEgk+cldj7iu34e53oqF164I+N92BcReegkYRvhNH8nAUASKT2a9FKuTiHVq+fLkSPnfddZeqvNerV0/lm4gYkn5GY8eOVZU980249FvKzLT1vRBvU9H1PEEqs/LQNoXSvffeG7TjvEhzRnMwV9NbJOG5TW8RI9B5htUbJNOWlauxcVfxzudKCEXEolV4NGqHVUFDXQTVC49AtCZ/Z4XqxvwonAllEUiF6OU/LEjHG/nH2O+oBMw+McHaN8YTTA+9r68VeQaY2xc7mKBAskOBFDpQIBFSTkTgiLARYSTNt8SWN4jmw1L6FEkkOlfR6ORhar7h9FUzIbmZy3GJR0WEmywHQ5MkMzy3TAcOHFBp4nEzAy6URVSGClZvkJy/ozuSsWCN875uN8XURP2wSCSFV0GrKlGoh0jEGJUmheUxYjON5WK2jfIKpD8LsnBf/mFGrisBuadI/8VQfsyLOJRIdhL6XcSSL5F7rLyMCjbPJgWSHQqk0IECiZByYDaPE8Q7Iw9jfxUeIsSkgiAVpkAXSaaHg+G5S8YU4PJ7m6LIVcCEy6NroFF4JJrrIqh1lWgkhlVBgj45ihSrbWB5jNhMY7mYbaO8AmmTloMr8vYrr2soe0dKwqywywC5ofp3IX0+R44ciYkTJ/q86Zv8bUnI72C7LimQ7FAghQ4USISUEbPyIRVzeQj7+u2kN7CKpECL/GVW9GVieO7iWM+PKSC3r1yN3enFm/tcHiNCKArNI6LRWBdEIoTqhhtB8Z0IFn8TSAe0fJyTl6KiNYoHlzjH9J6Ecl8t+TuQ+5x4GiviHi1/e8HW7JMCyQ4FUuhAgURIGTDFkbc8MfJQlW3KQ9zXbzmtIqki3qqWF4bnLo7VGyT21lWrkZJWXAidFV0dzapEoUtkLGrpAqhmWIS+HKnyHO78DiLFapsz3ShMttoGlnVsprFczLZRXoEkdM7dhQGdOmO+i2aBxPa3LhP7aZHyQIFkhwIpdKBAIqSUmM3qvNlMTQRAt27dKuyNuLk/8cCI7W8VKKnUMTy3Y8AEudZSdyRjza7ikeM66QLotKh4tIqIRp3wSDSsoguh8GgjVzBu82pmsx3u/A4ixWqbM90oTLbaBpZ1bKaxXMy24Q2BNC7/KL4vyHTcFiF+gtmqIBjEKQWSHQqk0IECiZBSYEack2Z1Umn1ZkXd3JaIg4rAbH7jL03tQjk8tymCzCl1x07MX7PKyHXk5vgkNNBFULOIKF0IRanIcTFh4SrPfjfXDYc7u7GgZjbb4c5vXXCwzZluFCZbbQPLOjbTWC5m2/CGQPqyIAPP56eGdP8a4hnm31VFNTOUSKH33Xdf0PRFokCyIaJo0KBBQR0NltihQCLEQ0S4SEVMKu++iIgkzevMB3lFeUhEdMj3qcxwyaEUntvaLM60XQVMuKVaEurrAihJF0BtImOQEBaBGuFVbJkuBIbd1A2HO7uxoGY22+HO72J79tV0ozDZahsUOwZjuZhtwxsCiZHsPEM83vJiR665YH7J4A6zSXRFiWl5ViQmJiqvd0W98PIlFEg2TIHE4DChge21IyGkROSNkYgJeXvki86+UomRCnNFNh8z+x9V9Nsw8RaJKJo0aZIaGNeMRifeottvvx2jRo1SFZlAFUdSKZKHqZxXOcdyvUglQyJcyQNWPHdSYRNxNDyuFu5LaIA3azfHD/XaYV79jtjcqCse1NOui6uNc2MT0Cwi2i6OiKJVWJSaywsF4hq5n8h9K5TPkykM5f5aEcg5F8+8BJMJpEA4hBA79CAR4gFS4bU+ZCtSxPgS802nNBmsiMqDeIlkCqbw3KY3yPT+bV+1GrudBEw4u2oNJXS6Rsejti52Guh2XQmYUPQWrBaNNIvtUMy6YLHtpm5Yy5dxe/bVdKMw2WobFDsGY7mYbcMbHqQ0FGBA7h72BygBs1lwKL/1roxzIPcEmXzxMq2ioQfJBj1IoQUFEiEeIG8BZSyNimh7LJXsihIL0rzthhtuwOzZs/HHH3+gR48eKr1q1aqIirK9oS8vIsJM8WANz22KokARm+Z3kEqPPCiP6fPVlr5SJp2i49ArphpaR8WiqS6CaoZHoFlktNNKvvosegu2JSrTajsUsy5YbLupG9byZdyefTXdKEy22gbFjsFYLmbb8IZAEiSS3SmNm2LDrorxDAQicr3K35l4MkO1Umf+zQZL0ISKhgLJBgVSaEGBRIgHSAVDvB6+7qsjD3BpdpWamlohwkGausmb1ZkzZ6JVq1Zo1KgRZsyYgYiICCWSyoOICfEWBVp4blMEmYIoNXkX5q9eaeTaESHUO7a6EkJ1qkSgkS6G6kVEIRq2yoSi8O6qG9Y7rXHbVZ9Fb8G2RGVabYdi1gWLbTd1w1q+jNuzr6YbhclW26DYMRjLxWwb3hJIE/OPYXJBuuP2CPEz5H4SyMKMAskGBVJoQYFESAmYzdCkf4xUmH2JGUK8ojqey3d78cUX8cILL6hl6cwsYyOVVZzJ9lyF5xZh5E99iqTSYr5ZNgWRtemflVsT66smcUlVItEmOhY1wiVggjGwqmC5jTpW/o25i0q++ix6C7YlKtNqOxRz2Ifdtpu6YS1fxu3ZV9ONwmSrbVDsGIzlYrYNx3NktY25GIbtTiCZkex8ETSFEG9gBoiozEA45YUCyQYFUmjBIA2ElIDcFIWKECxmJc/XQsxEhNDzzz9vLAFPPfVUqZvWiRdKjlcCLoi4W7JkiUoXQSkdlUX0iUCqLHEkok1+Q2kaKZUVOcfOAiaIOLoiIQn3126Mtxu0wY9NO2FZy57Y2ro3Hq7dBNfXqItz42uiWWQMalSxiCNSaTQNsw16KwKXuEf+DmQKVaSZtPz9V/Q5MEVRIAVryMnJMSxCQhcKJEJKwBQrFfGGWvYhoqIi3zRKPyShXr16ylPmadM6WU86P4vwkGZ5Bw4cUOG5ZbBbEUUiKCvye1iFkBk5rmliTfWdRAjJuCRm5LhzqtXEbTUb4p2GbfFjsy5Y2LIHtrbtg+fqtcQdevpgXQi1j46jEPJzGsL2+1AguUcq5/J3EMoR1eQ+Ln//FfXyyUTuRYKv+656E/MlmbxEMr1Hgtgyyf00lMU2CQ3YxI6QEpCKtlSqA7mJREm89NJLiIyMVCLCHaa3SJrRmQEXoqOjVfM5mURkVQRmszizidyx5J1YvbN4JfmcarXQPCoGXatWQ+0qkaipT82jYvUce7MtNXPV5EuwFbCZFtucKSzrsImd+lS2bWa1bXirid1JPePU3N2MZFcCcm6kUusvg0JXBiJQ5P42efJk5UmqSKQ5lnjrTbEUCMgLMBmCwVlTsoULF6J79+6IjZV7aXAj58Fs/SDf+6KLLsLDDz+MRx55RKUJch7kOUiCCwokQkrAFEjB/Kdi9SI5o7LCc4sYM/sHyfTf6jXYkLzDyLXTObYaescloE1MVdSJiELDyGjUj4hGTHi4Q4XaXtHWDcNWM4cyFluwFbCZFtucKSzrUCCpT2XbZlbbhrcEknBN3n6EN6yH1buLRxQkduTNf0X0o/RXTJHI/iOec/z4cRW4x+otkufhb7/9FlQDeLsjOztbvUBUL+L08yB/P/Ki1HxZ+uOPP6JatWrKJsEFBRIhJVDRAkluwtJ0TW7Asu/KwnwYyOTr8NxWb5DsL3XnLsxfVTxynHBbncZooAugupFRaBMdpwuhKJsQslC6Crh8WMtYbMFWwGZabHOmsKzjuG9jLoaT8urTzf6stkMxh33YbbupG9byZdyefTXdKEy22gbFjsFYLmbbKN3vY7cV1vI6ZiS7ior8GKiI90LOT6iKA7mfyRSsrQB8weHDh/H22287XDNyj+7Vq1fICCS5ZuT576wPsngi33zzTcTHxxspJJigQCKkBCpaIIlA6Natm+rLI0KpopH9+yo8t1UImbacW2dcWas+2sfEI0kXQm1j4pBYJQI1qkTa6squKtgGpauAy4e1jMUWbAVspsU2ZwrLOo77NuZiOCmvPt3sz2o7FHPYh922m7phLV/G7dlX043CZKttUOwYjOVito3S/T52W2Etr/NjwXE8nn+EkeyIXyMVbbOJXSA1c7R6keTv69dffw2JpnVWxIvUvn179byysmfPHjRs2NBYIsEGBRIhJVDRAkkw34TLQ6kikP14Mzy3bE+2JZM8VGS+Y/Va7Dp21Chh56raDdAoKgYto6uiSXSs6idUTxdFisJTrhuGrWauKtgGpauAy4e1jMUWbAVspsU2ZwrLOo77NuZiOCmvPt3sz2o7FHPYh922m7phLV/G7dlX043CZKttUOwYjOVito3S/T52W2Etr/NPwQmMyj+owtMHUh8PEnqI92rnzp0B5e209kUSYScv7kLNU5uZmYnvvvvOoe+a2OUZEoP4PxRIhJRAZQgkcedLZDhfBoaQgAviKRJhJBHoBOloKl4iEUWe7tfqDRJ765q1SEktLoTOqVEHLXQR1C2+OmpHRKFWRCSa68tCcVFhLBcm64Y1yaG8xTYoXQVcPqxlLLZgK2AzLbY5U1jWKf5dBN1wUl59utmf1XYo5rAPu203dcNavozbs6+mG4XJVtug2DEYy8VsG6X7fey2wlpeZ2dBHi7K34t77703oCKFVTTy0kL+PoWKGLLAH5FKvnjlzSbMFY3sX4YVCLR+UBkZGTj99NPxzz//hJz3yIpE9TO9SLt27UKtWrXKPaA68V8okAgpAVMgVeRbP/G4mE0avI28ERRRJOLI9BZJeG7xFok4cuUtsnqDpKJ1LHkXVu/cYeTa6RJXHb2rJaJNbDzqREahcVQsmscYD1V1tzFuOZY7T3FRUbSMbliTXFWwDUpXAZcPaxmLLdgK2EyLbc4UlnWKfxdBN5yUV59u9me1HYo57MNu203dsJYv4/bsq+lGYbLVNih2DMZyMdtG6X4fu62wlhf0xc55uxjJrgTkfiKhvkP5PJkCpbKaY8pvIMJMPJ2BJJDkmSHPCrl+qlevbqSGFnIOvvrqK/Xb0XsUGvhUIMkFJW+pK+NNDSHewnyo/vLLLzj77LNLPZCqP1Ca8NxWISRT6q7dmL9yhZHryO31m6FtVV0IRehCKDoW9aNiEGOMm6FuLIV3F8OwJhbm6WaxSnLRMrphTXJVwTYoXQVcPqxlLLZgK2AzLbY5U1jWKf5dBN1wUl59utmf1XYo5rAPu203dcNavozbs6+mG4XJVtug2DEYy8VsG6X7fey2wlpe0BfvzT+ErXGR2JVhu7aJc+RZLJV0mUIRaSI2cuRIRrIjZcLsj7VgwQK0aNGC3qMgx6cCSW5G0t5WwgGbb6cJCTTMh6o0S5k+fbqRWjGIQCmPJ0m8RDI5C88tb7/MZnEyl8lVwIRRDZqjYXQMkiKjlSBKjIhUARMKcVLhVZ+FyYZhTSzM081ileSiZXTDmuRkf1ZKVwGXD2sZiy3YCthMi23OFJZ1in8XQTeclFefbvZntR2KOezDbttN3bCWL+P27KvpRmGy1TYodgzGcjHbRul+H7utsJYX9MWJBamYXJDBSHYlYHrDg3lMN3fIvU7u49IUs6LHQgpk5BkkzyITuXbM68d8dpiYzxahaJ71OWY+20xvplWwWm3Zj/W3cpUn+7EGv5B9mfuTfVn7J8rvL8cpyDrW9ax5so71e3/77bf4+++/lRdWjsPMK3p+rIPrFvXYWvMo1P0bnwokuWCs/Rt8FSKYEF8gHlAZ32DSpEl4/PHHlRfGh38uDshN84UXXihsAifIII+SXlLFxrxZy2R6i6TduEyS9+eff7oUQlfVbYwmMbFoGROn5jUjo1A/0mxyp3934+u7rbQatvosTDYMa2Jhnm46rF/4YSmjG9YkJ/uzUroKuHxYy1hswVbAZlpsc6awrFP8uwi64aS8+nSzP6vtUMxhH3bbbuqGtXwZt2dfTTcKk622QbFjMJaL2TZK9/vYbYW1vKAv/qll4b78w4xkVwJmRc3fn8FmZdOsqLqroLvLc1d5l3NhrbhaK6pSYbauZ82z2rIfTyrvcnzWCvoVV1yBgwcPFvYFK2vl/fXXX1e2YP2bMoWw4K6C7mnlXcrIGFIm1jyZSwsLE+vfYNE8V8coWPPkNzKfXZ4ev7tjLJrn7hitea6OMSsrC+eff35hnrx0dCUE5feS383EmifXh/X6If5FhfRBkgtHbhDWt9gSNrhdu3Zu+zwQUpnIg1cCJciDSGyhAv5c1A1z6tSpxpIjItjWrFlTWAGwIn9jMtL3kSNHjBRg39692LptmxJFVs6tVRctYuPQvVoN1U+oYXQs6kVZ/g6t37PQ1A3DpkCyzxSWdYp/F0E3nJRXn272Z7Udijnsw27bTd2wli/j9uyr6UZhstU2KHYMxnIx20bpfh+7rbCWF/TFVdoJ3JB/sNxvZOVvyPxbl0qaWRkVrJU0a15ZK++yPes25e/eVZ71O5VUeTe/g6cVMylvraC7y7NW0MtSsRSseb6o/Pq68u6pwHB3/BIJTp4t8tJLznVZK+/yO1sFn4n8ZuZ15+468PQakevNKtSknFlW9mvdt6xTmutYjkG+g3Xf5jUseOPvkJCyUCECycS8gGUy3w4IIpbkQhaxZP6xE+IPyHW6e/duDBgwQF2/vv5zkYeGNOdzhzx45UEjDxc5PhmLoWpsLMKrVFH5MmbDli1b8O+//6J2+nH0qVFTF0KJqBMVrTxCLWLi9FLG91Azm+3w1awLhaZuGDYFkn2msKxT/LsIuuGkvPq0lN+fn4sTBQW6ZUtrViW60N6Xp+dpkgfEIAz1zCaO+vrJeTZPo5SMCQtHvfAItSDl9xfk4mhBHo7oU+sqMfo2besdK8jHv7lZypZtnBZZFQlh+jUk28vPwX/5du/lqRGxSIDt+kouOImteTnKFs6OjFfrCDNy07FVX9dkTFQt/dOWN+GkXbi3DIvE0Ahj9Hl93Qm59qiHg8Krolu4/r311Q5o+fg83/asSNbyMDQ8DmeF2QJ+/Flg8xpZkQqn/A2VVLEM9cq7NeJfaY7feoxynq2VZqt4slbQBetxeFJ5l/qA2GYFXTCPSZA8s2xZK++ynkwm5jqCHJ9ZQResedbteVp5d4bky/2bzUIJ8U8qVCBZkeZLchOS/hFWsSTN8KTDuExyI5MbB28epDI5evSoCswgImnlypVGqm+QB6rV0+qKc845B506dSqMKJSXl4e8AwdR578dqHc0A41jYtEgOgbR4bYKrwNqUdMr4vnYe+KEXi4aMXo5KXZMr4QfzdUruMY64mUy6rfYl5ON7Px824KOGaJb2Hcy26jY2yro9XUxZuwGM1MP2gyd2hHR6BlvO+ZjublYnGn3zLXV96W2qRc9pleyVZ6x797xCagRbqvYb9f3teVEprKP68fTN06/Z0SKkAC+P3ZAzzMq/ToP19UrQ8Z3+f7YQfx30pJXp6maS+6LB+0VpTZRsRhWvY6xBIxK2Yw/jqcq++16rXFufKKyk3NO4Jxda5QtvF23Fc6NS1Tf5Xe9/N0Htxk5wO8NO6BZhM1D93vWMdx9yJ43q357Pc92/C8f24sPM2xNkoXNDaWCZTv+l9L24aNMOZfAzfF18GC1+sqW79du/1qbrXNzXB08EF9XrZasi5zzjvxn5ABvVG+Mc6JtwmSHLnLOT92qbOH7hOZoJ8eob292TgbuzUwxcoBfqjdHs3BbcJI/cvW843uVLaxPaKPWEV49cRgf59jOlbAuvpX+acvrmGn/ziMja2BMZE3bgr5up+wdNltnYmQSzq5iuw52arm4MMd2HB3DovBQRE10he04RDx9UZChbCksfZBMUVDWyrusY1aa5fnjqoJuzXNXQS8pz1pBl+Mzn3VF86wV9JIq73JspghwhnwP2UZlDELtD8jvJh56q9irDEwRPHnyZIfrjBDiH4Tpf6S2pxchxCW5emU+MtISlMBHWCth7rjnnnvUGAzW8h906Inz6tgqzduzMnH6v3OULbzfvgfOq22LVPfbof24beNyZQvzepyuhJDUcX87cgC3b7JHrNvVd4hZv8VzOzdj0l57RXZnr3MNS8/btQXv7bNV6G6v1xSPNW5tW03/aLbsD5Uu3F63KR5t1FLZO3QhM2j9YmUL7zbviCE1dGGir7NDFzJnblxi5AB/tTsNzXXhIsxMO4w7dq5XtvBn6566sLLlzUrX83ZtVLawrUN/fXu2L/DigWS8f8Re6d/Wrq+aS26rTf8oW7g1sYEunpoYS8Clu9ahV6xNVJylC6AeMfHK3q8LyU/STDGj4ayqtjwRSCt0AfeHLoRMbtAFVz1DYKw46Zh3vS52TG/QipPHcTg/V9nCuTEJ+qft+JfreeIFEmqFVUH3KPEE6uj7m30i3WbqU63wCHSP1M+HvpCmvETHUTUsDA2rRCERVZAQHq7KZhdoyruk0LeRqItk04OUpouPVH1dY9eoq29TvFZCmpZnyzNQwsk4x4LNNJaL2TYc3ss52MZcDMP2pImdfIwrOIrvC447bpsUQ0SBeKBC1XNhChMJuFOZ40GJyBUR7M7LRAipPCiQCCkFBQUFCDcqmL7AU4E06errcWbGSUxcY4oZDefWqodTE2xv5fedyMbHKTuMeqWGwXpez+o2z8eytFTMOrJf2dIHqY++To2ISFXv3J59HJt1cWVWQlWeUXlflpGKQzn2ZldDEpMMy5Z3WDxPOrX1bfWMr2HWW5UQUoZOjF4Br2+EST+RX4B9uSeULZXaRH0/chxSVLxb+3L1fdlWQ/3IKOWZElJ1AZGqC1aT5ta+Uwalq4DLh7WMxRZsBWymxTZnCss6jvs25mI4Ka8+3ezPajsUc9iH3babumEtX8bt2VfTjcJkq21Q7BiM5WK2DV8IpA8L0vFGQVrIRmjzFPGgSef+yvagVBbiZZNmg9amhIQQUpRKa2Inb07MJnbWSF3SxE4ebmYzO5kYxIEEGtb+dua1vmPtOuw6au+HYTI4qT666eKlVVw1/H5oH77eu8vIcc36AechQTxahX+9umH9Szb+rNWniwqlwmI7FLMuFJq6Ydjsg2SfKSzrFP8ugm44Ka8+3ezPajsUc9iH3babumEtX8bt2VfTjcJkq21Q7BiM5WK2jdL9PnZbYS0vqEUNf2rZjGTnAdLkT/o5ykCXIpZCDbkXy/cWceQv14mINl6zhPgXlR6kQQarFEEkARpkzv5GJNCQh5vZZ0DstF27sWrHdiPXzuCkBmgZF4/uCTVRR7/ua0VGo0VVW3Mts9L377EjuGTpfGW74o4mrfB4qw5FKo5WW8fYnvp0UaFUWGyHYtaFQlM3DJsCyT5TWNYp/l0E3XBSXn262Z/VdijmsA+7bTd1w1q+jNuzr6YbhclW26DYMRjLxWwbpft97LbCWl5Qixo2abm4In8/PQMlYPZf4rPWP5BmfhLRTvq3srkdIf5DhQgkqTjKeEibN282UmyR6+RmIMKIkEDA6g2SaeuatVjvRAh11QVQ31p10C6+OpKiY9AoJg4NYmIQI1HmjMqcwvqXZ/wZyufkXdvw+GZ7538rnavVwJdd+6BGZJReVi9duA2rrWPZnqsKpcJiOxSzLhSaumHYFEj2mcKyTvHvIuiGk/Lq083+rLZDMYd92G27qRvW8mXcnn013ShMttoGxY7BWC5m2yjd72O3FdbyglrUcAD5OCdvrwqhHKoBCEjgYXr0zAiMhBD/wKcCSSqR6o264S2S5nO9e/dWwojN5oi/YhVBMh3bswfzltuDGli5s0U7NIytqjxDjfV5g5iqhhCy/1nZTGO5mG1glLdla5h35CA+3L0Nfx22RzR7pk1nXN2giYo4J1AgGVhtg9JVwOXDWsZiC7YCNtNimzOFZZ3i30XQDSfl1aeb/Vlth2IO+7DbdlM3rOXLuD37arpRmGy1DYodg7FczLZRut/Hbius5QW1aEvrnLcbXbp0UX+3/oeGvCMz8ePE5/HcnlNxJubhl6XZaJ7eFc1mf4S32vGZGKqIN48hvwnxL3wqkORtyM6dO9Uow9K+lh1niT9hbRZn2tbxRaxc26QFOlSvgXoxsWhXLQGJUVFIFC+Oq4qbxbaZxnIx28Aob8u2Z/x99BCWpR3FiIbNUCMiSgUvoECSj8IMR9ugdBVw+bCWsdiCrYDNtNjmTGFZp/h3EXTDSXn16WZ/VtuhmMM+7Lbd1A1r+TJuz76abhQmW22DYsdgLBezbZTu97HbCmt5QS3a0sblH8X3mj9GsstFxppHcc/gI4ifNRFvdq6BMGzDXw90x1mzHsGnSx7BdVXt4xT5Ggl7Ls0Q5d7HZl2Vj+k5YrhvQvwHnwokGetIPEV8I0IqE2cBE5LXrcfOI46DTArXNm2JJlXj0Dq+uprXiopG/RhzvB/9T6Xwr8VmOPz1OFT07LbNNJaL2QZGeVu2JaPQ1PDMf+vxz7HD+LXnQCNFz7Tk220dV9sTbInKtNoOxVwcg301u61wKG+z1WdhsmFYEwvzdLPY/oqW0Q1rkpP9WSldBVw+rGUstmArYDMttjlTWNYp/l0E3XBSXn262Z/VdijmsA+7bTd1w1q+jNuzr6YbhclW26DYMRjLxWwbpft97LbCWl5Qi7a0DwrS8WZBmp/159CQmzwed53yM7b++Cv+PCfJFjC94E98fO4Q3NpqOja+eyHaVJw+UuKIY/AQQohrKjRIAyG+pmjAhG3r1mHPkeKR44bUb4SW8dXQI7E26ugiXoRQyzjbWDe2+pblz6LQ1A2rLZ+WYo7r2G2baSwXsw2M8rZsS0ahqWHy7h14fMsa/NBjgArnTYFkYLUNSlcBlw9rGYst2ArYTIttzhSWdYp/F0E3nJRXn272Z7Udijnsw27bTd2wli/j9uyr6UZhstU2KHYMxnIx20bpfh+7rbCWF9SiLe2PgmyMKThc6WPcOJA7D9NuugjXRkzBqo8vRSdTCB14AaMavIIfJy3ErlvbIcJIrgjk3iihru+9917lTSKEEOIIBRIJSKweIXnYp+3eg1Xb7SP1m3RNrIX+deqibfUENNMFUK3oGEMIGZd94dWvG9akEiptpuHw1+Owjt22mcZyMdvAKG/LtmTo5r6T2dhzIguNomPR8+/fcXWDpnilXVc9S88sLGq1dVxtT7AlKtNqOxQrcgw2dMOwKZDsM4VlneLfRdANJ+XVp5v9WW2HYg77sNt2Uzes5cu4PftqulGYbLUNih2DsVzMtlG638duK6zlBbVoS0vW8jA0f58fRbIrQNbfl6FX/62I/mEmll7c0BhuNwdHf78I/QbnoM2C6ZjRv2JbWYhXXZq9y0SB5D+IqJffRp5phJDKhQKJ+DXWZnEyuQuYcHfbDroQqoG6MTFoHBePhmbABJ3ilVZjuTBZN6xJJVTaTMPhr8dhHbttM+VDw8mTGVh2KAXLo5vhnloxRmVJxyhvK2pfVxLeSN6CF7dtwLJ+52Lmof2oq4u88+vU17P0zMKiVlvH1fYEW6IyrbZDsSLHYEM3DJsCyT5TWNYp/l0E3XBSXn262Z/VdijmsA+7bTd1w1q+jNuzr6YbhclW26DYMRjLxWwbpft97LbCWl5Qi7a0Y1oBTs9P8aNIdnuwaFx39H31Ijyy7l0839Q2SDKyf8K7l1+OOxfdgec3voJH6lak/4j4K9IsdPXq1Qz5TYgfQIFE/AJrszjTdhUw4e52HdGoapwKmCCCqGZ0tAqaoHBRkSpeaTWWC5N1w5pUQqXNNBz+ehzWsds28zj+2LQCTyQfwE59qUbjvph/Sj3UlizBKK8+HbYD/HpwL25d+29h0zoTCiQDq21Qugq4fFjLWGzBVsBmWmxzprCsU/y7CLrhpLz6dLM/q+1QzGEfdttu6oa1fBm3Z19NNwqTrbZBsWMwlovZNkr3+9hthbW8oBZtaZLVJX83TmncFBt2Jau0SkVbhGlXDsLVC8fg7Y3P4M6EcD3xEDZ/fBGuG/8vlnefgoXf3YC+kkxCHob8JsR/oEAiFYqzgAmuhNB1LdqgaXw8WldPQNO4eNSMikGDqlXNupCOXnWy2NaZwnJpF6+0Fi2vG9akYuUFexnTcPjrcVjHbouZk/Efhv+9GkuNNFRphnf7dcXFMUbNyCivPh22A2zPysSARX/gtfbdMbxeYyNDsvTMwqJWW8fV9gRbojKttkOxIsdgQzcMmwLJPlNY1in+XQTdcFJefbrZn9V2KOawD7ttN3XDWr6M27OvphuFyVbboNgxGMvFbBul+33stsJaXlCLtjTJmlhwDFO0DMd9VBbFBNJx7J05AkM+iUXnJdPww40LcWB0AWbu6IBLVWS7ikXuvxJEiRFm/Qf5LUaPHq0mQkjlQYFEfIZ4g6xCKHn9euw8XDxy3HmNmqBVtQT0qFVHF0TSTyga9WPNyHEGLipR9mTDsF7NlnWKV1qLltcNa5KL/TnY8mkp5riO3da0HCz5bxHGputi6NAB2IaAjcMlnfvj7XpxtkqRUV59Otn30rQjqg9SfX2SUN9f7t2F5lXjMDCxjq2Aw7HpuNqeYEtUptV2KObkGJRh2BRI9pnCsk7x7yLohpPy6tPN/qy2QzGHfdhtu6kb1vJl3J59Nd0oTLbaBsWOwVguZtso3e9jtxXW8oJatKVJ1jRdHD2vi6Q5c+aoPjaVyyGsfrU7uj5QF93feQavxLyGUQtvxfRrP8WVZ81Hyn2P44H565Dx5Vt4vnWRe56PMQM1+E9/LUII8R8okEi5sTaLEzttTwpWbdtq5Nrppgug/nXro0ftOkiSyHESMEEXRoVYLsVil6V1udAMDIFUcCIF9y/cha692iJy0z+4//AJW0at7ljYvRlaiEIyyqvPEvYtAqnl3J8xuHY9fNTpNFuiJV/hanuCLVGZVtuhWAnHQIFknyks6xT/LoJuOCmvPt3sz2o7FHPYh922m7phLV/G7dlX043CZKttUOwYjOVito3S/T52W2EtL6hFW5pk/allYUzBEb8JYa0dmILXR9+PMUt6ovttD2PK/YPQNvkx3DroVUzv+jDufu5+PFMJ3iO5Xzdv3tyP+msFH9JiQiYZ7sQcHD8zMxN5eXlquV69eiqNEOJ/UCARj7F6g2RKS0nB3GXLjFw7SgjVq492NRJRN6YqmkjAhLg4REvAhMKrTTeKXnmWS7HYZWldLjQDQSDlY+vu5bjoSH3M7lIfJ/csQ/91e4y8Bnih76m4IV7Oi7E99WHdjjF32DcweY8t5Pf07v2NfkmO+S63J9gSlWm1HYqVcAwUSPaZwrJO8e8i6IaT8urTzf6stkMxh33YbbupG9byZdyefTXdKEy22gbFjsFYLmbbKN3vY7cVlvIHtHyk6lMK8rBDy8VaLQdztGyVx34cNvL2H0JEPdPT7EhYWJgayF3u68T7HD58GL/88ovDdVjUqymR69q2bVsooAT5PSS6oORVvheUkNCEAokUQ27OMlmbyElkHWfc07ELGukCqF5sVZyiC6Ka0TFIjI52qMQ4r+hYbQPLOsUuSyfbE8OebBjW1VxtT5lFy+uGNcnF/hxs+bQUc1zHsPNT8c6/y7GzZV88XycWyN6DuxYuwQ/5khmFU9sNwDdNEhBllFefTvZ9LPckpu9PwWk1aqJDfIKtX9LiP/F5lz4YWFMqP3pBy2rmNtSndXuCLVGZVtuhmJNjUIZhUyDZZwrLOsW/i6AbTsqrTzf7s9oOxRz2Ybftpm5Yy5dxe/bVdKMw2WobFDsGY7mYbaN0v4+GNK0A+7Q8pOiTCKE9+vz7gkxbgSL069cPf//9t6p0btq0yUgNbTLnLUb8wN7IT8/QFVM+qtS0hRWXirt4ONjfxXekpKSgUaNGxpIjIoBkzK6imM0fBw4cqGxCSMVDgRTCmAETrE3kXAVMuL5NOzStVh1tEmroQqimLXKcEkLWOo3lUnJS6Qk9gaQh9fA6DNpQBZP6tEOviDA96ThmrFmAO/Ydt5Wr0Qkze7RG53Bje+rDuh3bbHtWBgYs+hPPtOmMkY2aq7RUXTTViDCi90lBy2rmNtSnw0Hq2BKVabUdijk5BmUYNgWSfaawrFP8uwi64aS8+nSzP6vtUMxhH3bbbuqGtXwZt2dfTTcKk622QbFjMJaL2TZc/T5pBQU4hnz8V5CDQ7oI2qflY3J+mpHrSJcuXVQoZOnULm/ZZW4GG5DAA4Lc4wiwrlZ75B9L10VSH8SfoU9nDUBcv1ORd8g2iHZEnVpqTrzPzp07cemll2LFihVGig25dhcsWIDw8HBUleBDRTBDfu/YsYNBNAipBCiQQgBTCJneIDXfsAE7Dx0yStg5v2lz9KiThNa6EGpaTQImxKJBXJxDJaZopacwx0Wlx17UobDFNrCsU+yydLI9MezJhmFdzdX2lFm0vG5Yk1zsz8GWT0sxx3XE1sXQqoX4qEYvfNM0AUrKaAVI2b8SZ6xO1nOF2ni4Vx/cW902Doragot9N/xzRuEgsbYUPdOSb7d1jG2oT4eD1LElKtNqOxRzcQz21ey2wqG8zVafhcmGYU0szNPNYvsrWkY3rElO9mfFcXtW25iXZnu2AjbTYpszhWWd4t9F0A0n5dWnm/1ZbYdiDvuw23ZTN6zly7g9+2q6UZhstQ2KHYOxXMy2cUL/O9gvHqGCPBzW51t1QbS04ATWFZw0StgZ0KkzarZoriqMpiCSuTtEMMnLntTU1EKxFKpIE7ud19yJzHmLjBQ7Iphqj74FCUMHQ8vLQ1gEx2PyFvKslWZy0hcuPT3dSLUh1/DatWtdiiNBvHsS8ttf+tIREmpQIAUZVm+Q2Gkpe7Fq639Grh0RQq10EdQzqS6SYquidkw0WlZ3rEi4r2Qay/qsMMdteZk5FLbYBpZ1il2WTrYnhj3ZMKyrudqeMouW1w1rkov9OdjyaSnmuI6GnIytuHzhYVw14FRcHWeG89b/5+zDowv/wSe5khCBVi364teWtRBvyy6yHWOuGw9sXIUv9+5EypkXGykaTuTnY21GGjpVq46YMNuguApjG8W2J9gSlWm1HYq5OAb7anZb4VDeZqvPwmTDsCYW5ulmsf0VLaMb1iQn+7Pi/toVdMOw1czd9mwFbKbFNmcKyzrFv4ugG07Kq083+7PaDsUc9mG37aZuWMuXcXv21XSjMNlqGxQ7BmNZn+3Uxc9RLR+7C3KVEPo3P9upEOrcqAkSWzZ38AaVtf+F3P/kxVBJQiqYEUGUvWo9shavQOb8RUooFaXmiCswp1c7aHpFfcSttxippDxIwAsRRmZrjISEBCVwvvvuO+zZs0cJdvEcNWjQADVr2se1K4pcvzLRe0RI5UCBFKBYvUEihA7rN97127YZuXa610lC/waNcEpiIupWjUOTatXQsGo8YtSbQv2nL/z1rbYN95VMY1mfFea4LS8zh8IW28CyTrHL0sn2xLAnG4Z1NVfbU2bR8rphTXKxPwdbPi3FHNfJwfJt/+DCLcUrJcWIbotv+p6CfhFhbvd9LCcHNSLNJnWSomHekUO4dvUifNCxJ86rXd/I0TG2UWx7gi1RmVbb9Xcx5mIYNgWSfaawrFP8uwi64aS8+nSzP6vtUMxhH3bbbuqGtXwZt2dfTTcKk622gb7OgYI87NVycbggH2vyTyBZF0N/5RlNSS00rpaAFt1t3iDTI8SO6OXDFEMn9Cl7tUwbjBznVEmohgavPYXEK4YiPDZGNVeUZwkpGyJkxOMjwkia1AkS/ELCp0s/o4KCAnz66adq2RNxRAipfCiQ/BxTBJlT2t69mLu0cLhRB/7XtTsax1dDy4QaaFK9OhrpgsgmhHSMn1l9Fv7iuuHUtuG+kmks67PCHLflZeZQ2GIbWNYpdlk62Z4Y9mTDsK7manvKLFpeN6xJLvbnYMunpZjD/k7uxSPzVyOtVVeMqhENQ/oYaDiZsRO3rduOA2q5Om7o2g/P1zGiGJW4bxtyPkU0dVw40xbyu+OpRo6OsQ316XCQOrZEZVptV9/FLKoMw6ZAss8UlnWKfxdBN5yUV59u9me1HYo57MNu203dsJYv4/bsq+mGYR8oyEWqLoL26PPtugiS+Xc5zvsJSSdza7M4mUK9yVt58UQMxXZpr08dENO1A2L1KaZdK6xv0M2Wpy83mfqGimwXUbum+k2kr0uxey4pEXkmiyiaOnWqkQIVNl2CXhQV/RLeW7xIIpjEq0QI8W8okPwEa7M403YVMOGG9h3QqVYd1I+Lwyk1a6nxhGrERNsyrb+mk0qP+ixM1g2ntg33lUxjWZ8V5rgtLzOHwhbbwLJOscvSyfbEsCcbhnU1V9tTZtHyumFNcrE/B1s+LcXsCwXYuWcpztociw8HdMRACc5grqhm+kfeITy7cAHeNloa1WjUB/NPqQfVVbrEfdswz+eUFAn5vRbze52JFrFxRqatsPp0OEgdW6Iyrbbz76JTaOqGYVMg2WcKyzrFv4ugG07Kq083+7PaDsUc9mG37aZuWMuXYXtpEkI7XwImnMTBgjzsy8/FxyePqryiiBCyNosz7cpEKqIixqwhlgONsogh6VfkDAnUkHDxEDR842loEsmuRnWVLs2/pIK/cuVKJZZIycg1JZO1GZ2IIjmXrq77/fv3Iyoqip4jQgIECqQKxlnAhJ0bNiL50EGjhJ0RHTraIscl1kQz/QYsQqhBvPRU0XGo0Mh/Y9n6azqp9KjPwmTdcGrbcF/JNJb1WWGO2/IycyhssQ0s6xS7LJ1sTwx7smFYV3O1PWUWLa8b1iQX+3Ow5dNSrHAh/yjeWfI3vqzdG7+1ro04lWzkFdo5+HvzQgxPNqJsVWmKd/t2xdCYcMeNFpq6of9/YJOtGYwEajDP576T2cjWK7KF4kgwtqE+HQ5Sx5aoTKvt9LsIhaZuGDYFkn2msKxT/LsIuuGkvPp0sz+r7VDMYR92227qhrW8m+2d0I39+TlIKcjFTn2+V58+PuFcCA3o3AU1m9u9QVIZ9NdKdaB5RkQIKREkgkifS2juongqhooi/Y9yDxxCTNuWCDNfphmYL+TYzNE9co7MZnRpaTaPqTRNNIURISS4oEDyIaY3yBRE2zZswB4nkeMuaNESrRITcWq9+ipgQhNdFDWIt1V2HX4d64KDLf+N5RLK/3975wEnVXX98d8ivS0LIr0sRZC2IDbQgMQSNRok1sSK3ZgE8Z/EaGKQWBITFdHYCxo1dgmW2MWCXem9LWVhgYVd2N7Y+d9z331v7pt5M7tL253Z3/ez897vnntem3m7e8/c+87VS8+sRKB2iN/INGW18mri+svK52xpg7VN1G0ZsD8RYbMR9max9qdlpL8StinG8XxalpabUwhh544lOOOb7Th71GhMatfE+BhHT4dQsGMpxny/wgyza4Uzhx6Lf3VuJb+U2qLxpBLqRwIkN1FD3PfT7EMvfSepcIxa2trnFuccHBXWGp+/o/XSMxthG706JaOOF+mjhG0KOJ5N/HtXUMJovYq3P8fBkZZ2Vxprm+hrEZQI8NfLOMeztc/Nd4ywDkslbH9TWFepAqHdZcipqsSqyjJ8W1GMxZXOxKo2w3r0QlofpzeovgdCsajPPSP7MxgKQuY/CpVX6CF1pHbI/3EJjOxhdDIJsQRGifY7QQipOQyQ9gF2j5DOHLc5G/NXrTS1YQ7v1BljevTAwPYd0Ce1HQ5u2QL92qVZDRm7UeOImjSKnM1MuRp/vfTMSgRqh/iNTFNWK68mrr+sfM6WNljbRN2WAfsTETYbYW8Wa39aRvorYZtiHM+nZWm56UKoELMWzcE1RX3x0VH9MMjrEDKOtq7IwR1fhIfZocPh+HxEL/QJH8Rz1UL9vLJlI65fOhefH3MC0ltK+nVTbep3VphEDubE9NJ3kgrHqKWto67FxZNKGM0AKbzSWNtEX4ugRIC/XsY5nq19br5jhLUr1+0uRe7u3dihAqEFKghap4Kij8oKnEqLrm3bof+IDN+wuGTpSZAH4uXbfvmbXJcN2QMdDJG9R0Z6uNno3EnSJemCBN0SGPE5OkKSHwZItcANgtyAaFd2Nj759ltT6+f6I47EYR0ORqdWrdCrbSq6tW6DFo2dNMzOO243cMxahK1labnFahQ5m5lyNf566ZmVCNQO8RuZpqxWXk1cf1n5nC1tsLaJui0D9icibDbC3izW/rSM9FfCNsU4nk/L0nbbXYy5WUvw28WZWNthGP47vC+Oaqo+c+1jHC0dqszDoz98gb/uLNdlIA0XDxmO3x3SFh0ayXNLCm//Sqif73bl4r2cbPyya6+oAOmO1Uvx5c4deG3EaDRPcdKK62r7JAXHqKWtfW7VXD8DpPBKY20TfS2CEgH+ehnneLb2uZnClt0VyNtdiazd5VirgqKNlRV4tSR6eFwPFQj1UYGQ3RskLzb0wuzeVaCzu+0NiRoMSSAgAYEEkw0Z+f8u74X0GLnD6OT5OgmK5Jk2QkjDgQFSAPJH0u0NcnWshAnXH3kUerRpi86tW2FQh47o0KIF0po3j2jNKHTRsTlVVr0nlbC1LC03X8Gn5ceUq/HXS8+sRKB2iN/INGW18mri+svK52xpg7VN1G0ZsD8RYbMR9max9qdlpL8StinG8XxalnoVwo5t83H0d6vM5K8WXY7G9xk90NXdUFZVOzB9zie4K3pkk6E1Lhp+HP5+sNxHxiTC0w6R7+er2Vm4fvk8PD/sGIxNO9hYZRG1obvwaZ9bNdfPACm80ljbRF+LoESAv17GOZ6rd1ZJwgQZFleKtZVlKhAqw6vFNUuYwEAoPlVFxUCjRqjctl0FSG295AXVUZNgqGmv7l4w1Pr4UfW2Z0juE/kfl5mZqe+bhoYEhxIUzZo1S5cl6YIERNIL2RDfD0JIAw+Q7IQJbu9QrEDokmEZOlHCgPYd1Lodurdtg/Y6EHLq4zYYBV10bE6VVe9JJWwtS8vNV/Bp+THlavz10jMrEagd4jcyTVmtvJq4/rLyOVvaYG0TdVsG7E9E2GyEvVms/WkZ6a+EbYpxPJ+WpeXm3yasHWnKUdpg/J1qq8KTSlhmIfL91Cm/v3jPSfk9+AhjlUXUhu7Cp31u1ZxD3PvdaL30zEbYRq9OyajjRfooYZsCjmcT/94VlDBar+Ltz3FwpKXdlcbaJvpaBCUC/PXS8i8NVWFLZQVWVpRg2+4KZFeW44nC6AQuwo+GDUf79F46ALKHyJGaU5mzQ88DtOHiSbrc/bF/BD6nsyfBkOiaBlt1jQQCU6dOxcyZMxtMT0msuYvcpAv8UoGQhk2DCZCkN8gNgmS9ftkyrNsW3fA4vf+h6N++PY7s2hXpKiBq36IlurVp42vEBDV64jYYBV10bE6VVe9JJWwtS8vNfw62lh9TrsZfLz2zEoHaIX4j05TVyquJ6y8rn7OlDdY2UbdlwP5EhM1G2JvF2p+Wkf5K2KYYx/NpWVpu/m3C2pGmHKUNxt+ptio8qYRlXltciC4qQG+e4gzbdOtf3ZKFXuqePbJtmmtVC2tDwTFqaWufWzXnwAApvNJY20Rfi6CEZS6t2q2Hx0lP0HYVEK2qKMU3ZQVYVF5sPMIM6tUb/Yc7w+PkJUGQrEn1SGNfegXy8vKiGry7c3eiYvNWZI6/FOXrNqJp7x4YuOQTVGzZZoKhpSj69MukC4aCkB6UCRMmYNq0aTpASGakDSABoVyzO4wu1txFhJCGS9IFSPawONHynND8ldEJE0Z26YIxvXqpQKgbDmnZCh0lYYLMT2C/G+qtCbdvrIqw0dNxG4yCLjo2p8qq96QStpal5eY/B1vLjylX46+XnlmJQO0Qv5Fpymrl1cT1l5XP2dIGa5uo2zJgfyLCZiPszWLtT8tIfyVsU4zj+bQsLTf/NmHtSFOO0gbj71RbFZ5Uwmg3UcNnx8i8Rybtu1WvibU/wTFqaWufWzXnEPd+9x1bS4URttGrUzLqeJE+StimgOPZxL93BSWM1qt4+3McHGlpd6Wxtom8lnUq+MmtqlCBUCXmlxVinQqKPiw26d0tMnr2Qrt0/zxCbLDtHW7PyOzZs7330h1Sl/v489g0eYq2uRzUto3O+GaTbMFQQ0V6i+Rlz13kJl1gzyshJJKEDZDs3iB5rVmyFItXrzK1YUZ26YoxvXth0MGSMKE1erdrh25t26L5QY1Vrbl0vbK1Qb01XjGi0eOghNFxG4yCLjo2p8qq96QStpal5eY/B1vLjylX46+XnlmJQO0Qv5Fpymrl1cT1l5XP2dIGa5uo2zJgfyLCZiPszWLtT8tIfyVsU4zj+bQsLTf/NmHtSFOO0gbj71RbFZ5UwmhJ1HDmD5/j8aFH4tSDuzhGq14Ta3+CY9TS1j63as4h7v3uO7aWCiNso1enZNTxIn2UsE0Bx7OJf+8KShitV/H25zg40tLuSqMqtlSWI6+qEhvKS1UgVKQDo6BAqEdqO/QxPUJubxADodqRk5ODjh076nWzZs3QVv1ND0IaxBMnTsSUKVN0sCTBT4oKjmRI3a5Z7xqvMI07d0Srow5nMJQkyDA6N+mCO4yOcxcRQmpCQgRI0hPkDpHL37IFs7/5xtT4mTxqlGp8pKJL6zYYfEhHdGvTFi0aSyCkiLjM6IaOrQ3KySva24eNno7bYBR00bH5ji14Uglby9Jy85+DreXHlKvx10vPrESgdojfyDRltfJq4vrLyudsaYO1TdRtGbA/EWGzEfZmsfanZaS/ErYpxvF8WpaWm3+bsHakKUdpg/F3qq0KTyphtEwMe8QX7+PGPofhN736O0arXlJ9/3frJrRW9/5Znboru7cTB100Nkv73Ko5h7j3u9F66ZmNsI1enZJRx4v0UcI2BRzPJv69KyhhtF7F25/j4Ei12mmeDdpYUYY15SXIqizDy/nR85sJbsIEd3icvPhsw96zfft23HHHHfpLMgkuzz77bHTo0MEbSteiRQvtJ/8zpDEswdGYI45Eo9atsPmGW5H7zMvYvTNf+9h0nnIDDv7tFQyKEhxpL0hQFDl3kQRF/DKCEFITEiJAkj9odvKEiYcfrnuCBhx8MAZ1lMxxLdFe/UOM2wCPuEynaGxR2qCcvKK9fdjo6bgNRkEXHZvv2IInlbC1LC03/znYWn5MuRp/vfTMSgRqh/iNTFNWK68mrr+sfM6WNljbRN2WAfsTETYbYW8Wa39aRvorYZtiHM+nZWm5+bcJa0eacpQ2GH+n2qrwpBKW+X852RjQqnXgEDt5vuWseV9q/erwUV7Kbw/tZ5wtbR+2unOIe7/7rkVLhRG20atTMup4kT5K2KaA49nEv3cFJYzWqwD/nbsrdea4lWXF2KYCos0qEHo8L1vXRSLfSrs9QvL3StbOsJ0KFK56EA9OmYEPthVhxZYf4fg7bsa9P+uPjiaTO6k9paWlePTRR33Py7jvvTx3dOKJJ2L37t3abvcuSVAUKi3TPUWly1ah8IPPUPjJVyj89Etdlzr+lJiJGkj9R4Iizl1ECNkXJESAJH/g5Jugjy+7DKN69HCMAY2euA3wiMt0isYWpQ3KySsGHE8Lo+M2GAVddGy+YwueVMLWsrTc/Odga/kx5Wr89dIzKxGoHeI3Mk1ZrbyauP6y8jlb2mBtE3VbBuxPRNhshL1ZrP1pGemvhG2KcTyflqXl5t8mrB1pylHaYPydaqvCk0pYZiHe+/mqPKe0fD5mDh+NI0zCBg/tZ5wtbR+2unOIe7/7rkVLhRG20atTMup4kT5K2KaA49nEv3cFJYwuCVUhu7wMmypKkbO7AitLi1UgtNmpjGBMxnCk9XYyx7kBkaxjEdp0J67tPw+V3zyFJ4Y2wobnRqP3xX1wwffP4NnD2Uuxp0gPwQcffIA777zTWPxIkCQZ2dyheLGIDJjKVq1F25OPR0rzZsaD1HekFzFo7iJpN3AYHSFkT0mIAMl90JYBklWIOB/vTKvx10vPrESgdojfyDRltfJq4vrLyudsaYO1TdRtGbA/EWGzEfZmsfanZaS/ErYpxvF8WpaWm3+bsHakKUdpg/F3qq0KTyphmYV476ek/L5g0Tf4Q/oAjGnnzInkof2Ms6Xtw1Z3DnHvd9+1aKkwwjZ6dUpGHS/SRwnbFHA8m1j3bmZZCXJVELS+vBSrVCD0dfEuLCwtNLVhMnr1RjsVCLm9QW5AVDuKnIDodz/Fv1bcjl+lNgIqFmPOtHWovPZUHN/GzUBIYmE/ZyovKbu9A0FIL4H8v7j66qvRXKZhUMg28pLPr7peBAmYUhofpIfikfqNBMkSGEXOXSS9RbX/XSWEED8J8wzSuHHj8OK552L8YYc5Rl8DyF0p4ZltrYi4TKdobFHaoJy8YsDxtDA6boNR0EXH5ju24EklbC1Ly81/DraWH1Ouxl8vPbMSgdohViPT8TNltfJq4vrLyudsaYO1TdRtGbA/EWGzEfZmsfanZaS/ErYpxvF8WpaWm3+bsHakKUdpg/F3qq0KTyphmWUY3cc7tmJAyzbo01KG2fnrY+5PcIxa2trnVs05xL3ffcfWUmGEbfTqlIw6XqSPErYp4Hg22SoA2lThpNCeX5yPzPISfFAQPbFqt3Zp6JcxzAuA3GFa+4Zy5L5/Bo79SQ4aT38Ir197NPo34bi6IGozJ509Ee4999yDwkInwJXP79lnn0X37t19gZD7BduMGTPYo5DgyH0i6bnlM+XcRYSQ/UlCBEjyzzI9PR03jB6NO046yTFGNahkpYRntrUi4jKdorFFaYNy8ooBx9PC6LgNRkEXHZvv2IInlbC1LC03/znYWn5MuRp/vfTMSgRqB3+j1dbeQq+8mrj+svI5W9pgbRN1WwbsT0TYbIS9Waz9aRnpr4RtinE8n5al5ebfJqwdacpR2mD8nWqrwpNKWGZJxDD483esRA3++pj7Exyjlrb2uVVzDnHvd9+xtVQYYRu9OiWjjhfpo4RtMv5bVBCUKwkTVEC0pqxEr1/K26LrbHqqQCjdBEJ2j9B+b1BVzMeHt5yOCXftQuXZt+GB+67FFd0a9vAt+cLL7dURLQGROzTKRhq+7udkf24uWVlZuOiii/Q+pIEsc/iUlJR4CRpc3C/Y3Ex2JPGQe0U+u8i5iyQoaigT2xJCDiwJESAJKSkpOGPAALx8/vmOIapBJSslPLOtFRGX6RSNLUoblJNXDDieFkbHbTAKuujYfMcWPKmErWVpufnPwdbyY8rV+OulZ1YiUDv4G6229hZ65dXE9ZeVz9nSBmubqNsyYH8iwmYj7M1i7U/LSH8lbFOM4/m0LC03/zZh7UhTjtIG4+9UWxWeVMIyC6d9/yk6N22OJ4cepUoR9WYfJVW78e3OHRjWph3aNW6ibY6fcba0fdjqziHu/W60XnpmI2yjV6dk1PH8Pjt3lyOvohIrSouwtbIMy0oK8VJudCAk2D0M/oQJdUTFcnz7+CX49Y3f4vsjb8djL96IKw4x2TWTGGnURvYKBQ2Pk6FRkYFQTXrxJEB67bXX9DYjRoyImepbeh3S0tL0fSHBEkkcJCCSYXScu4gQcqBJmABJ/mHKH8mSKWZiv4AGXNwGeMRlOkVji9IG5eQVA46nhdFxG4yCLjo237EFTypha1labv5zsLX8mHI1/nrpmZUI1A7+RqutvYVeeTVx/WXlc7a0wdom6rYM2J+IsNkIe7NY+9My0l8J2xTjeD4tS8vNv01YO9KUo7TB+DvVVoUnlbDMwu2rl+DhDauxeuxP0bxRI3+92ceneTm4YOE3mDYgA2dLym9BVxlnS9uHre4c4t7vRuulZzbCNnp1SpptSqskYUIpsspL9PNCm5V+dNtGXRfJmIwRSOvdM6pxXT8pwOaZZ+CEn6/Frn+9hVXXDUOyPOWyp8Pj5G+6fGZ724uXm5uL9jLJdxyk90F6GuR4pH4TNHeR9Ca6nyGH0RFCDgQJEyDJN0bTp0/Hwl//Gv07dJAWlalReO0tJTyzrRURl+kUjS1KG5STVww4nhZGx20wCrro2HzHFjyphK1labn5z8HW8mPK1fjrpWdWIlA7+IMKW3sLvfJq4vrLyudsaYO1TdRtGbA/EWGzEfZmsfanZaS/ErYpxvF8WpaWm3+bsHakKUdpg/F3qq0KTyphmYW8ijJta9ekqSpF1Jt9SA/S2fO/0vrVjGNUIHWQ8TPOlrYPW905xL3fjdZLz2yEZcwsLcbGslLkVJZjZUkhvirIw8LiAl1nM6h3Ojr26uk1qKVxXe8buqEtWPX2C/iwz2W4ZlAq9JNHux7CjQN+jQev+wIbbhmFREwkXdPhcZL23P2cEuYzI3WK3EsSGHHuIkJIfSBhAiT5wzl58uRwJruABlzcBnjEZTpFY4vSBuXkFQOOp4XRcRuMgi46Nt+xBU8qYWtZWm7+c7C1/JhyNf566ZmVCNQODJAMAT6usN3824S1I005ShuMv1NtVXhSCcssxH0/rf09vSkTt6xegncP/xEGt25r/Iyzpe3DVncOce9369iykEBohwqCtquAbl5hPtaWFeGDndu1j01k5ji3lyEhqfoUz555Mi7OvBXPfvNHXNiyEvlfX4oJxxbg4C+fxotHt3eCpnpKbYfHJcVnRuqEyLmL5J5yky7I/UQIIXVBwgRI7oO2Xia7gAZcTRqMLk7R2KK0QTl5xYDjaWF03AajoIuOzXdswZNK2FqWlpv/HGwtP6Zcjb9eemYlArUDAyRDgI8rbDf/NmHtSFOO0gbj71RbFZ5UwjILcd9Pa3+luyv10LX9/QySDI3Lq6zABhUQrS4twnwVDH2wM8c4hOnZrj3SM4b6ehbklVxDZ0Ko3PQcnvj73bj7yw5oVroVjYafg9OvuwZTRneGk4C67tmT4XHu55VIn5lclzTE5fyl4U3qFvfzkMCIcxcRQuojCRMguQ/aepnsAhpwNWkwujhFY4vSBuXkFQOOp4XRQQ1GH7ro2HzHFjyphK1labn5z8HW8mPK1fjrpWdWIlA7MEAyBPi4wnbzbxPWjjTlKG0w/k61VeFJJSyzIO/n01mZWFKwC/8cmOGvj7U/wTFqaWufW5xz2KmCIMkct6KoUAdCG8uK8eK2TcbHz/545oTsGXs6PE5eUk5k3C/YZMiWNMxJ3SCfg7z/kcPopMdI7jNCCKkvJEyAJKR36oQOjRtjzpVXBjbg4jbAIy7TKRpblDYoJ68YcDwtjPYfWxFxPKfOsfmOLXhSCVvL0nLzn4Ot5ceUq/HXS8+sRKB2YIBkCPBxhe3m3yasHWnKUdpg/J1qq8KTSlhmQd7PO1Yv1YkaFh/3E7RrLM8iGWLsL7usFF2aSv+FsTkOjgy76YLMtbRZ+a8oLsS28jJsKivBI5szjYMfu1FtD7ciBx63J8juFeLwOPXPLiWFmezqAPlyk3MXEUISjYQKkOSftwz/yP3Tn9DiIGsWeq+tp4R3NbZWRFymUzS2KG1QTl7R3j5s9LT/2IrIt1UXHZvv2IInlbC1LC03/znYWn5MuRp/vfTMSgRqBwZIhgAfV9hu/m3C2pGmHKUNxt+ptio8qYRlFuT9fGdbNq5c/B3eO3IMBrdKNTWKgP3dkbkMj2xci0WjTlbBlEkzrapKqyp1ILSxtEQHQitVQPTVrh1YUBjduzBmxOFI69nD17PAb37rBnd4nN0zlIzD4/YVcs0SKCbQv7yERu5HNxudPYxOAiPOXUQIqe8kVIDky2Rnp3U1VxC3AR5xmU7R2KK0QTl5RXv7sNHT/mMrIt9WXXRsvmMLnlTC1rK03PznYGv5MeVq/PXSMysRqB38QYWtvYVeeTVx/WXlc7a0wdom6rYM2J+IsNkIe7NY+9My0l8J2xTjeD4tS8vNv01YO9KUo7TB+DvVVoUnlbDMgryfMrzuD8sX4Nb+g3FkW/t3wnHWS6Pf2b4FVy39ATf2HoC+LVphbsFOfLUzOBDK6J2OdiZzXEPoXajvuEGQ2yskr4YyPG5fIe+ZvBfssdi/BM1dJAGR9CDxXiSEJAoJFSDJN1ETJ07EmxdeiBP79DFWhbmCuA3wiMt0isYWpQ3KySva24eNnvYfWxH5tuqiY/MdW/CkEraWpeXmPwdby48pV+Ovl55ZiUDtwADJEODjCtvNv01YO9KUo7TB+DvVVoUnlbDMQrz3M7u0BLkV5VhfWoy5+blYW1yE93dsNbVheqa1R/owf8IEBkJ1hzTiIwMhd1iSDbPHkfqE9Ga6SRc4dxEhJBlIqADJfdD2CfUH94Jhw4xVYa4gbgM84jJr2mj1itU0Wv3HVkS+rbro2HzHFjyphK1labn5z8HW8mPK1fjrpWdWIlA7MEAyBPi4wnbzbxPWjjTlKG0w/k61VeFJJSyzIO+nGwhtKCnC6qJCnUHuhewNxsOPDG8pLi5Gv379cNVVV+kGNhsudQOHx5FkQO5hCYqk18jt0Rw/frwe7cGAnRCSyCRUgCTIg7Y6k92JJxqLwlxB3AZ4xGXWtNHqFatptPqPrYh8W3XRsfmOLXhSCVvL0nLzn4Ot5ceUq/HXS8+sRKB2YIBkCPBxhe3m3yasHWnKUdpg/J1qq8LInRVlyC0vx/KiAmwtK8UmFQhJcoYg3Aa126vgalI3cHgcSTakt0he9jA6N+kC71lCSDKQcAHS4QMHolFBAeZccYWxKMwVxG2AR1xmTRutXjGg0aqF0f5jKyLfVl10bL5jC55UwtaytNz852Br+THlavz10jMrEagdGCAZAnxcYbv5twlrR5pylDYY/xLJHFdSjI3qta28FCsKC/Dw+lW6LpKxh49Eux7ddW+ENFTuvfdePZkyqRsk8OHwOJKsyL3tBkbufS1BvRsYEUJIMpFwAZI0JKQxuOn3v0f7Fi0co9feVMK7GlsrIi6zpo1Wr2hvHzZ62n9sReTbqouOzXdswZNK2FqWlpv/HGwtP6Zcjb9eemYlArUDAyRDgI8rbDf/NmHtSFO29NqiQuwoL8O64iIVCO3Cl7nbMT8/T9fZDE/vg9SePbwGtdu74OIOPZ0yZYoe818d0tBxv+mVxg6pHRweRxoScp/L34nIuYvkbwgDe0JIspJwAZI0AKdOnYqF112H/h06OEav7amEdzW2VkRcZqxGa+Q2XtHePmz0tP/Yisi3VRcdm+/YgieVsLUsLTf/Odhafky5Gn+99MxKBGoHBkiGAB9X2G7+bcJ6TaEEQqXIUa+5O3OxpqgA723LNrVhurdvj75Dh9a6Z0Ea7DKJsjTGpTFTE2Tf8i1wXl4eG+xx4PA40hCRvyluNjp3Di1JuiBBkfQY8W8GISTZSbgASb7Jkkx2L557LsYPHOgYzRXEbYBHXKZTNLYobVBOXtHePmz0tP/Yisi3VRcdm+/YgieVsLUsLTf/Odhafky5Gn+99MxKBGoHBkiGAB9X2G7ZJcW6R2hDcRFWFebrxAn/2ZhpasP0bN8B6UOHeI1ot0G9N40OabjIPqTxUhPcLxpq2uuU7EjgExkIBQ2Pk0aiG7jK2tWEJAPyOxA0d5H8fZEXIYQ0FBIuQHKHE0079VRcc+SRjtFcQdwGeMRlOkVji9IG5eQV7e3DRk/7j62IfFt10bH5ji14Uglby9Jy85+DreXHlKvx10vPrESgdmCAZIjwyasoR155KZYX7FJBUSmW5O9UgdBa4+OnviZMkG+I3YCqpkFVMlDb4XH7MoglpL4ivw8SGM2aNUuXOXcRIaShk3ABkhCVyc5cQdwGeMRlOkVji9IG5eQV4zSYHRXWmsi3VRcdm+/YgieVsLUsLTf/Odhafky5Gn+99MxKBGqHhh4gle52EiZIj9DawgJsKinCg2uWa59I3IQJbkPabViTumNPhsfVpyCWkP2JfFkgPUWRcxe5SRf4ZQAhpCGTkAHSj485BrO/+QYlf/mLY/AatuFGrhb2lUVcplM0tihtUE5e0d4+bPS0/9iKyLdVFx2b79iCJ5WwtSwtN/852Fp+TLkaf730zEoEaoeGEiBJICTBz8aiImwrK8Hy/F34YvtWzN+Z6/hYDE7vg35mYlU3CJJ1XSONHQkIBPnmtyEhgc+eDI9zP0NCGhLyuyI9Q5y7iBBCYpOQAZI0AGUogJfJzmvrKuFdja0VEZfpFI0tShuUk1eMamALShjtP7Yi8m3VRcfmO7bgSSVsLUvLzX8OtpYfU67GXy89sxKB2iEZA6Q1hQXYUVqKHBUI/ZC7XZffzc7SdTbD+/RFao/uvh6F+tx4kACptokaBGksyTfI7jNM9Rk5V3lxeBwhtUd6i+Tl/s7IMDr5vZfASH5PCCGEhEnIAMl9wPzrq65CRufOVttYCe9qbK2IuEynaGxR2qCcvKK9fdjoaf+xFZFvqy46Nt+xBU8qYWtZWm7+c7C1/JhyNf566ZmVCNQOiRwgydC4XBUIrS8qwKqCfMxVwVBQINSrw8HoPWRwUjSm5fyl56Q2v9Ju0hNJ2yu6viBBUGTPEIfHEVI75IsTN+mC26vqzl0kXzTySwNCCAkmIQMkGRowYcKEcCY7r22shHc1tlZEXKZTNLYobVBOXtHePmz0tP/Yisi3VRcdm+/YgieVsLUsLTf/Odhafky5Gn+99MxKBGqHRAiQcsvKsKm4yAmE8vP1+vnM1abeT2TChGTrVXB7VufNm6evrabIeyDBR12k/LaDILdniMPjCNk75HdJgiLOXUQIIXtGQgZI0pgaMWIEpv74x/jDccd5DWYGSI72CPDXS8+sRKB2qE8BUl5ZqQ6Glu/Kw5aSEmSpoOhfyxebWj/yDak0nu0GtbySHXdoXW0DP7dHdubMmfvt+SV3SJwbBMnvsDu/SiQcHkfIniFBkfQYRc5dJK+G8DeQEEL2FQkZIAmSyW6iCpIeOuMMr6HNAMnRHgH+eumZlQjUDnURIOmECdIjVFiAbSXFKiDaiS+2bcG83O3GKczYkSPRrns4c5zboCa1Q4bhyGtfNaA4PI6QA4f8nrmBkft7Jl8yuIERIYSQ2pOwAZI0quRbMp3JzlwBAyRHewT466VnViJQO+zvAGlN/i6dMGGbev2wfRvmbM0ODISG9+2H1O7dfI1oDhPZO3JyctCxY0dT2jPsIIjD4wg5sMjvnARFkXMXyfNF/P0ihJC9I2EDJPlmTMZXr1b/DLq1aattDJAc7RHgr5eeWYlA7bCvAqTNRZJCu1D3CP2wPQerVWD0TlZAQ/rgg9F7sJMwQV4MhGqPfJMsL3e4XSQlJSVo0aKFHlJ3yimn4OijjzY14VThkcPsJPCRlxsESUDE4XGEHHjkd1SewZVhse6XEZy7iBBC9j0JGyD5Mtl16qxtDJAc7RHgr5eeWYlA7VDbAGmzCoKkR0iGx63alYf1BQV4dvUKU+uHDen9g/vFQVCiBmlcFajP5Gc/+5kOciSQOu+889C8eXNdL8GopAC+5ZZbkJ+fr33kxeFxhNQt8sVE5NxF8jfUzUZHCCFk35KwAZJ8mz1u3Dgnk92AgdrGAMnRHgH+eumZlQjUDrECpLzSMuSWlWBZXi62FBfr3qEHFsfuUXAbz2xI739kyM3kyZMxY8YM3/MHpSpwfemll3SDSgIl4YwzzsChhx6K77//nsPjCKmHSEAkv9Ocu4gQQg4sCRsgSYMuPT0dN4wejTtOOFHbGCA52iPAXy89sxKB2qGksgKbCouwoTAfW1UgtGxnLh5YFBwIHT/yCP2ckNuAdhvT5MDifnEwZcoU/Y2zPGskQ+ouuugi3diKhTS8hgwZooMlSYDyzjvv6M+PvXqEHFjkCww36YI9jE5+n6W3iL+ThBCy/0nYAEmQhtwZAwbg5XPP02UGSI72CPDXS8+shNFrzJC4bSYQmpO9GXNztjmVFsP79UNqNydhAgOh+ok0sKQRlZubi6KiIowZM0Z/oRCJDK2TQEg+Q/fbaAmiZFv5fAkhBw4ZzipBEecuIoSQuiehAyT5pyFDD0pu+YsuM0BytEeA/+pdO7G9pATb1Ov7rVt0+X/rM3WdTfeDD0bfwYO9oVXy4j/pxGLLli062JEJYN9//30d/EgPkzvETigsLESrVq1MiRByoHETq9jD6NykC+4XF4QQQg4sCR0guQ+kL/zVdejfoYMTJHhXY2tFxGU6RWOL0gbl5BXt7cNGT9e3AEknTFBB0Lr8XVi5Mw/r8/Px7+VLnUqLXgd3RO/Bg3y9QRxalXxIUCTPIXXu3BmLFy/Ga6+95j3fIM+JEUIOHNKj6w6jc5MuSOITNzAihBBStyR0gCT/XOSB9I8vnYhRPXo4QYJ3NbZWRFymUzS2KG1QTl4xIiBxUMLougqQ8lSjd0dJKZbmbseW4iIs2r4d/162RNdFwoQJDQMJfKSRJc8sSIMrCBl+16hRIx0Iu0PyXKTs3h/xnlsihNQO6cGVwChyGJ38nnKoMiGE1B8SOkDyMtmdcy7GDxyoQgp1Kd7V2FoRcZlO0diitEE5eUV7+7DR0/s7QCqprMSmggIsU4FQdlERspSePu8HpzKC4484Eqnduup/uAyEGh7u74U0vKQxtifI/SIPiGdmZvLeIWQvkC8c5IsG+cLCTrogX2JIYMTeekIIqX8kdIAk/3jS0tJww6jRuOPEE1VIERFg2FcWcZm+ICVKG5STV7S3Dxs9va8CpJIKFQgVFmB9/i4nc9yOHfg8ayPmbttqfMIM7tsX/YYM8YbFSUOW30ISQRKYyJAdefB7T5DAauLEiZg0aZLuqSWE1A4ZRie/O/K7xLmLCCEksUjoAElI79QJQ1WQJJnsEi1AWr0zD9uLS7CtuAjfbcnG6rw8vL12jfaxGd6/P1K7dmXCBFJj3OcY9rQHyR1m56YWJoTUDOktkt+7WbNm6bIkXZDfIfldYm8sIYQkBgkfIEkjTrL/5N50M5o3PsiNQRRK2FcWcZlukKKJ0gbl5BXt7cNGT8cLkKRHaIcKhNbt2qkDoVW5EgitNrVhenc8BL0GHebrDZIXh2AQQkj9Rb5QkKBIeow4dxEhhCQ+CR8gyXCF6dOn60x2/Tq0t4KU2AGL4BSNLUoblJNXtLcPGz0tnnklpdiYn68DoZW5O9R6F55ZvMhxiMBNmOAGQQyECCEksXDnLpJeI3cY3fjx4/X/JfbyE0JI4pLwAZKbye7NCy7ACX36BAYvmn0YIOWWlOjX0u05yC4oxMaCfNz33bem1o88ByLBjzssTtYcZkEOBO7zR3L/7SluA1CG7LHBR4iD9BbJy567yE26wL/vhBCS+CR8gORm7Hpi/Hj8ctgwK8BRwr6yPQiQSioqkKWCn/W7dmFrYaEKiLbj8w0b8MOWbOMR5vgjj0Jq1y5eb5DbO0RIXbG3iRoE+WZ8woQJ+ltxpvwmDRkZRucmXXCH0XHuIkIISU4SPkASpCEomexuP/EEK8BRwr6yagKk1bk7kFNcjLV5eVimAqHPNqzHD9nRgdDwQw9FapcuXm+QGxARUt9wn8/b219xuc+Z8ps0VGLNXcReVUIISV6SIkA6fMBANCoswOeXX24FRUrYV2YuU+YS2qB7hIrw3eYsrMrNxVsrV+o6m96HHIJehzkJE9weIf4zJImEPCDuNu72JrCRb81lX+5QO0IaAvJ7I/f8ggULdJlzFxFCSMMhKQIk95vyHTfdhBYHNda2Tfm7dOa4zJ15WLF9B9ap9dMxhhpJwgQ3CHIDIv4DJMRBhhYJ/J0gyU6suYskMOKXA4QQ0nBIigBJvt2eOnUqJo8apcvTvvpKryNxM8e5vUGuJoQQ0nCRnlYJjCLnLpLeIvnCjBBCSMMiKQIk+bZPZv13Of6oo/RzQm5vkLwYCBGyd0hPkiRq4DfpJBmINXeRm3SBPaaEENJwSYoASYZFSKYuCYL4bR8h+wf5Rl2+YZ89ezafxyMJi/y/kFEHkXMXSVAk9zghhBCSFAESIWT/4/bUSgYv0YQkEhIQSW8R5y4ihBBSHQyQCCE1RhqSTPlNEoV4cxdJbxGH0RFCCAmCARIhpMbIt/B8po/Ud2TItQRGnLuIEELInsAAiRBCSFLgJl1w5y6SYXRu0gUG9YQQQmoKAyRCyB4hD7uz0UnqGrkP3cAoseYuqkTpjiVYu+BtvHVnS3R7YxIuaJli6gghhNQlDJAIIbVCGqQyTEme35ChTITUBZFzFwkyjC4x5i4qweYPf49Hn30F9/57G4qvfhPLHj4dhzI+IoSQegEDJEJIrZEASbKBzZs3j6n1yQHDnYtL0nQnw9xFVcuvw6mH/Q8rn34Pqy45FI2NnRBCSN3SyKwJIaTGuEOX5Bt8QvY30mvppuOWVPMSHMkwupkzZ3p1iZeRrgw5y+fhO/TGsL6HMDgihJB6BAMkQkitkQBJhjNxYk2yP5HeIumtTE9Px/Tp07Vt0qRJOs28DLFL7PsvB2vnr0ZeWgZG9W9tbIQQQuoDHGJHCCGk3iDD6NykC/YwOhlWl1RzF1V9imfPPBmXtHoG3/3nfIzk80eEEFJvYA8SIYSQOkcSfkjPZFpaGiZPnqyDo/Hjx2P27Nl6GF0iPmPko+Bz/O+fJ+DEfkdj8M9uxv1vvYI5b1ci7eiBGMjgiBBC6hUMkAghe4w0amUIlHzjT8ieIPeO3EMjRozQE7vK3EVTpkzRw+jcIXaJTQgVm+7HzYfejAcGPYHXVn2Dxc8NQflDz+D9qhEYNqg7WhlPQggh9QMGSISQPUaGQ0k2OwZIpDZIj5AMmXOTLsg9lJGRgRkzZuh7yq1LBkL5L2Da+Tfj+d/dh2dOS0dqCpDS9iScdFI7rGudgWMGtDWehBBC6gsMkAghe4x8uy8NW2ngck4kUh2SWEGGyknShalTp+phdJLsQ9LFu0PskotsLHj8T/jjtsm48dLhOMQdShfKxfbsYmDYcIzq0sQYCSGE1BcYIBFC9gpJsSwP0UuvACGRuEkXZL6scePG6WF0cr/IMLq8vDyvLinJfR0vPLoBLS88Ded3OMgYVXy0+TW8OnMnWp1yBI5rygeQCCGkvsEsdoQQQvY5EjBLJjoJgHbt2qVtMneR9BIlX09REFUo/uIsHH3cajT777v4bnw3OKHQenz3t7H48c1tMMBnJ4QQUl9gDxIhhJB9hiRWkHTc9txFMozOnbuoYQRHQiGyFi/CYjRDmxbNTBBUhdKFd+L2O9er2sNw9IAODI4IIaQewgCJELJPcB+8Jw0PGUYnvUWSWGHChAmYNWuWHkY3bdo0fV9IL1KyJF2oOQeheatWsKeADRW8jgd/9SEOGtUMGDICo3qUYOFry7CN4zgIIaRewQCJELJPkOBIHryXHgTSMJDgR3qEJPgJmrtInk9Lmolda01LdM44CqNTVmLB18uxY8f/8NJV92PhXfdjbGEF0CYfeQ/+DFeUHIQ27EYihJB6BQMkQsg+wR06JT0JJLmRHiHJYCjD6CTpgjBp0qQkmrtoX5CCpkNuxT0zxuLkWaeizyVfYdFNb+CZo9qi22Ht0Rzb8VH3h/HWBYeihdmCEEJI/YBJGkjyEcrGks9C6Du2q2qE1GMqVuDTlZ0xZnBq0jyHID0J0osg2ckabs9BcuIOo5PgSD5jQVK8Sy9Rw3muiBBCSEMgYXqQqrJewfPTJuK3I2/A3zdXGmtyESrJwvLtpahdxBpCZf56ZJVUmXIDJ7QO86adg0uXbkP+vg79Q/nYvnx77fdbmYO1OSVRn2uodCWWXno1frNwZy0/8/qL9B5ILwKDo+TBTayQlpbmm7tIhtEl59xFhBBCGjoHMEDahvkPHovBgwfr149+NBCnDmuClJQ2aD56AoZe8Dtc/shH+CS3wvj7qdr0Cqbc8DQemFuMUmNLLipRMOdSDLvsP/ikohbN5dBKfHLTT3DDwmJjiCC0DJ/d2hctBv8Wf1xWaIzJSg5WPHU2Tlg8GY9ckRGelLHsDTxysnPfyetnp/fAEW1S1L13KA75yfkYfe3duOm9ZciqrOZ9z38O/xj2G9y0osgYakI5cj++EEc8tVQpPyltTscVrwxE8fF/wM2rYnx+CYbMZ9PwHsZPTtz5iSLnLpIA2B1iRwghhCQjBzBASkFlwSosXboUSyuORm8V7Nz4+hqsWvUFFj7wM9w28ius/f2JGHfMRJz3cVZUENS4xyAcK6JHZ/RIDU+4lzwUY8vadah48xU8PDff2KojhIrlD+BfD4ewZoszz0gUObPwn3vWonTpDDz03pqoRnryIOlz/4z/u2Ykrv7LTzGyiTVo7aAyFK5V993SDVg7/CqM/eN7eGzhWqzLfAYfTB6KC6ruwb9OOQr9fzEdT2wqMxtFU5W9BAsq3sMLs5Yiz9iqpeITvP7AJ9iZmY0NxhQmBU16T8Kf7vkad09+Hu+WJEs/kjMcSx7SJ4mFm4lQegAnTpyIBQsW6LmLZsyY4dUxACaEEJL0yDNIB4bi0PrnhkoLMISLXwstNtYw+aFNr48NDZT6tImhySuLjN2waUroYqnr+8/QyxXGllQsC717XWv9/jSe9G4os8qY41G1PPTh/7VX23QJdXlsWSjwbanKCi189pzQ8WfeF3piY6kxJiHFb4QePLV5KO3v34Zyjcmj6uvQC2c3Ve9T39CglzcYo0XFd6E3rkvT732j854LzSk3dh/loR1v/SiUJvdgl9+H7t1ek5uwLLTjvZOde/rkJ0OzdxtzJEUvhu7KaB7q9egS9VuSHKSmpoZ69eplSqS+M3v27ND48eOdv8/qJZ/fJZdcEpo3b57xIIQQQhoOB7AHqRGaNGlidBBt0PW0X+GyoSlA3n/x7/czETzYLknZvQLLv3CGblU++RzuXxO7J8PB6T164NFcpbOxY+tOlDgVflK6YeiFL2P2zEm4vHszY0w2SrD5jb/ij+/+ElefnwEVxPhJaYImzeKkQWg8EidffBIylKx66RXMWB403C0fG5avcXqOsl/B/W+tRbVPwpneo+WiV25BVrm0PQNoeRrOnpSODb/7F+7KSo67XoZfybMq8vwKqZ9IL587P5EMowuau0iG2BFCCCENjfqVpKFZP/QZ1lSJPOz4dgVWOtaGwY5lWLysKfrKrIKFb+Pp1xbGH8YVWonPnnwBs8xjReWrNgcM4WoglL+HV6fPReF5J+HsnnL/1JYUNOt+mA6QgMX4avkOrfxsxsalhaoBKb8y67Du0TcxszhGwKMpR+7se3DPW2ZQ47oNWJ2729FRtEH6j8fjvMLn8MCrS1CbJ5zqK5LZTGDK7/qHBD/u3EUyjE4CWRlGN3PmTF3XsOcuIoQQQupxFrvGndqhvdHJTwilq77Gsxc9gntu7qrKech7+g28sCNWg9rpPbr7kUvx8L1DHNOiLKyJ5Z7UVKH4u2fw+Ffd0PMnR2DEXufLbodDUgNmJSldgAXP/xJ//ud4jJLyV6/j4S9y9HikQCo+wWtTF6LL/bfgQm1YjzVbY/cKpvQ8DaedXorcJ9+pJvBKDKQHSTKduYESqXvc+YmC5i6Snr4zzzxT2wghhJCGTv0KkEqXYvkX0ogcgoxjB6CzY62eUC42fXkb/nHlcCczXpsj0OO8G3Dx8z9gVWBGuDJkvzwSKSkpSLnkdSxRllDJQnzz3CW44eed0E9n1rsEp9w/B0tiZZQr+ALvPzQB156Uijba/0L8+PY3MLtgT6KUUmxbtxboPwSnnnMezpRepOUvYPq761XzPwDpPXrsNSy793JcPPow9BXbli3IKgzwrnwFd/eTjG39MPiVjcZo2HwrLpH3IOUa3Lq5EqGCd/DC7wZgZKPO6PD3byCD96Lfq90oWHgLbj69HRo1Og3nfrNTezmEUJk7G+/J+3LaIep9NJnizvqd+iy+weKgVOQ1Ood4bMPSz77GYhyOE0d23cMbWgWomfPxmci04/CTjOhvz0PblmAB0pE6fiquPUN6qb7EJ099jLmBt4fTezS57e2Ydrm6l/UHlIOsnMBBkA4pgzB0bEdg8Wy8sajAGBMbZjqre2QYnZtYYcKECfj000/1MDo36YL08DHpAiGEEOKnHgVIKkj46Ck8t061FU+8Crec1LWGk2duwPd3H4Oxx87EM/3vwLUvr8GG7/6Mxw7/EF9fOAHHTZ2NVVGN2EZo1qqVeVZlN1JW/QO3nzkaYx9pjKW9L8RFk3pi2KJ/471JV+IX/90YEaSEULHpfvzlp+NwyowuKJ/8Ob7OnI3vb2mE7s+ciRN+fj9ezq9tkLQN6xbloG96JzTtezV+fbX0na3Bygdn4rWA3oTQphfw7IPn4prxh6LFwd1VOKnI3oDV2wOeX0lpiiZtYryTzVKR5j6wU74KMyefj1/es1I1+tuia9/O5v2x36sQWq27DX846w787e1dCLXqhUHdW+ka6ckpWXUnbh5/Csa/PQzt/zwH/12xAuvXPYW3xi9F3p9G44iz78aTWyPOsUbnEIfd8/D929tUYKMCwK57+IxVaDE+efEzrEMPdP7zRbi6U2NT4VKF4rULMOucfhjU9DD89NfHY6Cyhl58Bnd9G5A9MLQQs5+ai4HXnIKMFl3QaZA8e7cNmZt3Bge8mrboObCvut7FmLNwc/XPNxESB3d+oqC5i9whdhxGRwghhMTAJGs4AJSGNr90uLT2QzjnydC7+W6qsJJQ/oaPQnNmnBo6Iz0llDLur6F/ZZWYOouYWexyQ4vv7x/qeff3oa125reqBaE3rmyljvfT0IVzC4wxTMXX54T6yv7G/Dx0QuczQ+f8d2loY4W7g5LQ1pmjQ11Ufcqlr4YW2fst/yT0woVtQmh9TuiiH/JC4aqdodVPDgm1RlpwJrV47P4w9FiXLqFzvpbz3B0q+vq80Cg5N4wIjX472zqGsCn03R3dw8fYfm9oUpr4Hhf62ec7tYefH0KvXtBM1R9v9m9R8XLon31l23NCV/zu5NCPn54fWq/eg4od80I/7Ai/yd57ddYtoRt/fFXoj/NzQuWh4tCOb1aGNronV/Rq6L7jm4Qw8Pehv22M/PzU+/nWuNBAtA41v+oN//tZw3OIyda/ha5urbaPm93QfQ96h/o+siC0zf2cK7aGshbOCD3/+3R1fT1Ch9z8fmhRuf/ddtgVWvFI31Czu75Td7Gi6MXQP49upPYXlHHQ+fzS0u4KvVwkFeHshE1v+yqU7zgF4r7PjX77bmidsSU6kh0tIyMjNGPGDGMh+xN5n8eOHavvN3lJNropU6aEMjMzjQchhBBCqqNuepC+uxPXdW3qDNtKaYG2PS/Eac+no/lNH+GLWTfjum7NjWNNSEWfcU9h1m8PD08MKqT0R8bYPkosx9zVcdIdZHfAwPdm4KXxh6F7Y3cHzdHx8DEYo1To80ws8zqEKlHwxT8w9bkCNL78cvx1RDurlysV6aPHYLQ8P/Tch3i7Ns+R5C3E4q1nYFAPue5GaHnUJPz2HOkNmYevHvufb+LYUNZj+Netp+O3Fwx3eldSu6O7flgrG6uzazp/UiTv4PmUP+CpSzLQU70HjdsPx+HtI3tRFK99hG//eBvuzDgYTdAC7Y/qj+76DSjB5jf/jqmftEb7q3+J33SP/Pya45ATr8FlQ4tQ+tizeHhF0FS/NTyHCKpyNyJTElUc2weDqnXfjo03H4k+TRo5916TTug++l+4Ke8KnP3ex1h8+0kYYs+f5LEZmfN36h4+3UfV8nSc++shkJGQlU/+G/+0J44NzcU7932I7o+ej7Nayr46oEN355mm6hJpuHN9Va3fhs21uH3qMzJ8S+bSkWFeZP8gPUL23EUyjM6du8geYkcIIYSQmlE3AdKYf2BWXj42LV6MxYvXYWNxFnZ98CBevnIcRrWp7SSwjdBiyHEY7mvYlqIg+wdkrjcp3uIx6hRcO8wOdBxSGjdzGsM+1uO7t+aokKs3eh3WAUVLl2DJkvBrS7GESYrFKrDZUF2a7jC7N8zF+417ol97c+0pI3HyFWOdYVyznsV937jDuDbjh38/iTduuwyTupuU6Y37Iv0YOdM1WJO5FTU/qs1YnPWLo9HLlGIy+nxcP7ZjwNDH1Zj74RIVGvbBsEHd4Q6689FsGIaNkZq5+GRRjmPzUcNziKBqV4668prSCf0eWYW8XWvUfafuvdXbsSv/e6x//Gb8/eR+6BgUGwm7V2DZ893Qr0tbY2iFnqddhesOVRsUvoFnXllonpWqQvG3d+PK9/6AW37aw/xytUW3Pj20whdrsbQmY+cWb0VWkiTckIa5NNaZ8nvfI++nDJWTpAsyjG7Xrl16GN28efO8OkIIIYTUnrp7BqlxG3QdPBiDB/dC9xb74DQqN2DVR3/Hg/83Gucck4bU0/+Bhz/cbir3EVXrsG6+zJGzDmuuORJDhgzxvbqNfAiviF9ruZ6adgGUYNPSBVg+oR8GeXP1NEX74y7D5UfLfj7BW09+jEVqd9J79NCU43HpWcOsZ3M6oGOvllqVr92yh6m+u6Nvpxr02vXrhr5NA6KI3Wux5nvpFWqDjqmx9uP2pMQK5Gp4DntNChq37aPuO3Xv9e2AtrGCIovQpq/xdcFIDOrpvM+a9hNw9qVdlChE0bRncb/MXyS9R/e/i9RpZ2KC7j0SmqDtIZ2gQ6StG7AmZqrv5EUy2UliALL3RM5dJNno5L2dMmUK8vLyOHcRIYQQsg+ouwBpn1GBgqW34ZYzBmLAH1fhk4F/xrmPr8PO71/CnRd1Mz77iKpc5K6TLoDjcc7XBfL8VvCr4EU8ODAgVXQg27BuaRaa9O+KXnZjveVp+PnVA/QwrqqnH8dt367HD/9+Ai9OvhST+tl9W63Rtr1zrNCSLKyti/Z3qBwVBXUzJqxRakcni99+w0nQ8HqTHujXwR7D1xWHuxkH817E/c/PxY5v78bUmdfh96f3RdizEZqndsDBIgs3YHWcVN8efdujYxL8ZrpI+mgZBsaMdnuOOz+RBEZBcxe5Q+wIIYQQsvckfDMstOmfuHH8FNxR+Vc88+4jeOXK03DO0E5om1KI3K1BE37uBSmt0bqzvGV5yNq+j6bzrFqNlV+WoGvfLhEZ29qgz2kX40JtfBev/eVa/OmWYQHD0FqjUw+TEH3JaizdWQcR0kE90X2EpL5eh/mrt8foO8tH/nYJDgZi8IAuAcMX94xGHfvhMHmPajp8rdYUYtOKlag4rR8Geb1CDo36XorLfiHDBvOQd9cf8Yub3sCmO8/BJR38w0QP6tQXQ7Vah6UbYqfwrty4FF+odUr6IeiWRAES2XPsuYumT5+ubTKMjnMXEUIIIfuPBG+G5WPVW0/h4dXd0fOCM3FBB/Nczv7ioKHIOLGDEmuw8OsVyN4XnSZ5C7Hos8OQ3rVd9IfR6UJc/NuOWla9/w4+vPgK/GG4dFnYWEO48jZgdU5Aqu/9TcogHHVaXxWqrcOaD+dicdD7Uvw95s4pVPHcERg7WPen7BvShmHY4Y2B3C3I2rU/gsPNyFy0FY0P7YbekcPxUobghEtOctKs532CD+Zfit+cPTj6GazUHuilP6BtWLc5L0YK7woVQG5BrgqT2w9NRzI+Us/nYmqGDKNz5ycKmrvIHWJHCCGEkP1DggdIFSgulMk3K1FWVGo91xJC5db38OUP8m19MfJ2Fu2jeWW6YvgZp+Kk1oUouu/vmDhzJXJ8wUAlSrfOwvM/vQ0P76hZY10SNHxe1Q+DekYGPkI3HHHWeJyk9XE46ZKxGBr1zIw1hAtrsXRDDRJT7HPaoM/463TSgqpX/43bv82N6EXKx4Y3p+Oxb1KROukKXN93X/UfKRoNxrAT1NXnrcaSzXuWoiIuu1dg+cdl6Ni/K5xQ1UYyDl6J68bJgLrWaPGr83GNmzzDpvnB6NBBPrhs5KzajKAUFdJTlb12A/JwBH58RA8V9iYf0rCXZ2ZkTaJx5y6S4Gfy5Ml6GN348eM5dxEhhBBygDmAAVI+Nq3d6Mg9GA5VtSNLNf8Vvp6CNBx63I8wSjU8t/zxBpxw7+t4/sMnMPOeH+PEAW9hY6dDVLNV1b3wAm77eDaeX+Q23CtRnJ+rQifFlp3ICZi90ztecS5yilyHRmgx8m7c/+AoHIl38N5Zx6PfyVfhlBv+D9dc83P84dL+GN31ITx50dk4y81IFxcnQcO8tJ7o1zGoSZyCJkMuw2WS8vukCzH5WJ3PO4rwEK7NWLF+uz8Y3L0VOeukV2kL1myJmNS0KAc5+k1YjzUxn42x3qtFWVgTK+5rfxX+9MpvcGnnN/DyRb/BhP98hS/XrceG9XPwzTM/x6W/+BobL7wXL954HHraQV6NziEeh2DQmGMwBHPx4Q+bgydirVyDzK9l37XP9CcJGr5aNgi9u6ZZzxVZNBmL0y4bpO6zk/HL80bCDHb0c1APdB8sQxDVqSxYhxVBJxlajLkfbAaGjMPPhrYxxuRCnqERpHeEhJGAUYbRjRgxQgeQgiRdkGF07hA7QgghhBw4DmCAVIHKMtMy3F2OssrajU+rKs5XoY4irxC7ytxt5Rv8+/Ds29fhd6euQNnvzsblf/kED5Rch8krnsE//vYIHp08BMd8+RgeeeYLLFXbOVvuRlFenrO/NSoACgqQ3ONl52KbFyAJHTHw4o/w/jcP4bEbeuPkgmfx3rTH8PTClvi+3124af3r+Oj8w/xzMsXESdCA3j3Rt12MgCplJE66ZByGX3EKTgqco0fRLBVp+lmlgB6KUCEKt8j5V6C0POJCi7Zhi77IUpSVx/o8rPcqX31uMT+2Jmgz7D48/vXbeP2irWj3+Cn4SXpv9BpyPc7+3zB0f3E+Vsy4BKdEpnGv0TnEQ90DR16CK0dtwob3vse8oF1UlqHMBHah8kqUO7IGOAkavkQX9O0a1MMntELPUy/F+OHnYdKQwATnipZo3c4EwItWY2lB9A0X2vA//O+t5mh/+alWBrzkQrKrSWIB6Q2RV0PGTazgJl2QYXQZGRmcu4gQQgipB6SEJO0aIQlNCTa/NAYDfzEM12U+jL/1cnprEocibHhuNHr/6lj8Zel03Bo0TC9JkMBAhok11KFi8hyWO9TQRZIuyPA59hQRQggh9QMGSCQ5KHkTD511Lv489jOsufHIiIyA9Zzil/CPYy/BtIu+wNIbRibWuZMaIUGRDC1csGCBLkvSBQmKZNghnysihBBC6hcMkEiSUIXShdfi7JHA0FXT8bfeB2LS2X1BPtY/Nw79nroQz//3tzi3bU2eXUt8ZBiZJCVI5l4T6S2ToEiCo127nOf/ZIihBEbyIoQQQkj9hAESSSLysOa5n+DIj2/EB4/+HCNjPbNVbwihIusuXJ+xCs3mTMe9h8V6zin5SElJQWpqqg6Ukg0ZRieB0axZs3RZrlPmK+JzRYQQQkhikOBpvgmxSUPfC2bis5HTcc0TC7Ctnof+oYK38NSlzyDz1TtwdwMKjgR57kZ6VZIl5bc9d9G4ceN0cCTD6KZNm6Z7kuQ6GRwRQgghiQF7kEjyEcrGks9C6Du2K+r1QLuKFfh0ZWeMGZyK5MxbFxsZXidprWXImfS4JCpuNjpJx+0Oo5O5i2QInfQaEUIIISTxYIBECKkTpMdFgohE7FmRHiF5SXpuQYbRuUkX2FNECCGEJDYMkAghpAa4w+gkMFq/fr22ydxFEhRJoMdsdIQQQkhywACJEELiIMMBJTDi3EWEEEJIw4BJGgghdYYEHzIkTZ7jqW9IT9Hw4cP1s1ISHEnShSlTpiAzM1PXMTgihBBCkhP2IBFC6gxJcpCenq6DD9F1jZtxTnqMOHcRIYQQ0jBhDxIhpM6Q3iMZribP9EhgUldIJj15jkiCtalTp+rgSM5r3rx5uo7BESGEENJwYIBECKlTJPiQXpoDnf1Nki5IUCbHjZy7KC8vzxtiRwghhJCGBYfYEUIaFDKMzs1GZw+jc7PREUIIIaRhwwCJENIgkMlcJTDi3EWEEEIIiQeH2BFC6gXuc0Ay9K0mlJSUID8/35SCcecukgBowoQJOjiSYXQzZszwepIYHBFCCCHEhgESIaReIAGSPAdUk2QNxcXF2L17N5o2bWosfiR9uPQOpaWlYfLkyToJxPjx4zF79mwdGEkdJ3YlhBBCSBAcYkcIqRdI4FKblN+SWOGBBx5Anz590LJlS22T4Epe9jA6GUInARF7igghhBBSE9iDRAipF0gAI708MixOeoBiIUPrJk6cqHuc7rnnHqxcuVJPNCs9QmKX4CgjI0MPo5N9SR2DI0IIIYTUFPYgEULqDdJzFC+YKS0txU033aSfHQpC5i6SHiOm5yaEEELInsIAiRCSEOTm5uLNN9/Uw+VspOfo8ssvx5///Gc+V0QIIYSQvYYBEiGk3iE9STKEzg2GZL4iSdMdGRwJ0uOUmZlpSoQQQgghewcDJEJIvcPtCZJAqaqqCps3b8aPfvSjmCnAJXiSyV7Zg0QIIYSQvYVJGggh9Q7pKXJ7jVq3bo0hQ4YgLy8P8n2OvAoLC3UiB3nNmTNHP3PUqBH/nBFCCCFk72EPEiGk3lHblN+EEEIIIfsKBkiEkHqJ9B5JzxBTdBNCCCHkQMIAiRBCCCGEEEIMHLRPCKn3xErOQAghhBCyr2GARAipt0gSBslMd+uttxoLIYQQQsj+hUPsCCH1Fuk5cp9BkmQNTONNCCGEkP0Ne5AIIfUWCYjOPPNML+U3IYQQQsj+hj1IhJB6jfQc3Xfffbj++uuZ0Y4QQggh+x0GSIQQQgghhBBi4BA7QgghhBBCCDEwQCKEEEIIIYQQAwMkQgghhBBCCDEwQCKEEEIIIYQQAwMkQgghhBBCCDEwQCKEEEIIIYQQAwMkQgghhBBCCDEwQCKEEEIIIYQQAwMkQgghhBBCCNEA/w97jd0pM+idYAAAAABJRU5ErkJggg==", "type": "binary"}]