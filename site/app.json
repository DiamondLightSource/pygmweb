[{"name": "app.py", "content": "from faicons import icon_svg\nfrom pathlib import Path\nfrom shiny import App, reactive, render, ui\napp_dir = Path(__file__).parent\nfrom pyplanemono_minimal.elements import *\nfrom pyplanemono_minimal.geometry import calc_beam_size\nimport plotly.graph_objects as go\nfrom shinywidgets import output_widget, render_plotly\nfrom configparser import ConfigParser\nfrom shiny.types import FileInfo\nimport asyncio\nimport io\n\nH = 6.62607015e-34\nE = 1.602176634e-19\nC = 299792458\n\nto_wavelength = lambda x: H*C/(E*x)\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.layout_column_wrap(\n        ui.card(\n            \"Energy (eV)\",\n            ui.input_numeric(\"energy\", \"\", 500, min=0, step=10),\n            fill=False\n        ),\n        ui.card(\n            \"Order\",\n            ui.input_slider(\"order\", \"\", 0, 10, value=1),\n            fill=False\n        ),\n        ui.card(\n            r'\\(\\mathit{c_{ff}}\\)',\n            ui.input_numeric(\"c_ff\", \"\", 1.4, min=1, max=15, step=0.1),\n            fill=False\n        ),\n        ui.card(\n            \"Line Density (l/mm)\",\n            ui.input_numeric(\"line_density\", \"\", 400, min=0, max=3600),\n            fill=False\n        ),\n        fill=False,\n    ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Beam Configurations\",\n                ui.tooltip(ui.input_checkbox(\"calc_beam_height\", \"Calculate ID Beam Height\", value=False),\n                           'This calculates the vertical beam size at the grating and mirror from an undulator source for the given PGM energy.'),\n                ui.output_ui('beam_height_calc_ui'),\n                ui.input_numeric(\"beam_width\",\"Beam Width (mm)\",5,step=0.1,min=0, max=100),\n            ),\n            open=True\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Mirror Configurations\",\n                ui.input_numeric('mirror_height', \"Mirror Height (mm)\", 40,min=0),\n                ui.input_numeric(\"mirror_length\", \"Mirror Length (mm)\", 450, min=0),\n                ui.input_numeric('mirror_width', \"Mirror Width (mm)\", 40, min=0),\n            ),\n            open=False\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Grating Configurations\",\n                ui.input_numeric('grating_height', \"Grating Height (mm)\", 40, min=0),\n                ui.input_numeric('grating_length', \"Grating Length (mm)\", 150, min=0),\n                ui.input_numeric('grating_width', \"Grating Width (mm)\", 45, min=0),\n            ),\n            open=False\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Offsets Configurations\" ,\n                ui.input_numeric('beam_vertical_offset', \"Beam Vertical Offset \\(b\\) (mm) \" , -13, min=-100, max=100),\n                ui.input_numeric('mirror_horizontal_offset', \"Mirror Horizontal Offset \\(a\\) (mm)\", 0, min=-100, max=100),\n                ui.input_checkbox(\"calculate_offsets\", \"Calculate Offsets Automatically\", value=False),\n                ui.output_ui('offset_calc_ui'),\n            ), open=True),\n        ui.accordion(\n            ui.accordion_panel(\"Export and Import\",\n                ui.input_text(\"export_filename\", \"Export Filename\", \"pgm_configurations.pgm\"),\n                ui.download_button(\"export_pgm\",\"Export Current PGM\"),\n                ui.input_file(\"import_pgm\",\"Upload Configuration File\", accept=\".pgm\", multiple=False),\n                ui.input_action_button(\"import_button\", \"Import\")),\n                \n                open=False),\n\n        title=\"PGM Configurations\"),\n\n        \n\n\n    ui.card(ui.card_header(\"Footprint View\", \"  \", ui.tooltip(icon_svg('circle-info'),\"Beam footprint size\", id='beamfootprint_tooltip')),output_widget(\"top_view\"),full_screen=True),\n    ui.card(ui.card_header(\"Side View\", \" \", ui.tooltip(icon_svg('circle-info'),ui.output_ui('side_view_angles'), id='angle_tooltip')),output_widget(\"side_view\"),full_screen=True, fill=True),\n\n    ui.include_css(app_dir / \"styles.css\"),\n    ui.tags.head(ui.tags.script(src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"),\n    ui.tags.script(id=\"MathJax-script\", src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\")),\n    title=\"PGMweb\",\n    fillable=True\n)\n\n\ndef server(input, output, session):\n\n    @render.text\n    def beam_size_mirror():\n        \n        beamsize = calc_beam_size(float(input.electron_size()), \n                                  float(input.electron_divergence()), \n                                  to_wavelength(float(input.energy()))/1E-9, \n                                  float(input.distance_to_mirror()), \n                                  float(input.length_of_id()), \n                                  num_of_sigmas = float(input.num_of_sigmas()))\n        return rf\"Beam Height : {beamsize:.3f} mm\"\n\n    @render.ui\n    @reactive.event(input.calc_beam_height)\n    def beam_height_calc_ui():\n        if input.calc_beam_height():\n            return ui.TagList(\n                ui.input_numeric('electron_size', \" Vertical Electron Beam Size RMS (um)\", 50, min=0),\n                ui.input_numeric('electron_divergence', \"Electron Beam Vertical Divergence RMS (urad)\", 20, min=0),\n                ui.input_numeric('distance_to_mirror', \"Distance to Image Plane (m)\", 15, min=0),\n                ui.input_numeric('length_of_id', \"Length of ID (m)\", 2, min=0),\n                ui.input_numeric('num_of_sigmas', \"Number of Sigmas\", 5, min=0),\n                ui.output_text(\"beam_size_mirror\"),)\n        else:\n            return ui.input_numeric(\"beam_height\", \"Beam Height (mm)\", 5,step=0.1,min=0, max=100)\n\n    @render.ui\n    def voffset_out():\n        return ui.TagList(\n            ui.tags.div(f\"Mirror Vertical Offset \\(c\\) : {-1*float(input.beam_vertical_offset())} mm\"),\n            ui.tags.script(\"MathJax.typesetPromise();\"))    \n    @render.ui\n    def axis_hoffset_out():\n        return ui.TagList(\n            ui.tags.div(f\"Mirror Axis Horizontal Offset \\(h\\) : 0 mm\"),\n            ui.tags.script(\"MathJax.typesetPromise();\"))\n    \n    \n    @render.ui\n    def axis_voffset_out():\n        return ui.TagList(\n            ui.tags.div(f\"Mirror Axis Vertical Offset \\(v\\) : {-1*float(input.beam_vertical_offset())/2} mm\"),\n            ui.tags.script(\"MathJax.typesetPromise();\"))\n    \n\n    \n    @render.ui\n    @reactive.event(input.calculate_offsets)\n    def offset_calc_ui():\n        if input.calculate_offsets():\n            return ui.TagList(\n                ui.output_ui(\"voffset_out\"),\n                ui.output_ui('axis_hoffset_out'),\n                ui.output_ui('axis_voffset_out'), \n                )\n        else:\n            return ui.TagList(\n                ui.input_numeric(r'mirror_vertical_offset', \"Mirror Vertical Offset \\(c\\) (mm)\", 13, min=-100, max=100),\n                ui.input_numeric(r'mirror_axis_horizontal_offset', \"Mirror Axis Horizontal Offset \\(h\\) (mm)\", 0, min=-100, max=100),\n                ui.input_numeric(r'mirror_axis_vertical_offset', \"Mirror Axis Vertical Offset \\(v\\) (mm)\", 6.5, min=-100, max=100),\n                ui.tags.script(\"MathJax.typesetPromise();\")\n            )\n    @render_plotly\n    def top_view():\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        if input.calc_beam_height():\n            beamsize = calc_beam_size(float(input.electron_size()), \n                                  float(input.electron_divergence()), \n                                  to_wavelength(float(input.energy()))/1E-9, \n                                  float(input.distance_to_mirror()), \n                                  float(input.length_of_id()), \n                                  num_of_sigmas = float(input.num_of_sigmas()))\n            pgm.beam_height = beamsize\n        else:\n            pgm.beam_height = input.beam_height()\n        \n        if input.calculate_offsets():\n            b = float(input.beam_vertical_offset())\n            pgm.beam_offset = b\n            pgm.mirror.hoffset = float(input.mirror_horizontal_offset())\n            pgm.mirror.axis_voffset = -1*b/2\n            pgm.mirror.voffset = -1*b\n            pgm.mirror.axis_hoffset = 0.\n        else:\n            pgm.beam_offset = float(input.beam_vertical_offset())\n            pgm.mirror.hoffset = float(input.mirror_horizontal_offset())\n            pgm.mirror.axis_voffset = float(input.mirror_axis_vertical_offset())\n            pgm.mirror.voffset = float(input.mirror_vertical_offset())\n            pgm.mirror.axis_hoffset = float(input.mirror_axis_horizontal_offset())\n        \n        pgm.beam_width = input.beam_width()\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        pgm.mirror.dimensions = [float(input.mirror_length()),float(input.mirror_width()),float(input.mirror_height())]\n        pgm.grating.dimensions=[float(input.grating_length()),float(input.grating_width()),float(input.grating_height())]\n        pgm.grating.compute_angles()\n        pgm.set_theta()\n        m_corners = pgm.mirror_corners()\n        m_corners = np.array(m_corners)\n        grating_corners = np.array(pgm.grating_corners())\n        mirror_corners = np.array(pgm.mirror_corners())\n        pgm.generate_rays()\n        _, mirror_int_1, grating_int_1 =  pgm.propagate(pgm.rays[1])\n        _, mirror_int_2, grating_int_2 =  pgm.propagate(pgm.rays[2])\n        _, mirror_int_3, grating_int_3 =  pgm.propagate(pgm.rays[3])\n        _, mirror_int_4, grating_int_4 =  pgm.propagate(pgm.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = pgm.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = pgm.calc_footprint_size(grating_intercepts)\n        ui.update_tooltip(\"beamfootprint_tooltip\", f\"Mirror Footprint Size: {mirror_footprint_width:.3f} mm x {mirror_footprint_height:.3f} mm \\n Grating Footprint Size: {grating_footprint_width:.3f} mm x {grating_footprint_height:.3f} mm\")\n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(pgm.mirror._width() + pgm.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        fig = go.Figure(layout={'showlegend':True, \n                                'xaxis':{'range':(min(mirror_corners[:,0])-50,max(grating_corners[:,0])+50)},\n                                'yaxis':{'range':(min(mirror_corners[:,1])-50,max(grating_corners[:,1])+50)}, \n                                'height':400})\n        fig.add_trace(go.Scatter(x=mirror_corners[:,0], y=mirror_corners[:,1],fill='toself',fillcolor='red',line={\"color\":'red'}, marker={'size':0}, name='Mirror', hovertemplate='%{x:.2f} mm, %{y:.2f} mm'))\n        fig.add_trace(go.Scatter(x=grating_corners[:,0], y=grating_corners[:,1],fill='toself',fillcolor='blue',line={\"color\":'blue'}, marker={'size':0}, name='Grating', hovertemplate='%{x:.2f} mm, %{y:.2f} mm'))\n        fig.add_trace(go.Scatter(x=mirr_footprint_corners[:,0], y=mirr_footprint_corners[:,1],fill='toself',fillcolor='green',line={\"color\":'green'}, marker={'size':0}, name='Beam', hovertemplate='%{x:.2f} mm, %{y:.2f} mm'))\n        fig.add_trace(go.Scatter(x=grating_footprint_corners[:,0], y=grating_footprint_corners[:,1],fill='toself',fillcolor='green',line={\"color\":'green'}, marker={'size':0}, showlegend=False,name='Beam', hovertemplate='%{x:.2f} mm, %{y:.2f} mm'))\n        fig.update_layout(xaxis_title=\"Z (mm)\", yaxis_title=\"X (mm)\")\n        return fig\n\n    @render_plotly\n    def side_view():\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        if input.calc_beam_height():\n            beamsize = calc_beam_size(float(input.electron_size()), \n                                  float(input.electron_divergence()), \n                                  to_wavelength(float(input.energy()))/1E-9, \n                                  float(input.distance_to_mirror()), \n                                  float(input.length_of_id()), \n                                  num_of_sigmas = float(input.num_of_sigmas()))\n            pgm.beam_height = beamsize\n        else:\n            pgm.beam_height = input.beam_height()\n\n        if input.calculate_offsets():\n            b = float(input.beam_vertical_offset())\n            pgm.beam_offset = b\n            pgm.mirror.hoffset = float(input.mirror_horizontal_offset())\n            pgm.mirror.axis_voffset = -1*b/2\n            pgm.mirror.voffset = -1*b\n            pgm.mirror.axis_hoffset = 0.\n        else:\n            pgm.beam_offset = float(input.beam_vertical_offset())\n            pgm.mirror.hoffset = float(input.mirror_horizontal_offset())\n            pgm.mirror.axis_voffset = float(input.mirror_axis_vertical_offset())\n            pgm.mirror.voffset = float(input.mirror_vertical_offset())\n            pgm.mirror.axis_hoffset = float(input.mirror_axis_horizontal_offset())\n        pgm.beam_width = input.beam_width()\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        pgm.mirror.dimensions = [float(input.mirror_length()),float(input.mirror_width()),float(input.mirror_height())]\n        pgm.grating.dimensions=[float(input.grating_length()),float(input.grating_width()),float(input.grating_height())]\n        _ = pgm.mirror.compute_corners()\n        _ = pgm.grating.compute_corners()\n        pgm.generate_rays()\n        pgm.grating.compute_angles()\n        pgm.set_theta()\n        mirror_corners = pgm.mirror.compute_corners()\n        grating_corners = pgm.grating.compute_corners()\n        rays = pgm.generate_rays()\n        _ = pgm.propagate(pgm.rays)\n        mirror_z = np.array(\n            [mirror_corners[i][2] for i in [4,6,2,0,4]]\n        )\n        mirror_x = np.array(\n            [mirror_corners[i][1] for i in [4,6,2,0,4]]\n        )\n\n        grating_z = np.array(\n            [grating_corners[i][2] for i in [4,6,2,0,4]]\n        )\n        grating_x = np.array(\n            [grating_corners[i][1] for i in [4,6,2,0,4]]\n        )\n        ray1z = [pgm.rays[0].position.list[2],\n                pgm.mirror_intercept[0].z,\n                pgm.grating_intercept[0].z,\n                1000]\n\n        ray1x = [pgm.rays[0].position.list[1],\n                pgm.mirror_intercept[0].y,\n                pgm.grating_intercept[0].y,\n                0]\n        ray2z = [pgm.rays[1].position.list[2],\n                pgm.mirror_intercept[1].z,\n                pgm.grating_intercept[1].z,\n                1000]\n\n        ray2x = [pgm.rays[1].position.list[1],\n                pgm.mirror_intercept[1].y,\n                pgm.grating_intercept[1].y,\n                pgm.grating_intercept[1].y + 1000*pgm.rays[1].vector[1]]\n\n        ray3z = [pgm.rays[2].position.list[2],\n                pgm.mirror_intercept[2].z,\n                pgm.grating_intercept[2].z,\n                1000]\n\n        ray3x = [pgm.rays[2].position.list[1],\n                pgm.mirror_intercept[2].y,\n                pgm.grating_intercept[2].y,\n                pgm.grating_intercept[2].y + 1000*pgm.rays[2].vector[1]]\n        \n\n        fig = go.Figure(layout={'showlegend':False, 'xaxis':{'range':(min(ray3z[1:])-50,max(ray2z[1:-1])+50),}, 'height':1000})\n        fig.add_trace(go.Scatter(x=mirror_z, y=mirror_x,fill='toself',fillcolor='red',line={\"color\":'red'}, marker={'size':0}, name='Mirror', hovertemplate='%{x:.2f} mm, %{y:.2f} mm'))\n        fig.add_trace(go.Scatter(x=grating_z, y=grating_x,fill='toself',fillcolor='blue',line={\"color\":'blue'}, marker={'size':0}, name='Grating', hovertemplate='%{x:.2f} mm, %{y:.2f} mm')) #mode lines if to hide vertices\n        fig.update_yaxes(scaleanchor=\"x\",scaleratio=1,)\n\n        fig.add_trace(go.Scatter(x=ray1z, y = ray1x, line={'color':'green', 'width':1.5}, hovertemplate='%{x:.2f} mm, %{y:.2f} mm', name='Centre Ray'))\n        fig.add_trace(go.Scatter(x=ray2z, y = ray2x, line={'color':'green', 'width':1.5}, hovertemplate='%{x:.2f} mm, %{y:.2f} mm', name='Upper Ray'))\n        fig.add_trace(go.Scatter(x=ray3z, y = ray3x, line={'color':'green', 'width':1.5}, hovertemplate='%{x:.2f} mm, %{y:.2f} mm', name='Lower Ray'))\n        fig.update_layout(xaxis_title=\"Z (mm)\", yaxis_title=\"X (mm)\")\n        \n        return fig\n    @render.ui\n    @reactive.event(input.angle_tooltip)\n    def side_view_angles():\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        alpha, beta = pgm.grating.compute_angles()\n        pgm.set_theta()\n        theta = pgm.theta\n        return ui.TagList(\n            ui.tags.div(\n                rf\"\\(\\alpha = {alpha:.2f}^\\circ\\), \\(\\beta = {beta:.2f}^\\circ\\), \\(\\theta = {theta:.2f}^\\circ\\)\"\n            ),\n            ui.tags.script(\"MathJax.typesetPromise();\"))\n    \n    \n    @reactive.effect\n    @reactive.event(input.import_button)\n   \n    def import_pgm():\n        file: list[FileInfo] | None = input.import_pgm()\n        if file is None:\n            return None\n        parser = ConfigParser()\n        parser.read( # pyright: ignore[reportUnknownMemberType]\n            file[0][\"datapath\"])\n        pgm_keys = [\n            'offsets',\n            'mirror',\n            'grating',\n            'core',\n            'beam']\n        if not all([key in parser.sections() for key in pgm_keys]):\n            error_message = ui.modal(\"The file doesn't meet the specifications.\", \n                                     title=\"Invalid PGM file\",\n                                     easy_close=True)\n            ui.modal_show(error_message)\n            return None\n        # Loads core parameters\n        try:\n            ui.update_numeric('energy', value=parser.getfloat('core', 'energy'))\n            ui.update_numeric('order', value=parser.getint('core', 'order'))\n            ui.update_numeric('c_ff', value=parser.getfloat('core', 'cff'))\n            ui.update_numeric('line_density', value=parser.getfloat('grating', 'line_density'))\n            # Loads beam parameters\n            ui.update_checkbox('calc_beam_height', value=parser.getboolean('beam', 'calculate_from_id'))\n            if parser.getboolean('beam', 'calculate_from_id') and 'beam_height' not in parser['beam']:\n                ui.update_checkbox('calc_beam_height', value = True)\n                ui.update_numeric('electron_size', value=parser.getfloat('beam', 'vert_electron_size'))\n                ui.update_numeric('electron_divergence', value=parser.getfloat('beam', 'vert_electron_divergence'))\n                ui.update_numeric('distance_to_mirror', value = parser.getfloat('beam', 'distance'))\n                ui.update_numeric('length_of_id', value=parser.getfloat('beam', 'id_length'))\n                ui.update_numeric('num_of_sigmas', value=parser.getfloat('beam', 'num_of_sigmas'))\n            else:\n                ui.update_checkbox('calc_beam_height', value=False)\n                ui.update_numeric('beam_height', value=parser.getfloat('beam', 'beam_height'))\n            ui.update_numeric('beam_width', value=parser.getfloat('beam', 'beam_width'))\n\n            # Loads Mirror Parameters\n            ui.update_numeric('mirror_height', value=parser.getfloat('mirror', 'height'))\n            ui.update_numeric('mirror_length', value=parser.getfloat('mirror', 'length'))\n            ui.update_numeric('mirror_width', value=parser.getfloat('mirror', 'width'))\n            # Loads Grating Parameters\n            ui.update_numeric('grating_height', value=parser.getfloat('grating', 'height'))\n            ui.update_numeric('grating_length', value=parser.getfloat('grating', 'length'))\n            ui.update_numeric('grating_width', value=parser.getfloat('grating', 'width'))\n            # Loads offsets\n            ui.update_checkbox('calculate_offsets', value=parser.getboolean('offsets', 'calculate_offsets'))\n            if parser.getboolean('offsets', 'calculate_offsets'):\n                ui.update_numeric('beam_vertical_offset', value=parser.getfloat('offsets', 'beam_vertical_offset'))\n            else:\n                ui.update_checkbox('calculate_offsets', value=False)\n                print('in else here')\n                ui.update_numeric('beam_vertical_offset', value=parser.getfloat('offsets', 'beam_vertical_offset'))\n                ui.update_numeric('mirror_vertical_offset', value=parser.getfloat('offsets', 'mirror_vertical_offset'))\n                ui.update_numeric('mirror_axis_horizontal_offset', value=parser.getfloat('offsets', 'mirror_axis_horizontal_offset'))\n                ui.update_numeric('mirror_axis_vertical_offset', value=parser.getfloat('offsets', 'mirror_axis_vertical_offset'))\n            success_message = ui.modal(\"The PGM configuration has been successfully imported.\",\n                                        title=\"Import Successful\",\n                                        easy_close=True)\n            ui.modal_show(success_message)\n        except Exception as e:\n            error_message = ui.modal(str(e), title=\"Error\", easy_close=True)\n            ui.modal_show(error_message)\n            return None\n            \n    @render.download(filename=input.export_filename)\n\n    def export_pgm():\n        parser = ConfigParser()\n        parser['core'] = {\n            'energy': str(input.energy()),\n            'order': str(input.order()),\n            'cff': str(input.c_ff())\n        }\n\n        if input.calc_beam_height():\n            parser['beam'] = {\n                'calculate_from_id': str(input.calc_beam_height()),\n                'vert_electron_size': str(input.electron_size()),\n                'vert_electron_divergence': str(input.electron_divergence()),\n                'distance': str(input.distance_to_mirror()),\n                'id_length': str(input.length_of_id()),\n                'num_of_sigmas': str(input.num_of_sigmas()),\n                'beam_width': str(input.beam_width())\n            }\n        else:\n            parser['beam'] = {\n                'calculate_from_id': str(input.calc_beam_height()),\n                'beam_height': str(input.beam_height()),\n                'beam_width': str(input.beam_width())\n            }\n        parser['mirror'] = {\n            'height': str(input.mirror_height()),\n            'length': str(input.mirror_length()),\n            'width': str(input.mirror_width())\n        }\n        parser['grating'] = {\n            'height': str(input.grating_height()),\n            'length': str(input.grating_length()),\n            'width': str(input.grating_width()),\n            'line_density': str(input.line_density())\n        }\n\n        if input.calculate_offsets():\n            parser['offsets'] = {\n                'calculate_offsets': str(input.calculate_offsets()),\n                'beam_vertical_offset': str(input.beam_vertical_offset())\n            }\n        else:\n            parser['offsets'] = {\n                'calculate_offsets': str(input.calculate_offsets()),\n                'beam_vertical_offset': str(input.beam_vertical_offset()),\n                'mirror_vertical_offset': str(input.mirror_vertical_offset()),\n                'mirror_horizontal_offset': str(input.mirror_horizontal_offset()),\n                'mirror_axis_horizontal_offset': str(input.mirror_axis_horizontal_offset()),\n                'mirror_axis_vertical_offset': str(input.mirror_axis_vertical_offset())\n            }\n        with io.StringIO() as buffer:\n            buffer.write(\"# PGM Configuration File\\n\\n\")\n            buffer.write(\"#pgmweb.diamond.ac.uk\\n\\n\")\n            buffer.write('# See pgmweb.diamond.ac.uk/tutorial.html for parameters\\n\\n')\n            buffer.write('# Please consider citing:\\n# Wang, Y.P., Walters, A.C., Bazan da Silva, M., et al., PGMweb: An Online Simulation Tool for Plane Grating Monochromators, In preparation.\\n\\n')\n\n            parser.write(buffer)\n            buffer.seek(0)\n            \n            yield buffer.read()\n        \n\n\n\napp = App(app_ui, server, static_assets=app_dir)\n", "type": "text"}, {"name": "Untitled.ipynb", "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 1,\n   \"id\": \"408be1f8-f6ee-4b9f-8134-b669ef507008\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"No arguments given, plane at origin with normal (0, 0, 1) initialised! Tread carefully!\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"import plotly.express as px\\n\",\n    \"import plotly.graph_objects as go\\n\",\n    \"from pyplanemono_minimal.elements import *\\n\",\n    \"#import matplotlib.pyplot as plt\\n\",\n    \"\\n\",\n    \"#%matplotlib widget\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 15,\n   \"id\": \"5d561b7f-d45d-430e-83ca-e93c565e9be3\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"2400 1 600 2 5.166008268050012e-10\\n\",\n      \"1200 1 600 1.4 1.0332016536100023e-09\\n\"\n     ]\n    }\n   ],\n   \"source\": [\n    \"pgm = PGM(mirror=Plane_Mirror(), grating = Grating())\\n\",\n    \"pgm.energy = 1200\\n\",\n    \"pgm.cff=1.4\\n\",\n    \"pgm.grating.compute_angles()\\n\",\n    \"pgm.set_theta()\\n\",\n    \"mirror_corners = pgm.mirror.compute_corners()\\n\",\n    \"grating_corners = pgm.grating.compute_corners()\\n\",\n    \"rays = pgm.generate_rays()\\n\",\n    \"_ = pgm.propagate(pgm.rays)\\n\",\n    \"mirror_z = np.array(\\n\",\n    \"    [mirror_corners[i][2] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"mirror_x = np.array(\\n\",\n    \"    [mirror_corners[i][1] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"grating_z = np.array(\\n\",\n    \"    [grating_corners[i][2] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"grating_x = np.array(\\n\",\n    \"    [grating_corners[i][1] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"ray1z = [pgm.rays[0].position.list[2],\\n\",\n    \"         pgm.mirror_intercept[0].z,\\n\",\n    \"         pgm.grating_intercept[0].z,\\n\",\n    \"         1000]\\n\",\n    \"\\n\",\n    \"ray1x = [pgm.rays[0].position.list[1],\\n\",\n    \"         pgm.mirror_intercept[0].y,\\n\",\n    \"         pgm.grating_intercept[0].y,\\n\",\n    \"         0]\\n\",\n    \"ray2z = [pgm.rays[1].position.list[2],\\n\",\n    \"         pgm.mirror_intercept[1].z,\\n\",\n    \"         pgm.grating_intercept[1].z,\\n\",\n    \"         1000]\\n\",\n    \"\\n\",\n    \"ray2x = [pgm.rays[1].position.list[1],\\n\",\n    \"         pgm.mirror_intercept[1].y,\\n\",\n    \"         pgm.grating_intercept[1].y,\\n\",\n    \"         pgm.grating_intercept[1].y + 1000*pgm.rays[1].vector[1]]\\n\",\n    \"\\n\",\n    \"ray3z = [pgm.rays[2].position.list[2],\\n\",\n    \"         pgm.mirror_intercept[2].z,\\n\",\n    \"         pgm.grating_intercept[2].z,\\n\",\n    \"         1000]\\n\",\n    \"\\n\",\n    \"ray3x = [pgm.rays[2].position.list[1],\\n\",\n    \"         pgm.mirror_intercept[2].y,\\n\",\n    \"         pgm.grating_intercept[2].y,\\n\",\n    \"         pgm.grating_intercept[2].y + 1000*pgm.rays[2].vector[1]]\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 16,\n   \"id\": \"1c25d5fd-a63f-4782-9288-f5726f84a185\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"0.0\"\n      ]\n     },\n     \"execution_count\": 16,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"pgm.mirror_intercept[0].x\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 37,\n   \"id\": \"098d24f9-d4bf-4698-9def-f7528b1f0d8a\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"application/vnd.plotly.v1+json\": {\n       \"config\": {\n        \"plotlyServerURL\": \"https://plot.ly\"\n       },\n       \"data\": [\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"red\",\n         \"line\": {\n          \"color\": \"red\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"name\": \"Mirror\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -488.98418690644684,\n          -486.82891290119335,\n          -37.24717582667142,\n          -39.402449831924926,\n          -488.98418690644684\n         ],\n         \"y\": [\n          -27.60960210030383,\n          -77.56312844191737,\n          -58.165662394635866,\n          -8.212136053022322,\n          -27.60960210030383\n         ]\n        },\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"blue\",\n         \"line\": {\n          \"color\": \"blue\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"name\": \"Grating\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -102.38789499346726,\n          97.35905233228345,\n          99.87347366287536,\n          -99.87347366287536,\n          -102.38789499346726\n         ],\n         \"y\": [\n          44.90789417025387,\n          54.96557949262149,\n          5.028842661183811,\n          -5.028842661183811,\n          44.90789417025387\n         ]\n        },\n        {\n         \"line\": {\n          \"color\": \"green\",\n          \"width\": 1.5\n         },\n         \"type\": \"scatter\",\n         \"x\": [\n          -1000,\n          -150.3724180180722,\n          -0.00031226780420468003,\n          1000\n         ],\n         \"y\": [\n          -13,\n          -13,\n          -1.572335073518616e-05,\n          0\n         ]\n        },\n        {\n         \"line\": {\n          \"color\": \"green\",\n          \"width\": 1.5\n         },\n         \"type\": \"scatter\",\n         \"x\": [\n          -1000,\n          -92.42905882122382,\n          69.51014597702995,\n          1000\n         ],\n         \"y\": [\n          -10.5,\n          -10.5,\n          3.499984276649206,\n          3.499984276649206\n         ]\n        },\n        {\n         \"line\": {\n          \"color\": \"green\",\n          \"width\": 1.5\n         },\n         \"type\": \"scatter\",\n         \"x\": [\n          -1000,\n          -208.31577721492062,\n          -69.51077051263833,\n          1000\n         ],\n         \"y\": [\n          -15.5,\n          -15.5,\n          -3.500015723350675,\n          -3.500015723350675\n         ]\n        }\n       ],\n       \"layout\": {\n        \"autosize\": true,\n        \"dragmode\": \"pan\",\n        \"showlegend\": false,\n        \"template\": {\n         \"data\": {\n          \"bar\": [\n           {\n            \"error_x\": {\n             \"color\": \"#2a3f5f\"\n            },\n            \"error_y\": {\n             \"color\": \"#2a3f5f\"\n            },\n            \"marker\": {\n             \"line\": {\n              \"color\": \"#E5ECF6\",\n              \"width\": 0.5\n             },\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"bar\"\n           }\n          ],\n          \"barpolar\": [\n           {\n            \"marker\": {\n             \"line\": {\n              \"color\": \"#E5ECF6\",\n              \"width\": 0.5\n             },\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"barpolar\"\n           }\n          ],\n          \"carpet\": [\n           {\n            \"aaxis\": {\n             \"endlinecolor\": \"#2a3f5f\",\n             \"gridcolor\": \"white\",\n             \"linecolor\": \"white\",\n             \"minorgridcolor\": \"white\",\n             \"startlinecolor\": \"#2a3f5f\"\n            },\n            \"baxis\": {\n             \"endlinecolor\": \"#2a3f5f\",\n             \"gridcolor\": \"white\",\n             \"linecolor\": \"white\",\n             \"minorgridcolor\": \"white\",\n             \"startlinecolor\": \"#2a3f5f\"\n            },\n            \"type\": \"carpet\"\n           }\n          ],\n          \"choropleth\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"choropleth\"\n           }\n          ],\n          \"contour\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"contour\"\n           }\n          ],\n          \"contourcarpet\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"contourcarpet\"\n           }\n          ],\n          \"heatmap\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"heatmap\"\n           }\n          ],\n          \"heatmapgl\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"heatmapgl\"\n           }\n          ],\n          \"histogram\": [\n           {\n            \"marker\": {\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"histogram\"\n           }\n          ],\n          \"histogram2d\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"histogram2d\"\n           }\n          ],\n          \"histogram2dcontour\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"histogram2dcontour\"\n           }\n          ],\n          \"mesh3d\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"mesh3d\"\n           }\n          ],\n          \"parcoords\": [\n           {\n            \"line\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"parcoords\"\n           }\n          ],\n          \"pie\": [\n           {\n            \"automargin\": true,\n            \"type\": \"pie\"\n           }\n          ],\n          \"scatter\": [\n           {\n            \"fillpattern\": {\n             \"fillmode\": \"overlay\",\n             \"size\": 10,\n             \"solidity\": 0.2\n            },\n            \"type\": \"scatter\"\n           }\n          ],\n          \"scatter3d\": [\n           {\n            \"line\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatter3d\"\n           }\n          ],\n          \"scattercarpet\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattercarpet\"\n           }\n          ],\n          \"scattergeo\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattergeo\"\n           }\n          ],\n          \"scattergl\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattergl\"\n           }\n          ],\n          \"scattermapbox\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattermapbox\"\n           }\n          ],\n          \"scatterpolar\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterpolar\"\n           }\n          ],\n          \"scatterpolargl\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterpolargl\"\n           }\n          ],\n          \"scatterternary\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterternary\"\n           }\n          ],\n          \"surface\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"surface\"\n           }\n          ],\n          \"table\": [\n           {\n            \"cells\": {\n             \"fill\": {\n              \"color\": \"#EBF0F8\"\n             },\n             \"line\": {\n              \"color\": \"white\"\n             }\n            },\n            \"header\": {\n             \"fill\": {\n              \"color\": \"#C8D4E3\"\n             },\n             \"line\": {\n              \"color\": \"white\"\n             }\n            },\n            \"type\": \"table\"\n           }\n          ]\n         },\n         \"layout\": {\n          \"annotationdefaults\": {\n           \"arrowcolor\": \"#2a3f5f\",\n           \"arrowhead\": 0,\n           \"arrowwidth\": 1\n          },\n          \"autotypenumbers\": \"strict\",\n          \"coloraxis\": {\n           \"colorbar\": {\n            \"outlinewidth\": 0,\n            \"ticks\": \"\"\n           }\n          },\n          \"colorscale\": {\n           \"diverging\": [\n            [\n             0,\n             \"#8e0152\"\n            ],\n            [\n             0.1,\n             \"#c51b7d\"\n            ],\n            [\n             0.2,\n             \"#de77ae\"\n            ],\n            [\n             0.3,\n             \"#f1b6da\"\n            ],\n            [\n             0.4,\n             \"#fde0ef\"\n            ],\n            [\n             0.5,\n             \"#f7f7f7\"\n            ],\n            [\n             0.6,\n             \"#e6f5d0\"\n            ],\n            [\n             0.7,\n             \"#b8e186\"\n            ],\n            [\n             0.8,\n             \"#7fbc41\"\n            ],\n            [\n             0.9,\n             \"#4d9221\"\n            ],\n            [\n             1,\n             \"#276419\"\n            ]\n           ],\n           \"sequential\": [\n            [\n             0,\n             \"#0d0887\"\n            ],\n            [\n             0.1111111111111111,\n             \"#46039f\"\n            ],\n            [\n             0.2222222222222222,\n             \"#7201a8\"\n            ],\n            [\n             0.3333333333333333,\n             \"#9c179e\"\n            ],\n            [\n             0.4444444444444444,\n             \"#bd3786\"\n            ],\n            [\n             0.5555555555555556,\n             \"#d8576b\"\n            ],\n            [\n             0.6666666666666666,\n             \"#ed7953\"\n            ],\n            [\n             0.7777777777777778,\n             \"#fb9f3a\"\n            ],\n            [\n             0.8888888888888888,\n             \"#fdca26\"\n            ],\n            [\n             1,\n             \"#f0f921\"\n            ]\n           ],\n           \"sequentialminus\": [\n            [\n             0,\n             \"#0d0887\"\n            ],\n            [\n             0.1111111111111111,\n             \"#46039f\"\n            ],\n            [\n             0.2222222222222222,\n             \"#7201a8\"\n            ],\n            [\n             0.3333333333333333,\n             \"#9c179e\"\n            ],\n            [\n             0.4444444444444444,\n             \"#bd3786\"\n            ],\n            [\n             0.5555555555555556,\n             \"#d8576b\"\n            ],\n            [\n             0.6666666666666666,\n             \"#ed7953\"\n            ],\n            [\n             0.7777777777777778,\n             \"#fb9f3a\"\n            ],\n            [\n             0.8888888888888888,\n             \"#fdca26\"\n            ],\n            [\n             1,\n             \"#f0f921\"\n            ]\n           ]\n          },\n          \"colorway\": [\n           \"#636efa\",\n           \"#EF553B\",\n           \"#00cc96\",\n           \"#ab63fa\",\n           \"#FFA15A\",\n           \"#19d3f3\",\n           \"#FF6692\",\n           \"#B6E880\",\n           \"#FF97FF\",\n           \"#FECB52\"\n          ],\n          \"font\": {\n           \"color\": \"#2a3f5f\"\n          },\n          \"geo\": {\n           \"bgcolor\": \"white\",\n           \"lakecolor\": \"white\",\n           \"landcolor\": \"#E5ECF6\",\n           \"showlakes\": true,\n           \"showland\": true,\n           \"subunitcolor\": \"white\"\n          },\n          \"hoverlabel\": {\n           \"align\": \"left\"\n          },\n          \"hovermode\": \"closest\",\n          \"mapbox\": {\n           \"style\": \"light\"\n          },\n          \"paper_bgcolor\": \"white\",\n          \"plot_bgcolor\": \"#E5ECF6\",\n          \"polar\": {\n           \"angularaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"bgcolor\": \"#E5ECF6\",\n           \"radialaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           }\n          },\n          \"scene\": {\n           \"xaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           },\n           \"yaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           },\n           \"zaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           }\n          },\n          \"shapedefaults\": {\n           \"line\": {\n            \"color\": \"#2a3f5f\"\n           }\n          },\n          \"ternary\": {\n           \"aaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"baxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"bgcolor\": \"#E5ECF6\",\n           \"caxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           }\n          },\n          \"title\": {\n           \"x\": 0.05\n          },\n          \"xaxis\": {\n           \"automargin\": true,\n           \"gridcolor\": \"white\",\n           \"linecolor\": \"white\",\n           \"ticks\": \"\",\n           \"title\": {\n            \"standoff\": 15\n           },\n           \"zerolinecolor\": \"white\",\n           \"zerolinewidth\": 2\n          },\n          \"yaxis\": {\n           \"automargin\": true,\n           \"gridcolor\": \"white\",\n           \"linecolor\": \"white\",\n           \"ticks\": \"\",\n           \"title\": {\n            \"standoff\": 15\n           },\n           \"zerolinecolor\": \"white\",\n           \"zerolinewidth\": 2\n          }\n         }\n        },\n        \"xaxis\": {\n         \"autorange\": false,\n         \"domain\": [\n          0,\n          1\n         ],\n         \"range\": [\n          -258.3157772149206,\n          119.51014597702995\n         ],\n         \"showspikes\": false,\n         \"type\": \"linear\"\n        },\n        \"yaxis\": {\n         \"autorange\": true,\n         \"domain\": [\n          0,\n          1\n         ],\n         \"range\": [\n          -168.09400364399824,\n          145.49645469470238\n         ],\n         \"scaleanchor\": \"x\",\n         \"scaleratio\": 1,\n         \"showspikes\": false,\n         \"type\": \"linear\"\n        }\n       }\n      },\n      \"image/png\": \"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\",\n      \"text/html\": [\n       \"<div>                            <div id=\\\"3d7beda4-f5a2-4d3a-aeba-ec3e842a8925\\\" class=\\\"plotly-graph-div\\\" style=\\\"height:800px; width:100%;\\\"></div>            <script type=\\\"text/javascript\\\">                require([\\\"plotly\\\"], function(Plotly) {                    window.PLOTLYENV=window.PLOTLYENV || {};                                    if (document.getElementById(\\\"3d7beda4-f5a2-4d3a-aeba-ec3e842a8925\\\")) {                    Plotly.newPlot(                        \\\"3d7beda4-f5a2-4d3a-aeba-ec3e842a8925\\\",                        [{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"red\\\",\\\"line\\\":{\\\"color\\\":\\\"red\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"name\\\":\\\"Mirror\\\",\\\"x\\\":[-488.98418690644684,-486.82891290119335,-37.24717582667142,-39.402449831924926,-488.98418690644684],\\\"y\\\":[-27.60960210030383,-77.56312844191737,-58.165662394635866,-8.212136053022322,-27.60960210030383],\\\"type\\\":\\\"scatter\\\"},{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"blue\\\",\\\"line\\\":{\\\"color\\\":\\\"blue\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"name\\\":\\\"Grating\\\",\\\"x\\\":[-102.38789499346726,97.35905233228345,99.87347366287536,-99.87347366287536,-102.38789499346726],\\\"y\\\":[44.90789417025387,54.96557949262149,5.028842661183811,-5.028842661183811,44.90789417025387],\\\"type\\\":\\\"scatter\\\"},{\\\"line\\\":{\\\"color\\\":\\\"green\\\",\\\"width\\\":1.5},\\\"x\\\":[-1000.0,-150.3724180180722,-0.00031226780420468003,1000],\\\"y\\\":[-13.0,-13.0,-1.572335073518616e-05,0],\\\"type\\\":\\\"scatter\\\"},{\\\"line\\\":{\\\"color\\\":\\\"green\\\",\\\"width\\\":1.5},\\\"x\\\":[-1000.0,-92.42905882122382,69.51014597702995,1000],\\\"y\\\":[-10.5,-10.5,3.499984276649206,3.499984276649206],\\\"type\\\":\\\"scatter\\\"},{\\\"line\\\":{\\\"color\\\":\\\"green\\\",\\\"width\\\":1.5},\\\"x\\\":[-1000.0,-208.31577721492062,-69.51077051263833,1000],\\\"y\\\":[-15.5,-15.5,-3.500015723350675,-3.500015723350675],\\\"type\\\":\\\"scatter\\\"}],                        {\\\"height\\\":800,\\\"showlegend\\\":false,\\\"xaxis\\\":{\\\"range\\\":[-258.3157772149206,119.51014597702995]},\\\"template\\\":{\\\"data\\\":{\\\"histogram2dcontour\\\":[{\\\"type\\\":\\\"histogram2dcontour\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"choropleth\\\":[{\\\"type\\\":\\\"choropleth\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"histogram2d\\\":[{\\\"type\\\":\\\"histogram2d\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"heatmap\\\":[{\\\"type\\\":\\\"heatmap\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"heatmapgl\\\":[{\\\"type\\\":\\\"heatmapgl\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"contourcarpet\\\":[{\\\"type\\\":\\\"contourcarpet\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"contour\\\":[{\\\"type\\\":\\\"contour\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"surface\\\":[{\\\"type\\\":\\\"surface\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"mesh3d\\\":[{\\\"type\\\":\\\"mesh3d\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"scatter\\\":[{\\\"fillpattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2},\\\"type\\\":\\\"scatter\\\"}],\\\"parcoords\\\":[{\\\"type\\\":\\\"parcoords\\\",\\\"line\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterpolargl\\\":[{\\\"type\\\":\\\"scatterpolargl\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"bar\\\":[{\\\"error_x\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"error_y\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"marker\\\":{\\\"line\\\":{\\\"color\\\":\\\"#E5ECF6\\\",\\\"width\\\":0.5},\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"bar\\\"}],\\\"scattergeo\\\":[{\\\"type\\\":\\\"scattergeo\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterpolar\\\":[{\\\"type\\\":\\\"scatterpolar\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"histogram\\\":[{\\\"marker\\\":{\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"histogram\\\"}],\\\"scattergl\\\":[{\\\"type\\\":\\\"scattergl\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatter3d\\\":[{\\\"type\\\":\\\"scatter3d\\\",\\\"line\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}},\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scattermapbox\\\":[{\\\"type\\\":\\\"scattermapbox\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterternary\\\":[{\\\"type\\\":\\\"scatterternary\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scattercarpet\\\":[{\\\"type\\\":\\\"scattercarpet\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"carpet\\\":[{\\\"aaxis\\\":{\\\"endlinecolor\\\":\\\"#2a3f5f\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"minorgridcolor\\\":\\\"white\\\",\\\"startlinecolor\\\":\\\"#2a3f5f\\\"},\\\"baxis\\\":{\\\"endlinecolor\\\":\\\"#2a3f5f\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"minorgridcolor\\\":\\\"white\\\",\\\"startlinecolor\\\":\\\"#2a3f5f\\\"},\\\"type\\\":\\\"carpet\\\"}],\\\"table\\\":[{\\\"cells\\\":{\\\"fill\\\":{\\\"color\\\":\\\"#EBF0F8\\\"},\\\"line\\\":{\\\"color\\\":\\\"white\\\"}},\\\"header\\\":{\\\"fill\\\":{\\\"color\\\":\\\"#C8D4E3\\\"},\\\"line\\\":{\\\"color\\\":\\\"white\\\"}},\\\"type\\\":\\\"table\\\"}],\\\"barpolar\\\":[{\\\"marker\\\":{\\\"line\\\":{\\\"color\\\":\\\"#E5ECF6\\\",\\\"width\\\":0.5},\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"barpolar\\\"}],\\\"pie\\\":[{\\\"automargin\\\":true,\\\"type\\\":\\\"pie\\\"}]},\\\"layout\\\":{\\\"autotypenumbers\\\":\\\"strict\\\",\\\"colorway\\\":[\\\"#636efa\\\",\\\"#EF553B\\\",\\\"#00cc96\\\",\\\"#ab63fa\\\",\\\"#FFA15A\\\",\\\"#19d3f3\\\",\\\"#FF6692\\\",\\\"#B6E880\\\",\\\"#FF97FF\\\",\\\"#FECB52\\\"],\\\"font\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"hovermode\\\":\\\"closest\\\",\\\"hoverlabel\\\":{\\\"align\\\":\\\"left\\\"},\\\"paper_bgcolor\\\":\\\"white\\\",\\\"plot_bgcolor\\\":\\\"#E5ECF6\\\",\\\"polar\\\":{\\\"bgcolor\\\":\\\"#E5ECF6\\\",\\\"angularaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"radialaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"}},\\\"ternary\\\":{\\\"bgcolor\\\":\\\"#E5ECF6\\\",\\\"aaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"baxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"caxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"}},\\\"coloraxis\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}},\\\"colorscale\\\":{\\\"sequential\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]],\\\"sequentialminus\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]],\\\"diverging\\\":[[0,\\\"#8e0152\\\"],[0.1,\\\"#c51b7d\\\"],[0.2,\\\"#de77ae\\\"],[0.3,\\\"#f1b6da\\\"],[0.4,\\\"#fde0ef\\\"],[0.5,\\\"#f7f7f7\\\"],[0.6,\\\"#e6f5d0\\\"],[0.7,\\\"#b8e186\\\"],[0.8,\\\"#7fbc41\\\"],[0.9,\\\"#4d9221\\\"],[1,\\\"#276419\\\"]]},\\\"xaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\",\\\"title\\\":{\\\"standoff\\\":15},\\\"zerolinecolor\\\":\\\"white\\\",\\\"automargin\\\":true,\\\"zerolinewidth\\\":2},\\\"yaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\",\\\"title\\\":{\\\"standoff\\\":15},\\\"zerolinecolor\\\":\\\"white\\\",\\\"automargin\\\":true,\\\"zerolinewidth\\\":2},\\\"scene\\\":{\\\"xaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2},\\\"yaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2},\\\"zaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2}},\\\"shapedefaults\\\":{\\\"line\\\":{\\\"color\\\":\\\"#2a3f5f\\\"}},\\\"annotationdefaults\\\":{\\\"arrowcolor\\\":\\\"#2a3f5f\\\",\\\"arrowhead\\\":0,\\\"arrowwidth\\\":1},\\\"geo\\\":{\\\"bgcolor\\\":\\\"white\\\",\\\"landcolor\\\":\\\"#E5ECF6\\\",\\\"subunitcolor\\\":\\\"white\\\",\\\"showland\\\":true,\\\"showlakes\\\":true,\\\"lakecolor\\\":\\\"white\\\"},\\\"title\\\":{\\\"x\\\":0.05},\\\"mapbox\\\":{\\\"style\\\":\\\"light\\\"}}},\\\"yaxis\\\":{\\\"scaleanchor\\\":\\\"x\\\",\\\"scaleratio\\\":1}},                        {\\\"responsive\\\": true}                    ).then(function(){\\n\",\n       \"                            \\n\",\n       \"var gd = document.getElementById('3d7beda4-f5a2-4d3a-aeba-ec3e842a8925');\\n\",\n       \"var x = new MutationObserver(function (mutations, observer) {{\\n\",\n       \"        var display = window.getComputedStyle(gd).display;\\n\",\n       \"        if (!display || display === 'none') {{\\n\",\n       \"            console.log([gd, 'removed!']);\\n\",\n       \"            Plotly.purge(gd);\\n\",\n       \"            observer.disconnect();\\n\",\n       \"        }}\\n\",\n       \"}});\\n\",\n       \"\\n\",\n       \"// Listen for the removal of the full notebook cells\\n\",\n       \"var notebookContainer = gd.closest('#notebook-container');\\n\",\n       \"if (notebookContainer) {{\\n\",\n       \"    x.observe(notebookContainer, {childList: true});\\n\",\n       \"}}\\n\",\n       \"\\n\",\n       \"// Listen for the clearing of the current output cell\\n\",\n       \"var outputEl = gd.closest('.output');\\n\",\n       \"if (outputEl) {{\\n\",\n       \"    x.observe(outputEl, {childList: true});\\n\",\n       \"}}\\n\",\n       \"\\n\",\n       \"                        })                };                });            </script>        </div>\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"fig = go.Figure(layout={'showlegend':False, 'xaxis':{'range':(min(ray3z[1:])-50,max(ray2z[1:-1])+50),}, 'height':800})\\n\",\n    \"fig.add_trace(go.Scatter(x=mirror_z, y=mirror_x,fill='toself',fillcolor='red',line={\\\"color\\\":'red'}, marker={'size':0}, name='Mirror'))\\n\",\n    \"fig.add_trace(go.Scatter(x=grating_z, y=grating_x,fill='toself',fillcolor='blue',line={\\\"color\\\":'blue'}, marker={'size':0}, name='Grating')) #mode lines if to hide vertices\\n\",\n    \"fig.update_yaxes(scaleanchor=\\\"x\\\",scaleratio=1,)\\n\",\n    \"\\n\",\n    \"fig.add_trace(go.Scatter(x=ray1z, y = ray1x, line={'color':'green', 'width':1.5}))\\n\",\n    \"fig.add_trace(go.Scatter(x=ray2z, y = ray2x, line={'color':'green', 'width':1.5}))\\n\",\n    \"fig.add_trace(go.Scatter(x=ray3z, y = ray3x, line={'color':'green', 'width':1.5}))\\n\",\n    \"\\n\",\n    \"\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"4fa70e97-df5a-43b9-a5cc-211ca76856cf\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"fig = go.Figure(layout={'showlegend':False, 'xaxis':{'range':(min(ray3z[1:])-50,max(ray2z[1:-1])+50),}, 'height':800})\\n\",\n    \"fig.add_trace(go.Scatter(x=mirror_z, y=mirror_x,fill='toself',fillcolor='red',line={\\\"color\\\":'red'}, marker={'size':0}, name='Mirror'))\\n\",\n    \"fig.add_trace(go.Scatter(x=grating_z, y=grating_x,fill='toself',fillcolor='blue',line={\\\"color\\\":'blue'}, marker={'size':0}, name='Grating')) #mode lines if to hide vertices\\n\",\n    \"fig.update_yaxes(scaleanchor=\\\"x\\\",scaleratio=1,)\\n\",\n    \"\\n\",\n    \"fig.add_trace(go.Scatter(x=ray1z, y = ray1x, line={'color':'green', 'width':1.5}))\\n\",\n    \"fig.add_trace(go.Scatter(x=ray2z, y = ray2x, line={'color':'green', 'width':1.5}))\\n\",\n    \"fig.add_trace(go.Scatter(x=ray3z, y = ray3x, line={'color':'green', 'width':1.5}))\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 48,\n   \"id\": \"ed7d79d2-825f-4b86-b4c5-6da69b38ee6b\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"2400 1 600 2 5.166008268050012e-10\\n\",\n      \"1200 1 600 1.4 1.0332016536100023e-09\\n\"\n     ]\n    },\n    {\n     \"data\": {\n      \"application/vnd.plotly.v1+json\": {\n       \"config\": {\n        \"plotlyServerURL\": \"https://plot.ly\"\n       },\n       \"data\": [\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"red\",\n         \"line\": {\n          \"color\": \"red\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"name\": \"Mirror\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -39.402449831924926,\n          -39.402449831924926,\n          -488.98418690644684,\n          -488.98418690644684\n         ],\n         \"y\": [\n          -35,\n          35,\n          35,\n          -35\n         ]\n        },\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"blue\",\n         \"line\": {\n          \"color\": \"blue\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"name\": \"Grating\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -99.87347366287536,\n          -99.87347366287536,\n          99.87347366287536,\n          99.87347366287536\n         ],\n         \"y\": [\n          35,\n          75,\n          75,\n          35\n         ]\n        },\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"green\",\n         \"line\": {\n          \"color\": \"green\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"name\": \"Beam Footprint on Mirror\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -208.31577721492062,\n          -92.42905882122382,\n          -92.42905882122382,\n          -208.31577721492062\n         ],\n         \"y\": [\n          -3.215,\n          -3.215,\n          3.2150000000000034,\n          3.2150000000000034\n         ]\n        },\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"green\",\n         \"line\": {\n          \"color\": \"green\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"name\": \"Beam Footprint on Grating\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -69.51077051263833,\n          69.51014597702995,\n          69.51014597702995,\n          -69.51077051263833\n         ],\n         \"y\": [\n          51.785,\n          51.785,\n          58.215,\n          58.215\n         ]\n        }\n       ],\n       \"layout\": {\n        \"autosize\": true,\n        \"showlegend\": false,\n        \"template\": {\n         \"data\": {\n          \"bar\": [\n           {\n            \"error_x\": {\n             \"color\": \"#2a3f5f\"\n            },\n            \"error_y\": {\n             \"color\": \"#2a3f5f\"\n            },\n            \"marker\": {\n             \"line\": {\n              \"color\": \"#E5ECF6\",\n              \"width\": 0.5\n             },\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"bar\"\n           }\n          ],\n          \"barpolar\": [\n           {\n            \"marker\": {\n             \"line\": {\n              \"color\": \"#E5ECF6\",\n              \"width\": 0.5\n             },\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"barpolar\"\n           }\n          ],\n          \"carpet\": [\n           {\n            \"aaxis\": {\n             \"endlinecolor\": \"#2a3f5f\",\n             \"gridcolor\": \"white\",\n             \"linecolor\": \"white\",\n             \"minorgridcolor\": \"white\",\n             \"startlinecolor\": \"#2a3f5f\"\n            },\n            \"baxis\": {\n             \"endlinecolor\": \"#2a3f5f\",\n             \"gridcolor\": \"white\",\n             \"linecolor\": \"white\",\n             \"minorgridcolor\": \"white\",\n             \"startlinecolor\": \"#2a3f5f\"\n            },\n            \"type\": \"carpet\"\n           }\n          ],\n          \"choropleth\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"choropleth\"\n           }\n          ],\n          \"contour\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"contour\"\n           }\n          ],\n          \"contourcarpet\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"contourcarpet\"\n           }\n          ],\n          \"heatmap\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"heatmap\"\n           }\n          ],\n          \"heatmapgl\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"heatmapgl\"\n           }\n          ],\n          \"histogram\": [\n           {\n            \"marker\": {\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"histogram\"\n           }\n          ],\n          \"histogram2d\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"histogram2d\"\n           }\n          ],\n          \"histogram2dcontour\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"histogram2dcontour\"\n           }\n          ],\n          \"mesh3d\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"mesh3d\"\n           }\n          ],\n          \"parcoords\": [\n           {\n            \"line\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"parcoords\"\n           }\n          ],\n          \"pie\": [\n           {\n            \"automargin\": true,\n            \"type\": \"pie\"\n           }\n          ],\n          \"scatter\": [\n           {\n            \"fillpattern\": {\n             \"fillmode\": \"overlay\",\n             \"size\": 10,\n             \"solidity\": 0.2\n            },\n            \"type\": \"scatter\"\n           }\n          ],\n          \"scatter3d\": [\n           {\n            \"line\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatter3d\"\n           }\n          ],\n          \"scattercarpet\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattercarpet\"\n           }\n          ],\n          \"scattergeo\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattergeo\"\n           }\n          ],\n          \"scattergl\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattergl\"\n           }\n          ],\n          \"scattermapbox\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattermapbox\"\n           }\n          ],\n          \"scatterpolar\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterpolar\"\n           }\n          ],\n          \"scatterpolargl\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterpolargl\"\n           }\n          ],\n          \"scatterternary\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterternary\"\n           }\n          ],\n          \"surface\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"surface\"\n           }\n          ],\n          \"table\": [\n           {\n            \"cells\": {\n             \"fill\": {\n              \"color\": \"#EBF0F8\"\n             },\n             \"line\": {\n              \"color\": \"white\"\n             }\n            },\n            \"header\": {\n             \"fill\": {\n              \"color\": \"#C8D4E3\"\n             },\n             \"line\": {\n              \"color\": \"white\"\n             }\n            },\n            \"type\": \"table\"\n           }\n          ]\n         },\n         \"layout\": {\n          \"annotationdefaults\": {\n           \"arrowcolor\": \"#2a3f5f\",\n           \"arrowhead\": 0,\n           \"arrowwidth\": 1\n          },\n          \"autotypenumbers\": \"strict\",\n          \"coloraxis\": {\n           \"colorbar\": {\n            \"outlinewidth\": 0,\n            \"ticks\": \"\"\n           }\n          },\n          \"colorscale\": {\n           \"diverging\": [\n            [\n             0,\n             \"#8e0152\"\n            ],\n            [\n             0.1,\n             \"#c51b7d\"\n            ],\n            [\n             0.2,\n             \"#de77ae\"\n            ],\n            [\n             0.3,\n             \"#f1b6da\"\n            ],\n            [\n             0.4,\n             \"#fde0ef\"\n            ],\n            [\n             0.5,\n             \"#f7f7f7\"\n            ],\n            [\n             0.6,\n             \"#e6f5d0\"\n            ],\n            [\n             0.7,\n             \"#b8e186\"\n            ],\n            [\n             0.8,\n             \"#7fbc41\"\n            ],\n            [\n             0.9,\n             \"#4d9221\"\n            ],\n            [\n             1,\n             \"#276419\"\n            ]\n           ],\n           \"sequential\": [\n            [\n             0,\n             \"#0d0887\"\n            ],\n            [\n             0.1111111111111111,\n             \"#46039f\"\n            ],\n            [\n             0.2222222222222222,\n             \"#7201a8\"\n            ],\n            [\n             0.3333333333333333,\n             \"#9c179e\"\n            ],\n            [\n             0.4444444444444444,\n             \"#bd3786\"\n            ],\n            [\n             0.5555555555555556,\n             \"#d8576b\"\n            ],\n            [\n             0.6666666666666666,\n             \"#ed7953\"\n            ],\n            [\n             0.7777777777777778,\n             \"#fb9f3a\"\n            ],\n            [\n             0.8888888888888888,\n             \"#fdca26\"\n            ],\n            [\n             1,\n             \"#f0f921\"\n            ]\n           ],\n           \"sequentialminus\": [\n            [\n             0,\n             \"#0d0887\"\n            ],\n            [\n             0.1111111111111111,\n             \"#46039f\"\n            ],\n            [\n             0.2222222222222222,\n             \"#7201a8\"\n            ],\n            [\n             0.3333333333333333,\n             \"#9c179e\"\n            ],\n            [\n             0.4444444444444444,\n             \"#bd3786\"\n            ],\n            [\n             0.5555555555555556,\n             \"#d8576b\"\n            ],\n            [\n             0.6666666666666666,\n             \"#ed7953\"\n            ],\n            [\n             0.7777777777777778,\n             \"#fb9f3a\"\n            ],\n            [\n             0.8888888888888888,\n             \"#fdca26\"\n            ],\n            [\n             1,\n             \"#f0f921\"\n            ]\n           ]\n          },\n          \"colorway\": [\n           \"#636efa\",\n           \"#EF553B\",\n           \"#00cc96\",\n           \"#ab63fa\",\n           \"#FFA15A\",\n           \"#19d3f3\",\n           \"#FF6692\",\n           \"#B6E880\",\n           \"#FF97FF\",\n           \"#FECB52\"\n          ],\n          \"font\": {\n           \"color\": \"#2a3f5f\"\n          },\n          \"geo\": {\n           \"bgcolor\": \"white\",\n           \"lakecolor\": \"white\",\n           \"landcolor\": \"#E5ECF6\",\n           \"showlakes\": true,\n           \"showland\": true,\n           \"subunitcolor\": \"white\"\n          },\n          \"hoverlabel\": {\n           \"align\": \"left\"\n          },\n          \"hovermode\": \"closest\",\n          \"mapbox\": {\n           \"style\": \"light\"\n          },\n          \"paper_bgcolor\": \"white\",\n          \"plot_bgcolor\": \"#E5ECF6\",\n          \"polar\": {\n           \"angularaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"bgcolor\": \"#E5ECF6\",\n           \"radialaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           }\n          },\n          \"scene\": {\n           \"xaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           },\n           \"yaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           },\n           \"zaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           }\n          },\n          \"shapedefaults\": {\n           \"line\": {\n            \"color\": \"#2a3f5f\"\n           }\n          },\n          \"ternary\": {\n           \"aaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"baxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"bgcolor\": \"#E5ECF6\",\n           \"caxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           }\n          },\n          \"title\": {\n           \"x\": 0.05\n          },\n          \"xaxis\": {\n           \"automargin\": true,\n           \"gridcolor\": \"white\",\n           \"linecolor\": \"white\",\n           \"ticks\": \"\",\n           \"title\": {\n            \"standoff\": 15\n           },\n           \"zerolinecolor\": \"white\",\n           \"zerolinewidth\": 2\n          },\n          \"yaxis\": {\n           \"automargin\": true,\n           \"gridcolor\": \"white\",\n           \"linecolor\": \"white\",\n           \"ticks\": \"\",\n           \"title\": {\n            \"standoff\": 15\n           },\n           \"zerolinecolor\": \"white\",\n           \"zerolinewidth\": 2\n          }\n         }\n        },\n        \"xaxis\": {\n         \"autorange\": true,\n         \"range\": [\n          -524.6444099350708,\n          135.53369669149933\n         ],\n         \"type\": \"linear\"\n        },\n        \"yaxis\": {\n         \"autorange\": true,\n         \"range\": [\n          -42.4113475177305,\n          82.41134751773049\n         ],\n         \"type\": \"linear\"\n        }\n       }\n      },\n      \"image/png\": \"iVBORw0KGgoAAAANSUhEUgAAA4sAAAH0CAYAAACU+LheAAAAAXNSR0IArs4c6QAAIABJREFUeF7t3X205VV9J+h9642qkpJXkWZCJMGVhay2JQvN1KwVDYJOEhgmDjOy4urYsXFYNTgxCdKwILRDXIbAQKN2Z7WkmkjM0kS7TExmEjEvmlHs7pDYZpxJJtIZMRKnQYKACFrvdSfnFLe4dbnU2ed+zzl777Of+qM7Ze199v49n7O5v0+dl1pYXFxcTH4RIECAAAECBAgQIECAAIFlAgvKoucDAQIECBAgQIAAAQIECKwUUBY9JwgQIECAAAECBAgQIEDgOQLKoicFAQIECBAgQIAAAQIECCiLngMECBAgQIAAAQIECBAgMFrAK4ujjYwgQIAAAQIECBAgQIBAdwLKYneRu2ACBAgQIECAAAECBAiMFlAWRxsZQYAAAQIECBAgQIAAge4ElMXuInfBBAgQIECAAAECBAgQGC2gLI42MoIAAQIECBAgQIAAAQLdCSiL3UXuggkQIECAAAECBAgQIDBaQFkcbWQEAQIECBAgQIAAAQIEuhNQFruL3AUTIECAAAECBAgQIEBgtICyONrICAIECBAgQIAAAQIECHQnoCx2F7kLJkCAAAECBAgQIECAwGgBZXG0kREECBAgQIAAAQIECBDoTkBZ7C5yF0yAAAECBAgQIECAAIHRAsriaCMjCBAgQIAAAQIECBAg0J2Asthd5C6YAAECBAgQIECAAAECowWUxdFGRhAgQIAAAQIECBAgQKA7AWWxu8hdMAECBAgQIECAAAECBEYLKIujjYwgQIAAAQIECBAgQIBAdwLKYneRu2ACBAgQIECAAAECBAiMFlAWRxsZQYAAAQIECBAgQIAAge4ElMXuInfBBAgQIECAAAECBAgQGC2gLI42MoIAAQIECBAgQIAAAQLdCSiL3UXuggkQIECAAAECBAgQIDBaQFkcbWQEAQIECBAgQIAAAQIEuhNQFruL3AUTIECAAAECBAgQIEBgtICyONrICAIECBAgQIAAAQIECHQnoCx2F7kLJkCAAAECBAgQIECAwGgBZXG0kREECBAgQIAAAQIECBDoTkBZ7C5yF0yAAAECBAgQIECAAIHRAsriaCMjCBAgQIAAAQIECBAg0J2Asthd5C6YAAECBAgQIECAAAECowWUxdFGRhAgQIAAAQIECBAgQKA7AWWxu8hdMAECBAgQIECAAAECBEYLKIujjYwgQIAAAQIECBAgQIBAdwLKYneRu2ACBAgQIECAAAECBAiMFlAWRxsZQYAAAQIECBAgQIAAge4ElMXuInfBBAgQIECAAAECBAgQGC2gLI42MoIAAQIECBAgQIAAAQLdCSiL3UXuggkQIECAAAECBAgQIDBaQFkcbWQEAQIECBAgQIAAAQIEuhNQFruL3AUTIECAAAECBAgQIEBgtICyONrICAIECBAgQIAAAQIECHQnoCx2F7kLJkCAAAECBAgQIECAwGgBZXG0kREECBAgQIAAAQIECBDoTkBZ7C5yF0yAAAECBAgQIECAAIHRAsriaCMjCBAgQIAAAQIECBAg0J2Asthd5C6YAAECBAgQIECAAAECowWUxdFGRhAgQIAAAQIECBAgQKA7AWWxu8hdMAECBAgQIECAAAECBEYLKIujjYwgQIAAAQIECBAgQIBAdwLKYneRu2ACBAgQIECAAAECBAiMFlAWRxsZQYAAAQIECBAgQIAAge4ElMXuInfBBAgQIECAAAECBAgQGC2gLI42MoIAAQIECBAgQIAAAQLdCSiL3UXuggkQIECAAAECBAgQIDBaQFkcbWQEAQIECBAgQIAAAQIEuhNQFruL3AUTIECAAAECBAgQIEBgtICyONrICAIECBAgQIAAAQIECHQnoCx2F7kLJkCAAAECBAgQIECAwGgBZXG0kREECBAgQIAAAQIECBDoTkBZ7C5yF0yAAAECBAgQIECAAIHRAsriaCMjCBAgQIAAAQIECBAg0J2Asthd5C6YAAECBAgQIECAAAECowWUxdFGRhAgQIAAAQIECBAgQKA7AWWxu8hdMAECBAgQIECAAAECBEYLKIujjYwgQIAAAQIECBAgQIBAdwLKYneRu2ACBAgQIECAAAECBAiMFlAWRxsZQYAAAQIECBAgQIAAge4ElMXuInfBBAgQIECAAAECBAgQGC2gLI42MoIAAQIECBAgQIAAAQLdCSiL3UXuggkQIECAAAECBAgQIDBaQFkcbWQEAQIECBAgQIAAAQIEuhNQFruL3AUTIECAAAECBAgQIEBgtICyONrICAIECBAgQIAAAQIECHQnoCx2F7kLJkCAAAECBAgQIECAwGgBZXG0kREECBAgQIAAAQIECBDoTkBZ7C5yF0yA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\",\n      \"text/html\": [\n       \"<div>                            <div id=\\\"cc5330c4-06a3-4a25-983d-1e42f2aad1ba\\\" class=\\\"plotly-graph-div\\\" style=\\\"height:500px; width:100%;\\\"></div>            <script type=\\\"text/javascript\\\">                require([\\\"plotly\\\"], function(Plotly) {                    window.PLOTLYENV=window.PLOTLYENV || {};                                    if (document.getElementById(\\\"cc5330c4-06a3-4a25-983d-1e42f2aad1ba\\\")) {                    Plotly.newPlot(                        \\\"cc5330c4-06a3-4a25-983d-1e42f2aad1ba\\\",                        [{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"red\\\",\\\"line\\\":{\\\"color\\\":\\\"red\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"name\\\":\\\"Mirror\\\",\\\"x\\\":[-39.402449831924926,-39.402449831924926,-488.98418690644684,-488.98418690644684],\\\"y\\\":[-35.0,35.0,35.0,-35.0],\\\"type\\\":\\\"scatter\\\"},{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"blue\\\",\\\"line\\\":{\\\"color\\\":\\\"blue\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"name\\\":\\\"Grating\\\",\\\"x\\\":[-99.87347366287536,-99.87347366287536,99.87347366287536,99.87347366287536],\\\"y\\\":[35.0,75.0,75.0,35.0],\\\"type\\\":\\\"scatter\\\"},{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"green\\\",\\\"line\\\":{\\\"color\\\":\\\"green\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"name\\\":\\\"Beam Footprint on Mirror\\\",\\\"x\\\":[-208.31577721492062,-92.42905882122382,-92.42905882122382,-208.31577721492062],\\\"y\\\":[-3.215,-3.215,3.2150000000000034,3.2150000000000034],\\\"type\\\":\\\"scatter\\\"},{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"green\\\",\\\"line\\\":{\\\"color\\\":\\\"green\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"name\\\":\\\"Beam Footprint on Grating\\\",\\\"x\\\":[-69.51077051263833,69.51014597702995,69.51014597702995,-69.51077051263833],\\\"y\\\":[51.785,51.785,58.215,58.215],\\\"type\\\":\\\"scatter\\\"}],                        {\\\"height\\\":500,\\\"showlegend\\\":false,\\\"xaxis\\\":{\\\"range\\\":[-538.9841869064469,125.0]},\\\"template\\\":{\\\"data\\\":{\\\"histogram2dcontour\\\":[{\\\"type\\\":\\\"histogram2dcontour\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"choropleth\\\":[{\\\"type\\\":\\\"choropleth\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"histogram2d\\\":[{\\\"type\\\":\\\"histogram2d\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"heatmap\\\":[{\\\"type\\\":\\\"heatmap\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"heatmapgl\\\":[{\\\"type\\\":\\\"heatmapgl\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"contourcarpet\\\":[{\\\"type\\\":\\\"contourcarpet\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"contour\\\":[{\\\"type\\\":\\\"contour\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"surface\\\":[{\\\"type\\\":\\\"surface\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"mesh3d\\\":[{\\\"type\\\":\\\"mesh3d\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"scatter\\\":[{\\\"fillpattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2},\\\"type\\\":\\\"scatter\\\"}],\\\"parcoords\\\":[{\\\"type\\\":\\\"parcoords\\\",\\\"line\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterpolargl\\\":[{\\\"type\\\":\\\"scatterpolargl\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"bar\\\":[{\\\"error_x\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"error_y\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"marker\\\":{\\\"line\\\":{\\\"color\\\":\\\"#E5ECF6\\\",\\\"width\\\":0.5},\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"bar\\\"}],\\\"scattergeo\\\":[{\\\"type\\\":\\\"scattergeo\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterpolar\\\":[{\\\"type\\\":\\\"scatterpolar\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"histogram\\\":[{\\\"marker\\\":{\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"histogram\\\"}],\\\"scattergl\\\":[{\\\"type\\\":\\\"scattergl\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatter3d\\\":[{\\\"type\\\":\\\"scatter3d\\\",\\\"line\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}},\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scattermapbox\\\":[{\\\"type\\\":\\\"scattermapbox\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterternary\\\":[{\\\"type\\\":\\\"scatterternary\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scattercarpet\\\":[{\\\"type\\\":\\\"scattercarpet\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"carpet\\\":[{\\\"aaxis\\\":{\\\"endlinecolor\\\":\\\"#2a3f5f\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"minorgridcolor\\\":\\\"white\\\",\\\"startlinecolor\\\":\\\"#2a3f5f\\\"},\\\"baxis\\\":{\\\"endlinecolor\\\":\\\"#2a3f5f\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"minorgridcolor\\\":\\\"white\\\",\\\"startlinecolor\\\":\\\"#2a3f5f\\\"},\\\"type\\\":\\\"carpet\\\"}],\\\"table\\\":[{\\\"cells\\\":{\\\"fill\\\":{\\\"color\\\":\\\"#EBF0F8\\\"},\\\"line\\\":{\\\"color\\\":\\\"white\\\"}},\\\"header\\\":{\\\"fill\\\":{\\\"color\\\":\\\"#C8D4E3\\\"},\\\"line\\\":{\\\"color\\\":\\\"white\\\"}},\\\"type\\\":\\\"table\\\"}],\\\"barpolar\\\":[{\\\"marker\\\":{\\\"line\\\":{\\\"color\\\":\\\"#E5ECF6\\\",\\\"width\\\":0.5},\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"barpolar\\\"}],\\\"pie\\\":[{\\\"automargin\\\":true,\\\"type\\\":\\\"pie\\\"}]},\\\"layout\\\":{\\\"autotypenumbers\\\":\\\"strict\\\",\\\"colorway\\\":[\\\"#636efa\\\",\\\"#EF553B\\\",\\\"#00cc96\\\",\\\"#ab63fa\\\",\\\"#FFA15A\\\",\\\"#19d3f3\\\",\\\"#FF6692\\\",\\\"#B6E880\\\",\\\"#FF97FF\\\",\\\"#FECB52\\\"],\\\"font\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"hovermode\\\":\\\"closest\\\",\\\"hoverlabel\\\":{\\\"align\\\":\\\"left\\\"},\\\"paper_bgcolor\\\":\\\"white\\\",\\\"plot_bgcolor\\\":\\\"#E5ECF6\\\",\\\"polar\\\":{\\\"bgcolor\\\":\\\"#E5ECF6\\\",\\\"angularaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"radialaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"}},\\\"ternary\\\":{\\\"bgcolor\\\":\\\"#E5ECF6\\\",\\\"aaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"baxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"caxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"}},\\\"coloraxis\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}},\\\"colorscale\\\":{\\\"sequential\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]],\\\"sequentialminus\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]],\\\"diverging\\\":[[0,\\\"#8e0152\\\"],[0.1,\\\"#c51b7d\\\"],[0.2,\\\"#de77ae\\\"],[0.3,\\\"#f1b6da\\\"],[0.4,\\\"#fde0ef\\\"],[0.5,\\\"#f7f7f7\\\"],[0.6,\\\"#e6f5d0\\\"],[0.7,\\\"#b8e186\\\"],[0.8,\\\"#7fbc41\\\"],[0.9,\\\"#4d9221\\\"],[1,\\\"#276419\\\"]]},\\\"xaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\",\\\"title\\\":{\\\"standoff\\\":15},\\\"zerolinecolor\\\":\\\"white\\\",\\\"automargin\\\":true,\\\"zerolinewidth\\\":2},\\\"yaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\",\\\"title\\\":{\\\"standoff\\\":15},\\\"zerolinecolor\\\":\\\"white\\\",\\\"automargin\\\":true,\\\"zerolinewidth\\\":2},\\\"scene\\\":{\\\"xaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2},\\\"yaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2},\\\"zaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2}},\\\"shapedefaults\\\":{\\\"line\\\":{\\\"color\\\":\\\"#2a3f5f\\\"}},\\\"annotationdefaults\\\":{\\\"arrowcolor\\\":\\\"#2a3f5f\\\",\\\"arrowhead\\\":0,\\\"arrowwidth\\\":1},\\\"geo\\\":{\\\"bgcolor\\\":\\\"white\\\",\\\"landcolor\\\":\\\"#E5ECF6\\\",\\\"subunitcolor\\\":\\\"white\\\",\\\"showland\\\":true,\\\"showlakes\\\":true,\\\"lakecolor\\\":\\\"white\\\"},\\\"title\\\":{\\\"x\\\":0.05},\\\"mapbox\\\":{\\\"style\\\":\\\"light\\\"}}}},                        {\\\"responsive\\\": true}                    ).then(function(){\\n\",\n       \"                            \\n\",\n       \"var gd = document.getElementById('cc5330c4-06a3-4a25-983d-1e42f2aad1ba');\\n\",\n       \"var x = new MutationObserver(function (mutations, observer) {{\\n\",\n       \"        var display = window.getComputedStyle(gd).display;\\n\",\n       \"        if (!display || display === 'none') {{\\n\",\n       \"            console.log([gd, 'removed!']);\\n\",\n       \"            Plotly.purge(gd);\\n\",\n       \"            observer.disconnect();\\n\",\n       \"        }}\\n\",\n       \"}});\\n\",\n       \"\\n\",\n       \"// Listen for the removal of the full notebook cells\\n\",\n       \"var notebookContainer = gd.closest('#notebook-container');\\n\",\n       \"if (notebookContainer) {{\\n\",\n       \"    x.observe(notebookContainer, {childList: true});\\n\",\n       \"}}\\n\",\n       \"\\n\",\n       \"// Listen for the clearing of the current output cell\\n\",\n       \"var outputEl = gd.closest('.output');\\n\",\n       \"if (outputEl) {{\\n\",\n       \"    x.observe(outputEl, {childList: true});\\n\",\n       \"}}\\n\",\n       \"\\n\",\n       \"                        })                };                });            </script>        </div>\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"pgm = PGM(mirror=Plane_Mirror(), grating = Grating())\\n\",\n    \"pgm.energy = 1200\\n\",\n    \"pgm.cff=1.4\\n\",\n    \"pgm.grating.compute_angles()\\n\",\n    \"pgm.set_theta()\\n\",\n    \"m_corners = pgm.mirror_corners()\\n\",\n    \"g_corners = pgm.grating_corners()\\n\",\n    \"m_corners = np.array(m_corners)\\n\",\n    \"grating_corners = np.array(pgm.grating_corners())\\n\",\n    \"mirror_corners = np.array(pgm.mirror_corners())\\n\",\n    \"pgm.generate_rays()\\n\",\n    \"_, mirror_int_1, grating_int_1 =  pgm.propagate(pgm.rays[1])\\n\",\n    \"_, mirror_int_2, grating_int_2 =  pgm.propagate(pgm.rays[2])\\n\",\n    \"_, mirror_int_3, grating_int_3 =  pgm.propagate(pgm.rays[3])\\n\",\n    \"_, mirror_int_4, grating_int_4 =  pgm.propagate(pgm.rays[4])\\n\",\n    \"\\n\",\n    \"mirror_intercepts = [\\n\",\n    \"    mirror_int_1[0].to_point(),\\n\",\n    \"    mirror_int_2[0].to_point(),\\n\",\n    \"    mirror_int_3[0].to_point(),\\n\",\n    \"    mirror_int_4[0].to_point()\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"grating_intercepts = [\\n\",\n    \"    grating_int_1[0].to_point(),\\n\",\n    \"    grating_int_2[0].to_point(),\\n\",\n    \"    grating_int_3[0].to_point(),\\n\",\n    \"    grating_int_4[0].to_point()\\n\",\n    \"]\\n\",\n    \"\\n\",\n    \"mirror_footprint_width, mirror_footprint_height = pgm.calc_footprint_size(mirror_intercepts)\\n\",\n    \"grating_footprint_width, grating_footprint_height = pgm.calc_footprint_size(grating_intercepts)\\n\",\n    \"#print(\\\"Mirror footprint width:\\\", mirror_footprint_width)\\n\",\n    \"# print(\\\"Mirror footprint height:\\\", mirror_footprint_height)\\n\",\n    \"#print(\\\"Grating footprint width:\\\", grating_footprint_width)\\n\",\n    \"# print(\\\"Grating footprint height:\\\", grating_footprint_height)\\n\",\n    \"\\n\",\n    \"mirr_footprint_corners = np.array([\\n\",\n    \"    [mirror_int_2[0].z, mirror_int_3[0].x],\\n\",\n    \"    [mirror_int_1[0].z, mirror_int_3[0].x],\\n\",\n    \"    [mirror_int_1[0].z, mirror_int_4[0].x],\\n\",\n    \"    [mirror_int_2[0].z, mirror_int_4[0].x]\\n\",\n    \"])\\n\",\n    \"\\n\",\n    \"grating_footprint_corners = np.array([\\n\",\n    \"    [grating_int_2[0].z, grating_int_3[0].x],\\n\",\n    \"    [grating_int_1[0].z, grating_int_3[0].x],\\n\",\n    \"    [grating_int_1[0].z, grating_int_4[0].x],\\n\",\n    \"    [grating_int_2[0].z, grating_int_4[0].x]\\n\",\n    \"])\\n\",\n    \"\\n\",\n    \"offset = 0.5*(pgm.mirror._width() + pgm.grating._width())* np.array([\\n\",\n    \"    [0,1],\\n\",\n    \"    [0,1],\\n\",\n    \"    [0,1],\\n\",\n    \"    [0,1]\\n\",\n    \"])\\n\",\n    \"\\n\",\n    \"grating_corners = grating_corners + offset\\n\",\n    \"grating_footprint_corners = grating_footprint_corners + offset\\n\",\n    \"\\n\",\n    \"fig = go.Figure(layout={'showlegend':False, 'xaxis':{'range':(min(mirror_corners[:,0])-50,max(grating_corners[:,1])+50)}, 'height':500})\\n\",\n    \"fig.add_trace(go.Scatter(x=mirror_corners[:,0], y=mirror_corners[:,1],fill='toself',fillcolor='red',line={\\\"color\\\":'red'}, marker={'size':0}, name='Mirror'))\\n\",\n    \"fig.add_trace(go.Scatter(x=grating_corners[:,0], y=grating_corners[:,1],fill='toself',fillcolor='blue',line={\\\"color\\\":'blue'}, marker={'size':0}, name='Grating'))\\n\",\n    \"fig.add_trace(go.Scatter(x=mirr_footprint_corners[:,0], y=mirr_footprint_corners[:,1],fill='toself',fillcolor='green',line={\\\"color\\\":'green'}, marker={'size':0}, name='Beam Footprint on Mirror'))\\n\",\n    \"fig.add_trace(go.Scatter(x=grating_footprint_corners[:,0], y=grating_footprint_corners[:,1],fill='toself',fillcolor='green',line={\\\"color\\\":'green'}, marker={'size':0}, name='Beam Footprint on Grating'))\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"7c6c5f05-7e12-48d0-95ec-54d35c4d286a\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3 (ipykernel)\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.9\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n", "type": "text"}, {"name": "__init__.py", "content": "", "type": "text"}, {"name": "default.pgm", "content": "[core]\nenergy=500\ncff=1.4\norder=1\n\n[beam]\ncalculate_from_id=false\nvert_electron_size=50\nvert_electron_div=20\ndistance=15\nid_length=2\nnum_of_sigmas=5\nbeam_height=5\nbeam_width=5\n\n[mirror]\nlength=450\nwidth=40\nheight=40\n\n[grating]\nlength=450\nwidth=40\nheight=40\nline_density=400\n\n[offsets]\nbeam_vertical_offset=-18\nmirror_horizontal_offset=0\ncalculate_offsets=true\n#mirror_vertical_offset=13\n#mirror_axis_horizontal_offset=12\n#mirror_axis_vertical_offset=6.3523\n", "type": "text"}, {"name": "deploy.sh", "content": "git pull\nkubectl cp ./landing_pages/* pgmtool-nginx-deployment-785fb44df8-ft9wb:/usr/share/nginx/html\nkubectl cp ./site/* pgmtool-nginx-deployment-785fb44df8-ft9wb:/usr/share/nginx/html/app\n", "type": "text"}, {"name": "requirements.txt", "content": "faicons\nshiny\npyplanemono_minimal", "type": "text"}, {"name": "shared.py", "content": "from pathlib import Path\napp_dir = Path(__file__).parent\n", "type": "text"}, {"name": "styles.css", "content": ":root {\n  --bslib-sidebar-main-bg: #f8f8f8;\n}", "type": "text"}, {"name": "pyplanemono_minimal\\LICENSE", "content": "MIT License\nCopyright (c) 2023 Patrick Yuheng Wang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", "type": "text"}, {"name": "pyplanemono_minimal\\README.md", "content": "# pyplanemono-minimal\n\nThis is a minimised version of the PyPlaneMono project, which is a calculation suite for the geometry of the plane grating monochromator. This repository contains only only the core calculation and visualisation functionalities and no GUI components\nand is not capable of interacting with SHADOW as a pre-processor. For full functionality, refer to pyplanemono. This is meant to be distributed with the online interface of the PyPlaneMono project with maximum portability.\n\n", "type": "text"}, {"name": "pyplanemono_minimal\\__init__.py", "content": "", "type": "text"}, {"name": "pyplanemono_minimal\\pyproject.toml", "content": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"pyplanemono_minimal\"\nversion = \"1.0\"\nauthors = [\n  { name=\"Patrick Wang\", email=\"patrick.wang@diamond.ac.uk\" },\n]\ndescription = \"X-ray tracing for plane grating monochromator. Minimal version with no interface to SHADOW.\"\nreadme = \"README.md\"\nrequires-python = \">=3.8.0\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\ndependencies = [\n    \"numpy >= 1.23.0\",\n    \"scipy >= 1.8.1\",\n    \"matplotlib >= 3.5.2\",\n]\n\n[tool.setuptools]\n\npackages = [\"pyplanemono_minimal\",\"pyplanemono_minimal.elements\",\"pyplanemono_minimal.geometry\"]\n\n", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\__init__.py", "content": "from .mirror import *\nfrom .grating import *\nfrom .pgm import *", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\grating.py", "content": "from __future__ import annotations\nimport numpy as np\nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Plane, Ray3D\nfrom scipy.constants import c, h, e\n\n\nclass Grating(object):\n    \"\"\"\n    A class for a simple grating\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    dimensions : array_like\n        The dimensions of the grating in mm [length, width, height],\n        dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    \n    Attributes\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    alpha : float\n        The incident angle of the beam in degrees\n    beta : float    \n        The diffraction angle of the beam in degrees\n    dimensions : array_like\n        The dimensions of the grating in mm\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    Methods\n    -------\n    set_angles(alpha, beta)\n        Set the incident and diffraction angles of the grating\n    energy_to_wavelength()\n        Calculate the wavelength of the beam in Angstroms\n    compute_corners()\n        Compute the corners of the grating in the global coordinate system\n    diffract(*args)\n        A method to diffract rays off the grating\n    compute_beta(alpha, line_density, energy, order)\n        Calculate the diffraction angle beta from the incident angle alpha\n    reflect(*args)\n        A method to 'reflect' rays off the grating\n    \"\"\"\n    # Run a code formatter and linter to fix code style adn syntax errors. Black & Falke8 are good for this.\n    def __init__(self, \n                 line_density=600, \n                 energy=2400, \n                 cff=2, \n                 order=1, \n                 dimensions = np.array([200,40,50]), \n                 borders = np.array([0,0,0,0])):\n\n        self._line_density=line_density\n        self._energy=energy\n        self._cff=cff\n        self._order=order\n        self._alpha = None\n        self._beta = None\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._borders = borders\n        _,_ = self.compute_angles()\n        _ = self.compute_corners()\n\n\n\n    def __repr__(self):\n        # Use f-strings\n        return f\"Grating(line_density={self.line_density},\\n energy={self.energy}, \\n cff={self.cff}, \\n order={self.order}, \\n dimensions={self.dimensions},\\n borders={self.borders})\"\n    \n    def read_file(self, filename):\n        \"\"\"\n        Read grating parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['grating']) != 6:\n            # You could add config['grating'] into the error message\n            raise ValueError(\"Expected exactly five parameters in grating file\")\n\n        # Could use tuple instead of list\n        variables = ('line_density', 'energy', 'cff', 'order', 'dimensions')\n        for var in variables:\n            if var not in config['grating']:\n                raise ValueError(\"Missing parameter {} in grating file\".format(var))\n            \n        # You already check if variables in config['grating'] above and repeat below.\n        # Could use sets to create items from variable and config['grating'] to avoid list comprehension.\n        items = [x for x in variables if x in config['grating'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['grating'].values()):\n            setattr(self, key, value)\n            print(key)\n            print(value)\n        \n        self._order = int(self._order)\n        self._dimensions = np.array([float(x) for x in config['grating']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['grating']['borders'].split(',')])\n\n    @property\n    def line_density(self)-> float:\n        return self._line_density\n    \n    @line_density.setter\n    def line_density(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive line density\")\n        else:\n            self._line_density = value\n\n    @property\n    def energy(self)-> float:\n        return self._energy\n    \n    @energy.setter\n    def energy(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive energy\")\n        else:\n            self._energy = value\n        \n    @property\n    def cff(self)-> float:\n        return self._cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if value <= 1:\n            raise ValueError(\"Expected positive cff\")\n        else:\n            self._cff = value\n    \n    @property\n    def order(self)-> int:\n        return int(self._order)\n    \n    @order.setter\n    def order(self, value: int)-> None:\n        if value >= 1 and isinstance(value, int):\n            self._order = value\n            print(\"order set!\")\n        else:\n            raise ValueError(\"Expected positive integer order\")\n\n    @property\n    def alpha(self)-> float:   \n        return self._alpha\n    \n    @alpha.setter\n    def alpha(self, value)-> None:\n        if np.abs(value) <= 180 and isinstance(value, (float, int)):\n            self._alpha = value\n        else:\n            raise ValueError(\"Expected float alpha with magnitude less than 180 degrees\")\n\n    @property\n    def beta(self)-> float:\n        return self._beta\n    \n    @beta.setter\n    def beta(self, value: float)-> None:\n        self._beta = value\n    \n    @property\n    def dimensions(self):\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value):\n        if len(value) != 3:\n            raise ValueError(\"Expected exactly three values for dimensions\")\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._grating_plane\n    \n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._grating_plane = value\n        else:\n            raise TypeError(\"Expected Plane object for plane\")\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value: np.ndarray)-> None:\n        if len(value) != 4 or not isinstance(value, np.ndarray):\n            raise ValueError(\"Expected exactly 1D array of length 4 for borders\")\n        else:\n            self._borders = value\n\n\n    def set_angles(self, alpha: float, beta: float)-> None:\n        \"\"\"\n        Set the incident and diffraction angles of the grating.\n\n        Parameters\n        ----------\n        alpha : float\n            The incident angle in degrees\n        beta : float \n            The diffraction angle in degrees\n\n        Raises\n        ------\n        ValueError\n            If the wavelength is zero\n\n        \"\"\"\n        wavelength = (np.sin(np.deg2rad(alpha)) + np.sin(np.deg2rad(beta))) / (self.line_density*1000*self._order)\n        \n        if wavelength <= 0:\n            raise ValueError(\"Expected positive, non-zero wavelength\")\n\n        else:\n            self._energy = 12398.42 / wavelength #converts wavelength to eV\n        \n        self._alpha = alpha\n        self._beta = beta\n        self._cff = self.cff\n\n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value:any)-> None:\n        print(\"Input ignored, corners are computed from dimensions\")\n        self._corners = self.compute_corners()\n\n    def compute_beta(self)-> float:\n        \"\"\"\n        Compute the diffraction angle beta from the incident angle alpha.\n\n        Returns\n        -------\n        beta : float\n            The diffraction angle in degrees\n        \n    \n        \"\"\"\n        beta = 0\n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        u = self.order*self.line_density*1000*wavelength - np.sin(np.deg2rad(self.alpha))\n        beta = np.rad2deg(np.arcsin(u))\n        \n        \n        return beta\n\n    def compute_angles(self)-> tuple[float, float]:\n        \"\"\"\n        Compute the incident and diffraction angles of the grating.\n        The incident angle is calculated from the diffraction angle\n        using the fixed focus constant.\n\n        Returns\n        -------\n        alpha : float\n            The incident angle in degrees\n\n        beta : float\n            The diffraction angle in degrees\n        \n        \"\"\"\n        \n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        print(self.energy,\n              self.order,\n                self.line_density,\n                self.cff,\n               wavelength)\n        \n        lambda_u = self.order*self.line_density*1000*wavelength/(1-self.cff**2)\n        sin_alpha = lambda_u + np.sqrt(1+lambda_u**2*self.cff**2)\n        self._alpha = np.rad2deg(np.arcsin(sin_alpha))\n        self._beta = -np.rad2deg(np.arccos(np.cos(np.arcsin(sin_alpha))*self.cff))\n\n        return self._alpha, self._beta\n\n    # Could add type annotations on all your functions\n    def diffract(self, *args: Ray3D | list )-> list:\n        \"\"\"\n        A method to diffract rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be diffracted\n\n        Returns\n        -------\n        diffracted_rays : list of Ray3D\n            A list of diffracted rays\n\n        Raises\n        ------\n        raises ValueError too\n        TypeError\n            If the rays are not Ray3D objects\n\n        \"\"\"\n        diffracted_rays = []\n        \n\n        if isinstance(args[0], list):\n            args = args[0]\n\n        elif len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n\n        for _, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            raydotplane = ray.vector.dot(self._grating_plane.normal)\n            angle = np.arccos(raydotplane/np.linalg.norm(self._grating_plane.normal))\n            alpha = np.rad2deg(np.pi/2-angle)\n            beta = self.compute_beta()\n            diff_ray = self.reflect(ray)[0]\n            angle = -90 - beta - alpha\n            diff_ray.vector[2] += np.cos(np.deg2rad(angle))\n            diff_ray.vector[1] += np.sin(np.deg2rad(angle))\n            diff_ray.vector = diff_ray.vector/np.linalg.norm(diff_ray.vector)\n            diffracted_rays.append(diff_ray)\n        return diffracted_rays\n    \n    \n\n    # rename something like energy_to_wavelength\n    def energy_to_wavelength(self, energy: float)-> float:\n        return h*c/(e*energy)\n    \n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the grating in the global coordinate system.\n\n        Returns\n        -------\n        corners : array_like\n            The corners of the grating in the global coordinate system:\n            [bottom left back, \n            bottom right back, \n            bottom left front, \n            bottom right front,\n            top left back,\n            top right back,\n            top left front,\n            top right front]\n        \"\"\"\n        \n        beta = np.deg2rad(self._beta)\n        # beta_g not used\n        beta_g = np.deg2rad(self._beta + 90)\n        l = self._length()\n        w = self._width()\n        d = self._height()        \n        #Bottom left back\n        blbz = (l/2)*np.sin(beta)\n        blby = -(l/2)*np.cos(beta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        #Bottom left front\n        blfz = -(l/2)*np.sin(beta)\n        blfy = (l/2)*np.cos(beta)\n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = blbz - d*np.cos(beta)\n        tlby = blby - d*np.sin(beta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Top right back\n        trbz = brbz - d*np.cos(beta)\n        trby = brby - d*np.sin(beta)\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Top left front\n        tlfz = blfz - d*np.cos(beta)\n        tlfy = blfy - d*np.sin(beta)\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Top right front\n        trfz = brfz - d*np.cos(beta)\n        trfy = brfy - d*np.sin(beta)\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        self._grating_plane = Plane(\n            Point3D(blfx, blfy, blfz),\n            Point3D(brfx, brfy, brfz),\n            Point3D(blbx, blby, blbz)\n        )\n\n        self._corners = np.array([\n            blb,\n            brb,\n            blf,\n            brf,\n            tlb,\n            trb,\n            tlf,\n            trf\n        ])\n\n        return self._corners\n\n    def reflect(self, *args, zero_order = False)-> list:\n        \"\"\"\n        A method to reflect rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        # Check after determining if list\n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        # se isinstance\n        if type(args[0]) == list:\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._grating_plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect grating, tread with caution!')\n                continue\n            ray_array = ray.vector\n            grating_normal = self._grating_plane.normal\n            if zero_order:\n                \n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, -grating_normal) * grating_normal\n            else:\n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, grating_normal) * grating_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n\n    @classmethod\n    def grating_from_file(cls, filename):\n        \"\"\"\n        Create a grating from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        grating = cls()\n        grating.read_file(filename)\n        return grating\n    \n", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\mirror.py", "content": "from __future__ import annotations\n# List not used\nfrom ast import List\nfrom matplotlib.pyplot import isinteractive\nimport numpy as np\nfrom pyplanemono_minimal.geometry import Point3D, Vector3D, Plane, Ray3D\nimport configparser\n\nclass Plane_Mirror(object):\n    \"\"\"\n    A class for a simple plane mirror.\n\n    Parameters\n    ----------\n    voffset : float, optional\n        The vertical offset of the mirror in mm\n    hoffset : float, optional\n        The horizontal offset of the mirror in mm\n    axis_voffset : float, optional\n        The vertical offset of the mirror axis in mm\n    axis_hoffset : float, optional\n        The horizontal offset of the mirror axis in mm\n    dimensions : array_like, optional\n        The dimensions of the mirror in mm [length, width, height]\n        Dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    theta : float, optional\n        The angle of the mirror in degrees\n    plane : Plane, optional\n        The plane of the mirror\n    borders: array_like, optional\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    \n\n    Attributes\n    ----------\n    dimensions : array_like\n        The dimensions of the mirror in mm\n    position : Point3D\n        The position of the mirror\n    normal : Vector3D\n        The normal vector of the mirror\n    orientation : Vector3D\n        The orientation of the mirror\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    plane : Plane\n        The plane of the mirror\n    \n    borders: array_like\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    Methods\n    -------\n    set_position(position)\n        Set the position of the mirror\n    set_normal(normal)\n        Set the normal vector of the mirror\n    set_orientation(orientation)\n        Set the orientation of the mirror\n    set_dimensions(*args)\n        Set the dimensions of the mirror\n    set_offsets(voffset, hoffset, axis_voffset, axis_hoffset)\n        Set the offsets of the mirror\n    compute_corners()\n        Compute the corners of the mirror in the global coordinate system,  \n    \n    \n    \"\"\"\n\n    def __init__(self, \n                 voffset=13, \n                 hoffset=40, \n                 axis_voffset=6.5, \n                 axis_hoffset=0, \n                 dimensions = np.array([450, 70, 50]),\n                 theta=45, \n                 plane=Plane(),\n                 borders = np.array([0,0,0,0])\n                 ):\n        \"\"\"\n        Constructor for the Plane_Mirror class.\n\n        Parameters\n        ----------\n        voffset : float\n            The vertical offset of the mirror in mm\n        hoffset : float\n            The horizontal offset of the mirror in mm\n        axis_voffset : float\n            The vertical offset of the mirror axis in mm\n        axis_hoffset : float\n            The horizontal offset of the mirror axis in mm\n        dimensions : array_like\n            The dimensions of the mirror in mm [length, width, height]\n            Dimensions are also accessible with lambda functions as:\n            self._length(), self._width(), self._height()\n\n        \n        theta : float\n            The angle of the mirror in degrees\n        plane : Plane\n            The plane of the mirror\n        \n        \"\"\"\n\n        self._voffset = voffset\n        self._hoffset = hoffset\n        self._axis_voffset = axis_voffset\n        self._axis_hoffset = axis_hoffset\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._plane = plane\n        self._theta = theta\n        # Just call method without assigning to _\n        _ = self.compute_corners()\n        self._borders = borders\n\n\n    def __repr__(self):\n        # Use f-string\n        return \"\"\"Plane_Mirror(voffset={}, \n        hoffset={}, \n        axis_voffset={}, \n        axis_hoffset={}, \n        length={}, \n        width={}, \n        height={}, \n        plane={},\n        borders={})\n        \"\"\".format(self.voffset,\n                            self.hoffset, \n                            self.axis_voffset, \n                            self.axis_hoffset, \n                            self._length(), \n                            self._width(), \n                            self._height(), \n                            self.plane,\n                            self.borders)\n    \n\n    # read_file is very similar to read_file in grating.py. Refactor to use common code.\n    def read_file(self, filename):\n        \"\"\"\n        Read mirror parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['mirror']) != 7:\n            raise ValueError(\"Expected exactly six parameters in mirror file\")\n\n        variables = ['voffset', 'hoffset', 'axis_voffset', 'axis_hoffset', 'dimensions', 'theta']\n        for var in variables:\n            if var not in config['mirror']:\n                raise ValueError(\"Missing parameter {} in mirror file\".format(var))\n        \n        items = [x for x in variables if x in config['mirror'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['mirror'].values()):\n            # Don't use exec. Either explicitly assign variables or if you will not know what they will be, use a dictionary not variables.\n            exec(f\"self._{key} = float({value})\")\n            print(key)\n            print(value)\n        \n        \n        self._dimensions = np.array([float(x) for x in config['mirror']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['mirror']['borders'].split(',')])\n        \n\n    @property\n    def voffset(self)-> float:\n\n        return self._voffset\n\n    @voffset.setter\n    def voffset(self, value: float)-> None:\n        if isinstance(value, float):\n            self._voffset = value  \n        else:\n            raise TypeError(\"Expected voffset to be float!\")\n    @property\n    def a(self)-> float:\n        return self._hoffset\n    \n    @a.setter\n    def a(self, value: float)-> None:\n        self.hoffset = float(value)\n\n    @property\n    def hoffset(self)-> float:\n        return self._hoffset\n\n    @hoffset.setter\n    def hoffset(self, value: float):\n        if isinstance(value, float):\n            self._hoffset = value\n        else:\n            raise TypeError(\"Expected hoffset to be float!\")\n\n    @property\n    def c(self)-> float:\n        return self._voffset\n    \n    @c.setter\n    def c(self, value: float)-> None:\n        self.voffset = float(value)\n\n    \n\n    @property\n    def axis_voffset(self)-> float:\n        return self._axis_voffset\n\n    @axis_voffset.setter\n    def axis_voffset(self, value: float):\n        if isinstance(value, float):\n            self._axis_voffset = value\n        else:\n            raise TypeError(\"Expected axis voffset to be float!\")\n\n    @property\n    def v(self)-> float:\n        return self._axis_voffset\n    \n    @v.setter\n    def v(self, value: float)-> None:\n        self.axis_voffset = float(value)\n\n\n    @property\n    def axis_hoffset(self)-> float:\n        return self._axis_hoffset\n\n    @axis_hoffset.setter\n    def axis_hoffset(self, value:float):\n        if isinstance(value, float):\n            self._axis_hoffset = value\n        else:\n            raise TypeError(\"Expected axis hoffset to be float!\")\n\n    @property\n    def h(self)-> float:\n        return self._axis_hoffset\n    \n    @h.setter\n    def h(self, value: float)-> None:\n        self.axis_hoffset = float(value)\n    \n\n    @property\n    def dimensions(self)-> np.ndarray:\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value:float):\n        \"\"\"\n        Sets the dimensions of the mirror.\n        The dimensions are specified as:\n        [length, width, height]\n\n        \"\"\"\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._plane\n\n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._plane = value\n        else:\n            raise TypeError(\"Expected value to be Plane instance!\")\n    \n    @property\n    def theta(self)-> float:\n        return self._theta\n    \n    @theta.setter\n    def theta(self, value: float)-> float:\n        self._theta = value\n    \n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value):\n        print(\"Input value ignored, corners computed from parameters!\")\n        self.compute_corners()\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value)-> None:\n        \"\"\"\n        Sets the borders of the mirror.\n        The borders are specified as:\n        |-----------Top------------|\n        |                          |\n         Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n        \"\"\"\n        if isinstance(value, np.ndarray) and len(value)==4:\n            if all(value > 0):\n                self._borders = value\n            else:\n                raise ValueError(\"Lengths should be positive.\")\n        else:\n            raise ValueError(\"Expected 1D numpy array with length 4\")\n\n\n    def set_position(self, position: Point3D)-> None:\n        if isinstance(position, Point3D):\n            self._plane.position = position\n        else:\n            raise TypeError(\"Expected Point3D instance for position value!\")\n\n    def set_normal(self, normal: Vector3D)-> None:\n        if isinstance(normal, Vector3D):\n            self._plane.normal = normal\n        else:\n            raise TypeError(\"Expected Vector3D instance for normal value!\")\n\n    # Combine with setter\n    def set_dimensions(self, *args: np.ndarray | float)-> None:\n        \"\"\"\n        Set the dimensions of the mirror.\n\n        Parameters\n        ----------\n        *args : array_like\n            Either one or three arguments for the dimensions\n\n        Raises\n        ------\n        ValueError\n            If the number of arguments is not one or three\n\n        \"\"\"\n        # compute length once and assign to variable. Can use this in error msg.\n        # Will raise ValueError if args does not have length, so check that too.\n        length_of_args = len(args)\n        if length_of_args == 1:\n            self._dimensions = args[0]\n        elif length_of_args == 3:\n            self._dimensions = np.array(args)\n        else:\n            raise ValueError(f\"Expected either one or three arguments for dimensions, got length of {length_of_args} instead.\")\n\n    def set_offsets(self, voffset: float, hoffset: float, axis_voffset: float, axis_hoffset: float)-> None:\n        self.voffset(voffset)\n        self.hoffset(hoffset)\n        self.axis_voffset(axis_voffset)\n        self.axis_hoffset(axis_hoffset)\n\n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the mirror in the global coordinate system,\n        in addition to the plane and normal of the mirror.\n    \n\n        Returns\n        -------\n        corners : np.ndarray\n            The corners of the mirror in the global coordinate system\n            [top left front,\n            top right front,\n            bottom left front,\n            bottom right front,\n            top left back,\n            top right back,\n            bottom left back,\n            bottom right back]\n        \n        \n        \"\"\"\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.theta)\n        theta_g = 90 - self._theta\n        theta_g = np.deg2rad(theta_g)\n        a = self._hoffset\n        c = self._voffset\n        v = self._axis_voffset\n        h = self._axis_hoffset\n        w = self._width()\n        l = self._length()\n        d = self._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Bottom left front\n        blfz = tlfz + d*np.cos(theta)\n        blfy = tlfy - d*np.sin(theta)        \n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Bottom left back\n        blbz = tlbz + d*np.cos(theta)\n        blby = tlby - d*np.sin(theta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        self._plane = Plane(tlf, trf, tlb)\n\n        self._corners = np.array([\n            tlf,\n            trf,\n            blf,\n            brf,\n            tlb,\n            trb,\n            blb,\n            brb\n        ])\n\n        return self._corners\n\n    @classmethod\n\n    def mirror_from_file(cls, filename: str)-> Plane_Mirror:\n        \"\"\"\n        Create a mirror from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        mirror = cls()\n        mirror.read_file(filename)\n        return mirror\n\n    def reflect(self, *args: Ray3D | list) -> list:\n        \"\"\"\n        A method to reflect rays off the mirror.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list of Ray3D\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        if isinstance(args[0], list):\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect mirror, tread with caution!')\n                continue\n            ray_array = ray.vector\n            mirror_normal = self._plane.normal\n            reflected_ray_array = ray_array - 2 * np.dot(ray_array, mirror_normal) * mirror_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\pgm.py", "content": "from __future__ import annotations\nfrom matplotlib.axes import Axes\nimport numpy as np\nfrom matplotlib.patches import Patch \nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Ray3D\nfrom scipy.spatial import ConvexHull\nfrom matplotlib.lines import Line2D\nfrom pyplanemono_minimal.elements import Plane_Mirror, Grating\n\nclass PGM(object):\n    \"\"\"\n    A class for a PGM setup.\n\n    Parameters\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n\n    Attributes\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n    rays : list\n        The rays to be propagated through the PGM\n    beam_offset : float\n        The vertical offset of the beam in mm\n    beam_width : float\n        The width of the beam in mm\n    beam_height : float\n        The height of the beam in mm\n    \n    Methods\n    -------\n    read_file(filename)\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n    propagate(*args)\n        Propagate rays through the PGM setup.\n    draw_sideview(ax)\n        Draws the setup on a y-z projection on a given axis.\n    draw_topview(ax)\n        Draws the setup on a x-z projection on a given axis, along with the beam footprints.\n    \"\"\"\n\n    def __init__(self, grating = None, mirror = None, **kwargs):\n        \"\"\"\n        \n        Constructor for the PGM class.\n        \n        Parameters\n        ----------\n        grating : Grating\n            The grating component of the PGM\n        mirror : Plane_Mirror\n            The mirror component of the PGM\n        **kwargs : \n            Keyword arguments for the grating and mirror components.\n            See Grating and Plane_Mirror classes for details.\n\n        \n        \"\"\"\n        # It's unclear what is happening here and there will be uncaught errors if kwargs is not as expected.\n        if grating is None:\n            grating_kwargs = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'grating_dimensions'\n            ]\n            grating_kwarg_keys = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'dimensions'\n            ]\n        \n            grating_args = [kwargs.get(x) for x in grating_kwargs]\n            grating_kwargs = dict(zip(grating_kwarg_keys, grating_args))\n            self._grating = Grating(**grating_kwargs)\n\n        else:\n            self._grating = grating\n        \n        if mirror is None:\n            mirror_kwargs = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'mirror_dimensions',\n                'theta'\n            ]\n            mirror_kwarg_keys = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'dimensions',\n                'theta'\n            ]\n        \n            mirror_args = [kwargs.get(x) for x in mirror_kwargs]\n            mirror_kwargs = dict(zip(mirror_kwarg_keys, mirror_args))\n            self._mirror = Plane_Mirror(**mirror_kwargs)\n            \n        else:\n            self._mirror = mirror\n\n        \n        self._rays = []\n        self._beam_offset = 13\n        self._beam_width = 6.43\n        self._beam_height = 5\n        self._energy = 2400\n\n    def __repr__(self):\n        return \"\"\"PGM(grating={}, \\nmirror={}, \\nb={},\\nbeam_width={},\\nbeam_height={})\"\"\".format(self.grating, \n                                                               self.mirror,\n                                                               self.beam_offset,\n                                                               self.beam_width,\n                                                               self.beam_height)\n    \n    def generate_rays(self):\n        \"\"\"\n        Generate rays for the PGM setup.\n        \"\"\"\n        \n        r0 = Ray3D(Point3D(0, self.beam_offset, -1000),\n                   Point3D(0, self.beam_offset, 0)-\n                   Point3D(0, self.beam_offset, -1000))\n        \n        r1 = Ray3D(Point3D(0, self.beam_offset + self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset + self.beam_height/2, 0)-\n                     Point3D(0, self.beam_offset + self.beam_height/2, -1000)\n                   )\n\n        r2 = Ray3D(Point3D(0, self.beam_offset - self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset - self.beam_height/2, 0) -\n                   Point3D(0, self.beam_offset - self.beam_height/2, -1000))\n\n        r3 = Ray3D(Point3D(-self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(-self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(-self.beam_width/2, self.beam_offset, -1000))\n\n        r4 = Ray3D(Point3D(self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(self.beam_width/2, self.beam_offset, -1000))\n\n        self._rays = [r0, r1, r2, r3, r4]\n\n\n    def read_file(self, filename):\n        \"\"\"\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        \n        self._grating.read_file(filename)\n        self._mirror.read_file(filename)\n        pgm_config = configparser.ConfigParser()\n        pgm_config.read(filename)\n        self._energy = float(pgm_config['beam']['energy'])\n        self._beam_offset = float(pgm_config['beam']['beam_offset'])\n        self._beam_width = float(pgm_config['beam']['beam_width'])\n        self._beam_height = float(pgm_config['beam']['beam_height'])\n    \n\n    def set_theta(self):\n        \"\"\"\n        Set the angle of the grating.\n        \"\"\"\n        self.mirror.theta = 0.5 * (self.grating.alpha-self.grating.beta)\n\n    @property\n\n    def theta(self):\n        return self.mirror.theta\n\n    @theta.setter\n\n    def theta(self, value):\n        self.theta = value\n        self.mirror.theta = value\n\n    @property\n\n    def energy(self):\n        return self.grating.energy\n    \n    @property\n    def wavelength(self):\n        return 1239.8419843320025/self.energy\n    \n    @energy.setter\n    # need validation for energy value, e.g. non-zero\n    def energy(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 0:\n            self.grating.energy = value\n        else:\n            print(value, type(value))\n            raise ValueError(\"Expected energy to be a positive float!\")\n    @property\n    def grating(self)-> Grating:\n        return self._grating\n    \n    @grating.setter\n    def grating(self, value: Grating)-> None:\n        if isinstance(value, Grating):\n            self._grating = value\n        else: \n            raise TypeError(\"Expected Grating instance for grating!\")\n    \n    @property\n    def mirror(self)-> Plane_Mirror:\n        return self._mirror\n    \n    @mirror.setter\n    def mirror(self, value: Plane_Mirror):\n        if isinstance(value, Plane_Mirror):\n            self._mirror = value\n        else:\n            raise TypeError(\"Expected Plane_Mirror instance for mirror!\")\n    @property\n    def rays(self)-> list[Ray3D]:\n        return self._rays\n    \n    @rays.setter\n    def rays(self, value: list[Ray3D])-> None:\n        self._rays = value\n    \n    @property\n    def beam_offset(self)-> float:\n        return -1*self._beam_offset\n    \n    @beam_offset.setter\n    def beam_offset(self, value: float)-> None:\n        if isinstance(value, (float, int)):\n            self._beam_offset = -1*value\n        else:\n            raise TypeError(\"Expected float for beam_offset!\")\n        \n    @property\n    def b(self)-> float:\n        return self._beam_offset\n    \n    @b.setter\n    def b(self, value: float)-> None:\n        self.beam_offset = value\n\n    @property\n    def beam_width(self)-> float:\n        return self._beam_width\n    \n    @beam_width.setter\n    def beam_width(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_width = value\n        else:\n            raise TypeError(\"Expected non-negative float for beam_width!\")\n    \n    @property\n    def beam_height(self)-> float:\n        return self._beam_height\n    \n    @beam_height.setter\n    def beam_height(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_height = value\n        else:\n            raise ValueError(\"Expected non-negative float for beam_height!\")\n\n\n    @property\n    def mirror_intercept(self)-> Point3D:\n        return self._mirror_intercept\n    \n    @property\n    def grating_intercept(self)-> Point3D:\n        return self._grating_intercept\n    \n    \n    @property\n    def cff(self)-> float:\n        return self.grating.cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 1:\n            self.grating.cff = value\n        else:\n            raise ValueError(\"Expected cff to be a positive float bigger than 1!\")\n\n    def values(self)-> dict:\n\n        dictionary = {'beam_vertical': self.beam_offset,\n                      'beam_width': self.beam_width,\n                      'beam_height': self.beam_height,\n                      'line_density': self.grating.line_density,\n                      'energy': self.grating.energy,\n                      'cff': self.grating.cff,\n                      'order': self.grating.order,\n                      'grating_dimensions': self.grating.dimensions,\n                      'grating.borders': self.grating.borders,\n                      'mirror_voffset': self.mirror.voffset,\n                      'mirror_hoffset': self.mirror.hoffset,\n                      'mirror_axis_voffset': self.mirror.axis_voffset,\n                      'mirror_axis_hoffset': self.mirror.axis_hoffset,\n                      'mirror_dimensions': self.mirror.dimensions,\n                      'mirror_theta': self.mirror.theta,\n                      'mirror_borders': self.mirror.borders}\n        return dictionary\n\n    @classmethod\n\n    def pgm_from_file(cls, filename:float)-> PGM:\n        \"\"\"\n        Create a PGM from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        pgm = cls()\n        pgm.read_file(filename)\n        return pgm\n\n    def propagate(self, *args: Ray3D | list)-> tuple:\n        \"\"\"\n        Propagate rays through the PGM setup.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be propagated\n        \n        Returns\n        -------\n        grating_ray : list of Ray3D objects\n            A list of propagated rays originating at the grating intercept\n        \n        mirror_intercept : list of array_like\n            A list of the mirror intercepts\n\n        grating_intercept : list of array_like\n            A list of the grating intercepts\n\n        \"\"\"\n        _ = self._mirror.compute_corners()\n        _ = self._grating.compute_corners()\n\n        mirr_ray = self._mirror.reflect(*args)\n        grating_ray = self._grating.diffract(*mirr_ray)\n        mirror_intercept = [mirr_ray.position for mirr_ray in mirr_ray]\n        grating_intercept = [grating_ray.position for grating_ray in grating_ray]\n        \n        # _mirror_intercept and _grating_intercept not defined in __init__\n        self._mirror_intercept = mirror_intercept\n        self._grating_intercept = grating_intercept\n        return grating_ray, mirror_intercept, grating_intercept\n\n\n    def draw_sideview(self, ax: Axes):\n        \"\"\"\n        Draws the setup on a y-z projection on a given axis.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes\n            The axis to draw on\n\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        grating_corners = self.grating.compute_corners()\n        mirror_corners_y, mirror_corners_z = mirror_corners[::2,1], mirror_corners[::2,2]\n        mirror_corners_yz = np.array([mirror_corners_z, mirror_corners_y]).T\n        # ConvexHull sp?\n        # ConvelHull method used to ensure the entire region is filled regardless\n        # of point order.\n        hull_grating = ConvexHull(mirror_corners_yz)\n\n        grating_corners_y, grating_corners_z = grating_corners[::2,1], grating_corners[::2,2]\n        grating_corners_yz = np.array([grating_corners_z, grating_corners_y]).T\n        hull_mirror = ConvexHull(grating_corners_yz)\n\n        ax.fill(mirror_corners_yz[hull_mirror.vertices,0], mirror_corners_yz[hull_mirror.vertices,1], 'r')\n        ax.fill(grating_corners_yz[hull_grating.vertices,0], grating_corners_yz[hull_grating.vertices,1], 'b')\n\n        self.generate_rays()\n        grating_ray, mirror_int, grating_int = self.propagate(self.rays)\n        #print(\"Side view r3 int:\", mirror_int[3])\n        for index, ray in enumerate(grating_ray):\n            r_z = np.array([\n            self.rays[index].position.z,\n            mirror_int[index].z,\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            self.rays[index].position.y,\n            mirror_int[index].y,\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='green', linewidth=1, label='Dispersed Rays')\n            ax.add_line(line)\n        \n        zero_order_rays = self.grating.reflect(self.rays, zero_order=True)\n\n        \"\"\"\n        for index, ray in enumerate(zero_order_rays):\n            r_z = np.array([\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='gray', linewidth=1, label='Zero Order Reflections')\n            ax.add_line(line)\n        \"\"\"\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n        ]\n        ax.legend(handles=legend_entries, loc = 'lower right', fontsize=16, fancybox=True, shadow=True)\n        ax.axhline(y=0, color='black', linestyle='--', linewidth=1.3)\n        ax.axvline(x=0, color='black', linestyle='--', linewidth=1.3)\n        \n    def draw_topview(self, ax: Axes)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        \n        self.generate_rays()\n        \n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        _, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        _, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        _, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        _, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n        #print(\"Mirror footprint width:\", mirror_footprint_width)\n       # print(\"Mirror footprint height:\", mirror_footprint_height)\n        #print(\"Grating footprint width:\", grating_footprint_width)\n       # print(\"Grating footprint height:\", grating_footprint_height)\n        \n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        ax.fill(mirror_corners[:,0], mirror_corners[:,1], 'r',alpha=1, label='Mirror')\n        ax.fill(grating_corners[:,0], grating_corners[:,1], 'b',alpha=0.5, label='Grating')\n        ax.fill(mirr_footprint_corners[:,0], mirr_footprint_corners[:,1], c='black')\n        ax.fill(grating_footprint_corners[:,0], grating_footprint_corners[:,1], c='green')\n        ax.grid(axis='both', which='both', alpha = 0.5)\n        ax.set_xticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xticks(np.arange(-1000, 1000, 100), minor=False)\n        ax.set_yticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xlim(min(mirror_corners[:,0]), max(grating_corners[:,0]))\n        ax.set_ylim(min(mirror_corners[:,1]), max(grating_corners[:,1]))\n        #ax.fill(mirror_rect_borders[:,0], mirror_rect_borders[:,1], 'r',alpha=0.5)\n        #ax.fill(m_corners[:,] , 'r',alpha=1)\n        #x.fill(grating_rect_borders[:,0], grating_rect_borders[:,1], 'b',alpha=1)\n        #ax.fill(grating_rect[:,0], grating_rect[:,1], 'b',alpha=0.5, label='Grating')\n        #ax.fill([mirror_blz, mirror_blz + mirror_l, mirror_blz + mirror_l, mirror_blz], [mirror_blx, mirror_blx, mirror_blx + mirror_w, mirror_blx + mirror_w], 'g', alpha=0.5, label='Beam Footprint')\n        #ax.fill([grating_blz, grating_blz + grating_l, grating_blz + grating_l, grating_blz], [grating_blx, grating_blx, grating_blx + grating_w, grating_blx + grating_w], 'g', alpha=0.5)\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n            Patch(facecolor=(0,0,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Mirror): {mirror_footprint_width:.2f} mm x {mirror_footprint_height:.2f} mm'),\n            Patch(facecolor=(0,1,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Grating): {grating_footprint_width:.2f} mm x {grating_footprint_height:.2f} mm')\n\n        ]\n\n        ax.legend(handles=legend_entries, loc = 'upper left', fontsize=12, fancybox=True, shadow=True)\n\n\n    def topview_trace(self)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        # use your _width and _length setters\n        \n        self.generate_rays()\n        \n        # _, mirror_intercept, grating_intercept\n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        grating_ray, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        grating_ray, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        grating_ray, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        grating_ray, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n\n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        return mirror_intercepts, grating_intercepts\n        \n\n    def calc_footprint_size(self, intercepts: list[Point3D])-> tuple:\n        \"\"\"\n        Calculate the size of the footprint of the beam on the grating or the mirror\n        when given the intercepts of the beam with the grating or the mirror.\n         \n        \n        Parameters\n        ----------\n        intercepts : list of Point3D objects\n            The intercepts of the beam with the grating or the mirror\n            [r_1, r_2, r_3, r_4]\n\n        Returns\n        -------\n        size : tuple\n            The size of the footprint of the beam on the grating or the mirror in mm\n        \"\"\"\n\n        r_1, r_2, r_3, r_4 = intercepts\n    \n        width = r_1.distance(r_2)\n        height = r_3.distance(r_4)\n\n        return width, height\n\n\n    def centre_of_footprint(self):\n        \"\"\"\n        Calculate the centre of the footprint of the beam on the grating or the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the footprint of the beam on the grating or the mirror\n        \"\"\"\n        _, mirror_int_0, grating_int_0 =  self.propagate(self.rays[0])\n\n        return mirror_int_0, grating_int_0\n        \n    def find_offset(self):\n\n        mirror_int, grating_int = self.centre_of_footprint()\n        mirror_int = mirror_int[0]\n        grating_int = grating_int[0]\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        #print(mirror_corners)\n        centre_of_mirror_top = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        #print([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]])\n        #print(centre_of_mirror_top)\n        mirror_offset =  np.array([mirror_int.x, mirror_int.y, mirror_int.z]) - centre_of_mirror_top\n        #print(mirror_offset)\n        mirror_offset = np.linalg.norm(mirror_offset) * mirror_offset[1]/np.abs(mirror_offset[1])\n\n        grating_offset = np.linalg.norm(grating_int) * grating_int[1]/np.abs(grating_int[1])\n        return mirror_offset, grating_offset\n    \n    def centre_of_mirror(self):\n        \"\"\"\n        Calculate the centre of the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the mirror\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        centre_of_mirror = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        return centre_of_mirror\n\n\n    def mirror_corners(self)-> tuple:\n\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.mirror.theta)\n        theta_g = 90 - self.theta\n        theta_g = np.deg2rad(theta_g)\n        a = self.mirror._hoffset\n        c = self.mirror._voffset\n        v = self.mirror._axis_voffset\n        h = self.mirror._axis_hoffset\n\n        w = self.mirror._width()\n        l = self.mirror._length()\n        d = self.mirror._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        return ((tlfz, tlfx), (trfz, trfx), (trbz, trbx), (tlbz, tlbx))\n\n    def grating_corners(self)-> tuple:\n        \n        l = self.grating._length()\n        w = self.grating._width()\n        beta = self.grating.beta\n        \n        beta_g = 90 + beta\n        beta_rad = beta_g*np.pi/180\n\n        blbz = -(l/2)*np.cos(beta_rad)\n        blbx = -w/2\n\n        brbz = -(l/2)*np.cos(beta_rad)\n        brbx = w/2\n\n        blfz = (l/2)*np.cos(beta_rad)\n        blfx = -w/2\n\n        brfz = (l/2)*np.cos(beta_rad)\n        brfx = w/2\n\n        return ((blbz, blbx), (brbz, brbx), (brfz, brfx), (blfz, blfx))\n    \n    def corners(self)-> tuple[dict]:\n        \"\"\"\n        Calculate the corners of the mirror and grating.\n        \n        Returns\n        -------\n        corners : dict\n            The corners of the grating and mirror in the following order:\n            bottom left back, bottom right back, bottom left front, bottom right front,\n            top left back, top right back, top left front, top right front\n        \"\"\"\n        positions = [\n            \"bottom left back\",\n            \"bottom right back\",\n            \"bottom left front\",\n            \"bottom right front\",\n            \"top left back\",\n            \"top right back\",\n            \"top left front\",\n            \"top right front\"\n        ]\n        grating_corners = self.grating.compute_corners()\n        grating_corners_dict = dict(zip(positions, grating_corners))\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners_dict = dict(zip(positions, mirror_corners))\n\n        return grating_corners_dict, mirror_corners_dict\n            \n\n    @staticmethod\n    def undulator_size():\n        pass\n", "type": "text"}, {"name": "pyplanemono_minimal\\geometry\\__init__.py", "content": "from .geometry import *\n#from .light import *", "type": "text"}, {"name": "pyplanemono_minimal\\geometry\\geometry.py", "content": "\"\"\"\nA module containing classes for simple 3D geometry\nused in ray tracing of X-ray optics.\n\nAuthor: Patrick Wang\nEmail: patrick.wang@diamond.ac.uk\n\nVersion: 0.2.2\nDate: 2023-09-15\n\n\"\"\"\nfrom __future__ import division, print_function\nimport numpy as np\n\nclass Ray3D(object):\n    \"\"\"\n    A class for a simple 3D ray\n\n    Parameters\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n    \n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the ray\n\n    Attributes\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n\n    \"\"\"\n    def __init__(self, position, vector):\n        self._position = position\n        vector_mag = np.linalg.norm(vector)\n        if vector_mag == 0:\n            raise ValueError(\"Vector magnitude cannot be zero\")\n        self._vector = vector / vector_mag\n\n    def __repr__(self):\n        # use f-string\n        return f\"Ray3D(position={self.position}, vector={self.vector})\"\n    @property\n    def position(self):\n        return self._position\n    \n    @position.setter\n    def position(self, value):\n        self._position = value\n    \n    @property\n    def vector(self):\n        return self._vector\n    \n    @vector.setter\n    def vector(self, value):\n        self._vector = value / np.linalg.norm(value)\n\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\n\n\nclass Point3D(object):\n    \"\"\"\n    A class for a simple 3D point.\n\n    Parameters\n    ----------\n    x : float\n        The x coordinate of the point\n    y : float\n        The y coordinate of the point\n    z : float\n        The z coordinate of the point\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the point\n    __add__ : Point3D\n        Adds two points together\n    __sub__ : Point3D\n        Subtracts two points\n    __eq__ : bool\n        Checks if two points are equal\n    __ne__ : bool\n        Checks if two points are not equal\n    __getitem__ : float\n        Returns the x, y or z coordinate of the point\n    __setitem__ : float\n        Sets the x, y or z coordinate of the point\n    __iter__ : float\n        Returns an iterator over the point\n    __len__ : int\n        Returns the length of the point\n    __hash__ : int \n        Returns the hash of the point\n    __copy__ : Point3D\n        Returns a copy of the point\n    __deepcopy__ : Point3D\n        Returns a deep copy of the point\n    copy : Point3D\n        Returns a copy of the point\n    distance : float\n        Finds the distance between two points\n    \"\"\"\n\n    def __init__(self, x, y, z):\n        self._point = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        # f-string\n        return \"Point3D(x={}, y={}, z={})\".format(self.x, self.y, self.z)\n    \n    def __add__(self, other):\n        return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other._point)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._point, other._point)\n    \n    def __getitem__(self, key):\n        return self._point[key] \n    \n    def __setitem__(self, key, value):\n        self._point[key] = value\n\n    def __iter__(self):\n        return iter(self._point)    \n\n    def __len__(self):\n        return len(self._point)\n    \n    def __hash__(self):\n        return hash(self._point.tostring())\n    \n    def __copy__(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Point3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def distance(self, other):\n        # use point property rather than accessing other._point\n        return np.linalg.norm(self._point - other._point)\n    \n    @property\n    def x(self):\n        return self._point[0]\n    \n    @x.setter\n    def x(self, value):\n        self._point[0] = value\n\n    @property\n    def y(self):\n        return self._point[1]\n    \n    @y.setter\n    def y(self, value):\n        self._point[1] = value\n\n    @property\n    def z(self):\n        return self._point[2]\n    \n    @z.setter\n    def z(self, value):\n        self._point[2] = value\n\n    @property\n    def list(self):\n        return self._point.tolist()\n    \n\nclass Vector3D(object):\n    \"\"\"A class for a simple 3D vector\n    \n    Parameters\n    ----------\n    x : float\n    The x component of the vector\n    y : float\n    The y component of the vector\n    z : float\n    The z component of the vector\n    \n    Methods:\n    ----------\n    __repr__ : str\n    Returns a string representation of the vector\n    __add__ : Vector3D\n    Adds two vectors together\n    __sub__ : Vector3D\n    Subtracts two vectors\n    __mul__ : Vector3D\n    Finds the dot product of two vectors\n    __div__ : Vector3D\n    Finds the cross product of two vectors\n    __abs__ : float\n    Finds the magnitude of the vector\n    __neg__ : Vector3D\n    Finds the negative of the vector\n    __eq__ : bool\n    Checks if two vectors are equal\n    __ne__ : bool\n    Checks if two vectors are not equal\n    __getitem__ : float\n    Returns the x, y or z component of the vector\n    __setitem__ : float\n    Sets the x, y or z component of the vector\n    __iter__ : float\n    Returns an iterator over the vector\n    __len__ : int\n    Returns the length of the vector\n    __hash__ : int\n    Returns the hash of the vector\n    __copy__ : Vector3D\n    Returns a copy of the vector\n    __deepcopy__ : Vector3D\n    Returns a deep copy of the vector\n    copy : Vector3D\n    Returns a copy of the vector\n    dot : float\n    Finds the dot product of two vectors\n    cross : Vector3D\n    Finds the cross product of two vectors\n    norm : float\n    Finds the magnitude of the vector\n    normalize : Vector3D\n    Normalizes the vector\n    angle : float\n    Finds the angle between two vectors\n    rotate : Vector3D\n    Rotates the vector around an axis\n    rotate_x : Vector3D\n    Rotates the vector around the x axis\n    rotate_y : Vector3D\n    Rotates the vector around the y axis\n    rotate_z : Vector3D\n    Rotates the vector around the z axis\n\n    \"\"\"\n    def __init__(self, x, y, z):\n        self._vector = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        return f\"Vector3D(x={self.x}, y={self.y}, z={self.z})\"\n    \n    def __add__(self, other):\n        return Vector3D(self.x + other[0], self.y + other[1], self.z + other[2])\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __mul__(self, other):\n        if isinstance(other, (int, float)):\n            return Vector3D(self.x*other, self.y*other, self.z*other)\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def __div__(self, other):\n        # np.cross returns np ndarray but Vector3D expects x, y, z params\n        cp = np.cross(self._vector, other._vector)\n        return Vector3D(cp[0],cp[1],cp[2])\n    \n    def __abs__(self):\n        return np.linalg.norm(self._vector)\n    \n    def __neg__(self):\n        return Vector3D(-self.x, -self.y, -self.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._vector, other._vector)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._vector, other._vector)\n    \n    def __getitem__(self, key):\n        return self._vector[key]\n    \n    def __setitem__(self, key, value):\n        self._vector[key] = value\n\n    def __iter__(self):\n        return iter(self._vector)\n    \n    def __len__(self):\n        return len(self._vector)\n    \n    def __hash__(self):\n        return hash(self._vector.tostring())\n    \n    def __copy__(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def dot(self, other):\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def cross(self, other):\n        # Vector3D expects x, y, z\n        return Vector3D(np.cross(self._vector, other._vector))\n    \n    def norm(self):\n        return np.linalg.norm(self._vector)\n    \n    def normalize(self):\n        return Vector3D(self.x/self.norm(), self.y/self.norm(), self.z/self.norm())\n    \n    def angle(self, other):\n        return np.arccos(self.dot(other)/(self.norm()*other.norm()))\n    \n    def rotate(self, axis, angle):\n        axis = axis.normalize()\n        return Vector3D(self.x*np.cos(angle) + (1 - np.cos(angle))*axis.x*axis.x + np.sin(angle)*(axis.y*self.z - axis.z*self.y),\n                        self.y*np.cos(angle) + (1 - np.cos(angle))*axis.y*axis.y + np.sin(angle)*(axis.z*self.x - axis.x*self.z),\n                        self.z*np.cos(angle) + (1 - np.cos(angle))*axis.z*axis.z + np.sin(angle)*(axis.x*self.y - axis.y*self.x))\n    \n    def rotate_x(self, angle):\n        return Vector3D(self.x, self.y*np.cos(angle) - self.z*np.sin(angle), self.y*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_y(self, angle):\n        return Vector3D(self.x*np.cos(angle) + self.z*np.sin(angle), self.y, -self.x*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_z(self, angle):\n        return Vector3D(self.x*np.cos(angle) - self.y*np.sin(angle), self.x*np.sin(angle) + self.y*np.cos(angle), self.z)\n    \n    @property\n    def x(self):\n        return self._vector[0]\n    \n    @x.setter\n    def x(self, value):\n        self._vector[0] = value\n\n    @property\n    def y(self):\n        return self._vector[1]\n    \n    @y.setter\n    def y(self, value):\n        self._vector[1] = value\n\n    @property\n    def z(self):\n        return self._vector[2]\n    \n    @z.setter\n    def z(self, value):\n        self._vector[2] = value\n\n    def to_point(self)-> Point3D:\n        \"\"\"\n        Converts the vector to a Point3D\n        \"\"\"\n        return Point3D(self.x, self.y, self.z)\n\n\nclass Plane(object):\n    \"\"\"\n    A class for a simple plane\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    *args\n        Either a point and a normal vector, or three points defining the plane, np.array_like\n\n    Attributes\n    ----------\n    point : array_like\n        A point on the plane\n\n    normal : array_like\n        The normal vector of the plane\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the plane\n    __eq__ : bool\n        Checks if two planes are equal\n    intersectQ : bool\n        Checks if the plane intersects another plane or ray3d\n\n    \"\"\"\n\n    def __init__(self, *args):\n        if len(args) == 0:\n            print(\"No arguments given, plane at origin with normal (0, 0, 1) initialised! Tread carefully!\")\n            self._point = np.array([0, 0, 0])\n            self._normal = np.array([0, 0, 1])\n\n\n        if len(args) == 2:\n            self._point = args[0]\n            self._normal = args[1]\n\n        elif len(args) == 3:\n            v1 = args[2] - args[0]\n            v2 = args[1] - args[0]\n\n\n            self._normal = np.cross(v1, v2) / np.linalg.norm(np.cross(v1, v2))\n            self._point = args[0]\n\n        self.d = -self._normal.dot(self._point)\n\n    def __repr__(self):\n        #f-string\n        return \"Plane(point={}, normal={})\".format(self._point, self._normal)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other.point) and np.array_equal(self._normal, other.normal)\n    \n    @property\n    def point(self):\n        return self._point\n    \n    @point.setter\n    def point(self, value):\n        self._point = np.array(value)\n\n    @property\n    def position(self):\n        return self._point\n    \n    @position.setter\n    def position(self, value):\n        self._point = np.array(value)\n\n    @property\n    def normal(self):\n        return self._normal\n    \n    @normal.setter\n    def normal(self, value):\n        self._normal = np.array(value)\n            \n    # rename intersect_q\n    def intersectQ(self, other, atol=1e-6):\n        \"\"\"\n        Checks if the plane intersects another plane or ray3d\n\n        Parameters\n        ----------\n        other : Plane or Ray3D\n            The other plane or ray3d\n        atol : float\n            The absolute tolerance for the dot product of the normal vectors\n\n        Returns\n        ----------\n        bool\n            True if the plane intersects the other plane or ray3d, False otherwise\n        Point3D or None\n            The point of intersection if the plane intersects the other plane or ray3d, None otherwise\n        \"\"\"\n    \n        if isinstance(other, Plane):\n            return not np.isclose(self.normal.dot(other.normal), 1.0, atol=atol), None\n\n        elif isinstance(other, Ray3D):\n            if not np.isclose(self.normal.dot(other.vector), 0.0, atol=atol):\n                w = other.position - self.point\n                fac = -self.normal.dot(w) / self.normal.dot(other.vector)\n                plane_intersect = w + fac * other.vector + self.point\n                return True, plane_intersect\n            \n            else:\n                raise ValueError(\"The plane and ray are parallel\")    \n        # return type is different to return type from if and elif above\n        print('Not handled!')\n\n\n\n# Image class already defined\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\ndef calc_beam_size(electron_size: float,\n                   electron_div: float,\n                   wavelength: float,\n                   distance: float,\n                   length: float,\n                   num_of_sigmas=3,\n                   insertion_device='undulator') -> float:\n    \"\"\"\n    Calculate the beam size based on the electron size and divergence.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n    electron_div : float\n        The electron divergence in urad\n    wavelength not photon_energy in params\n    photon_energy : float\n        The photon energy in eV\n    distance : float\n        The distance from the source to the image plane in m\n    length : float\n        The length of the insertion device in m\n    num_of_sigmas : int\n        The number of sigmas to use when calculating the beam size\n    insertion_device : str\n        The type of insertion device, can be 'undulator' or 'wiggler', default is 'undulator'\n    \n    Returns\n    ----------\n    float\n        The RMS photon beam size at distance in mm\n\n    \"\"\"\n    if insertion_device == 'undulator':\n        source_size = calc_source_size(electron_size, wavelength, length)\n        source_div = calc_source_div(electron_div, wavelength, length)\n        return np.sqrt(source_size**2 + (source_div*distance)**2)*1e3*num_of_sigmas\n    else:\n        raise NotImplementedError(\"Only undulator is currently supported\")\n        \n\n\ndef calc_source_size(electron_size: float, wavelength:float, length:float)-> float:\n    \"\"\"\n    Calculates the source size based on provided parameters.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source size in m\n    \"\"\"\n    return np.sqrt((electron_size*1e-6)**2 + (wavelength*1e-9*length/(2*np.pi**2)))\n\ndef calc_source_div(electron_div: float, wavelength: float, length: float)-> float:\n    \"\"\"\n    Calculates the source divergence based on provided parameters.\n\n    Parameters\n    ----------\n    electron_div : float\n        The electron divergence in urad\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source divergence in rad\n    \"\"\"\n    return np.sqrt((electron_div*1e-6)**2 + (wavelength*1e-9/(2*length)))", "type": "text"}, {"name": "pyplanemono_minimal\\dist\\pyplanemono_minimal-1.0-py3-none-any.whl", "content": "UEsDBBQAAAAIAHFbmVgAAAAAAgAAAAAAAAAfAAAAcHlwbGFuZW1vbm9fbWluaW1hbC9fX2luaXRfXy5weQMAUEsDBBQAAAAIAHFbmVjTlgmkKQAAAEEAAAAoAAAAcHlwbGFuZW1vbm9fbWluaW1hbC9lbGVtZW50cy9fX2luaXRfXy5weUsrys9V0MvNLCrKL1LIzC3ILypR0OLlSgMLpxcllmTmpWOIF6TnwsUAUEsDBBQAAAAIALxdmViGlHaXdA8AAORDAAAnAAAAcHlwbGFuZW1vbm9fbWluaW1hbC9lbGVtZW50cy9ncmF0aW5nLnB57Vxtbxs3Ev4eIP+BtYGz5Kxk2ckVrXEqmqTtXYHrIZf6Chx8hkBpufJeVru6Xcq20ua/38yQ3OXbKpIvBXpA12ikJYfD4cOZ4QxJNaurFZvNso3c1GI2Y/lqXdWS8bKsJJd5VTZPn+iycrNabxlvWLluyxZVmeXLNa8bUT99kiGz9XZd8FKsqrKarfIyX/FivBTVSsh6a9i/qfJSPv8mYW+QNGFv+fb5N7p9s8jX2zEwbiQvZWOaLBJ2mzDx9An+LQreNOzPNUhYLgfV/N9iIYeXT58weI6OjtSXl0yRZVXNOGuATyHYUrVBJkjzijciZVXJ5K1g91X9jlUZ+4FLeL1nf+Flagjf8JrDEETdqPdR+6j3Ii/FLBVlk8stu2RZUXGpavC5Au5IwQwF9II9amlYXlJ1w9aiZquVaihKUS97mOk6zSYvFzlwlmwu+AqZiZ8U+SLL4u2z/AHGnVWLTcMM1J5QqkFVpyDSJTD1OKR5ltV8gSqiiWLN03yFI4YegAeva76dFfk74bNqiUJcVit2XYhyKWH27/MUP25FvryVN0nHxeLAa8F40VSMLxaiafI5TPp9Lm9ZwVfzlLNsU5LQQNlcdhwaUWTjmepoMEz0O3XYvaqOB0PVbE7D7hvYj2uxyLMc5hQHZGhhfJzVghd5I/NFO85FBUpewgyOOwa/dCo2uqrW1tvoF4uK9T4d1V9FJuFD24syOlXzFge0Hzf1gd1/xZ69B8hrQUBGJX5VSVmtohJfy2qdACBIkLACREtYTRNqbK0VeaTkY9Ov2BUvl4BPzgtLd6o1kKiukOZHvsylNBTaCUhZ5/ONFL/b7SF2y4v1LY+L0AoNMwK2pVubEaRiWQsD9lzIlkk3JTFJPs7rU3gSDW5Vl/12i2wMRciDXotqzgsgAvjykkvBmm0jxcryJtdKvUm72Zwv3iXW2HUd6XxfJTWE5bCUvS1VbVcJZmX155ZbfUUaxDhZfdz87u7+D9zdD0LeVqnr5dRLI+SM7KsZkFknZJdDa+6EdN0RxD2hdfrmYDu7maxm9/xOmPWz4/2aF4tNgUZCEVZL49v6y3LZSAj/GmOjqzU47Zm2RIejqqLWjzNU41DUAAenvF42Vgcv2YqwBDtoiRhoPHYTQcCIiqAagO1VJdEYJcrd9mITukNynxQTy9DvUk+KVy2yQnxkICea6GTHSNrI+Zi93YAQMLRUYPi8goAYFgpUCxgZfgWOsBQpgkZuUZ60BHhLyR+YqOuqbsbsVQEOh/2BfceLd+ILisyWVZVSQC5v80ZbfyoyyEAgU5Cz2QADLdvltY8N6fTzySRKpJCeXrzoqYd1dXoRraG5mZ5H66xVZQrJz5j83+D6Ajp5MUn+OLkZRpsZJ2i3mST0dzPEbCWIPu0h2i8+oR6m+vArcYzwn1+sBkj/+lVqsZ+yv4FP9utIB+NVDizdSzymBhIVgF8Gra8nN34birt3NTkPmqjYfFebi6BNN0P6W0cwS2ZQTGTGwLUPtQwsILHclfoj9SH9rsW61vo9tCKFY/aPBmxsBM4P7NASoBaQkZcsOzJZrqMdP1O3dtGH5F+l0X9Vq14+JAwqUClUKXxTRUohVCF9V8UdYLquK6AuNFK6Ur99GB7ZQTeOGFb9dJblhdAmjV9LSKHtwbcOB5+30KD14Os23VYOkFP7sWVmPwqhdx9m6+VqDO5DJfoAwgPHVH9sO0JNiUzYim/xXXKMCasavS+0AgWHuVSpIayQGwiry2KLTrLjY6TTdJBXFgV4aRrr2LZnf7cAHz/zwMeAAkEVKIDrQzAQpTq9uJHs4HexMwKlB0c1VNBMe29m/Jpe3tCLrcKKaIxMB+0UddXdtzyD4KUcKPrrEw3Fyc2QfTZln1+6sh+zf1Yb4L0pUlgYUha0wrykomHRYgELVdPwpXC51DwH2/iJFxvxLVINjr59gDBTQgYEc7yQMD1ZfidsZYEpNZOEozka2rNyDLEDSrQBrnKDu0E5ZFAIJ0CMIWpHesfrnM8x6JmywYltZycJO1GWhd/AmvCDrAC/dMZyYqGIigkcUbqWsYcYwIsUZSWRKsDLo46j80PeNI7xsJ8/BIiM1Xo+gN6GQ5erjRTOHy9QLcBYbgWs40pCjUpMRsbnFcwGRgng7ATHtLao7sfxCYCotEF1XkAfEAHlEJdpWze9EKewF2jD76o8pRmj6KsWtwp0qyvFb8quHwj9Bwd7HMtDzxigzwdUaXsqrVLt8E6c6B17eCcgwrvD2UDG7/P1gERIwj7GRAWLxNCbVYAEAq1aO8yOoTdNa1gp5ACqo+V+i2gcAMAgrVUy9Ol6gh7K5QcPww7VYHzXNnQ342Zd5HJwkpwMb4JOzGJyaAftLHjcFf+v13W1FrWJm3A1si1YrcGQ1lFX1hzoJTcMxuy17Wu7YgxTJk1AFe1HT6HeBMFeMZS6dPyq0po/Tdnkcm8HuK6gC3R+9vbUkQWwKBoR6Jc/MJha6nwHcsrX7YeZHZBqhqoowMni+qsjpPraCxu9Pdei4hpRBB3w//tB00bkmhW8B6AYZgchcv4IRKCjveDAbUgHi14cyB5bJMC3hDjEHY7mSEUBIB3XFhLgsguQrwAQ8tZ5k9Pu6EIoj5hQy+gojUf05hwf5VKPFAVI99lHYNsHfEygl7jtikyPdjktyss89WK2R3c0zNoQ0BypJAC142qWlyie6JHnjV5OSNG+mPQgOyDRFMJxiE2G6UF8GIJqG1mxohOdFV+Wudyk4AQhfFRhPEqp9413Yku7NXtZLlI6sGJBgGrL76PG6+TV+9hWt5oG2aMjqJ+Ca4ZdcSC0x9nog6sIGPVrLYAA6Pn+82VidHkLs6FYq8PYrtuj3WHHx9YmOmhuZ5H2efvA0cHDjJq4gGNJAE3Hup1Q4h83ltAmFHHUGBxRDjCKq+06wFjtbasDcMKWmO7WfBU7tbCBoZcpBV+9FmBvjhgjUGWhHVjcW+S6LuLwuSr2AlyjSoQCVC1Gh+vh+Tfq5IKyPbUp9YIw0zLvtSR2W0atcnaDt3ba1fjJWWlXoLbd+/2Ck8Q/bkv+UXsQPUd9+ESO+/xjOXycY76QQ7ixbTPp6N/iFAbCdu/d5Lp9fJ/5Zwt5w96LurKZO+hapJDeg1KBouEHCHVR81Tt4g+H7BkL6+jsBOrO2CDYgzs9n0wmp/GsylF4S4DHBbVgClU5wkFavNzdjo8HuecXz7/8YvziAsZiCXQM+dYduIzGLoSk25xNu4Nx13crBukq9VLXraNdlQowzb7kDqdlNlb3d1q6hRt0q7Iw8La4G6fFy5iz0gHh9+V6A/5pWVa1SJP2GApPOPRWsNqi27nUmVa79pA7Ca1Dpr6wxdFx+5jsMUdLji95S8iGjiTuAw51Aa5W9YxHa9EkpoSOPVt7396xpFVjTcbGtCGLPe0xaquLUcQrUCvtNgKZgQ5oLoB2QPscC2y8GUadQ6DNymxCTbDWGdQF2s+81gsNfdzsoxkHry/2rPpLQ8MW5kQz7ZQr4GpBT9uVsudey4Ea+Ph17NfQ4gD1T663yhVZdYkrMbO0OqjSlc45dQ8NOOawqpMuqsXqDG52qGmdDc5Hps/T0wvbY+Zlu8i0zNXy/J9aDs6fmUJodtrDwlmpojbZ9jIMdyqVKY+CdouqwW/6I2TUSjN0VucwdU+cfFNRmg1zPEOREP7b93Lx1iovCratNnV3q9FO7vT9BrWq0eWAS3XTlv2iNs/RceCXPk+x902IRwWeJBEzIkEcTjKBx9G3gW19Q/OjjkGSeWeJIj3MR3TtZsTtclefL9vKrhkJcUjQSrFcYwVzMILKcqMmp4uGtCQjBhWYDWmYKNVrekNbf4RTdn1jW2hf2opzcT25SWjMfnJFEzVlmsYNMnX6RldP2PSgYBayhUJwhLiksbrxK2ZmswTL6WZkuVkJUDYlqS8g7le5CSM009fKfdpOqFhCbaN8NPSHsk0radJ2eBvfAVVVj6F0EMntxyUetRUeF7Vy6CMPch8W3zMoBQ/JiyU13sXVZxt1bOv87GJEPXrk2p85kScFlx4d6hNqkqE1d40wBXcubthDG305gSiJuhj5OYHNVON3fXHDnpHk2ou2eRgJ3iORaXxuGvtJ3B6N6eKKU+JPgFcdYWdZ25iv16JM20YWtfb3XgM74u18fq3uBDT4m4lbjJDwqmX0pl3n7XsDB3P9zNp46NnuvD1dnA3EqRNohHHnXplYb7z5uAt7B0aCuy/44vNJLvnis/OiLz47L/taBPELvwEH/6ouPn0Xf01d9PKv07CPa3gJOJjcWLLjJEUz77LpMRHOluSwNw2u4DaH2bKPB4R7X04sRoVxSbPw1ul9W6d/wWEtkG2V+TVHOJTjV96sWjIW8/e4aVScXQxPtdPxRggk6C5HLQ16tZDmAWnuzy6cQijTv40aIElCzOjf98NQvm5mLSY1CYgtnMKtKtw6hSiDK0LtiFCTCDWJUJMIPSCRjtgjyd47EERhyrY2klGUshhKmYNSRihlhFIWF9HSY3uomQIqc4DKFFCZA1QWAcqRoiYpapKi9qW4sg20K5dFO1OwTKY9GMiinTpDFQFTxvRJOvokSZ8k6ZMs/Mm8chyFxUOrU71bSK1f9W4hIwonHYWTpHCSFE4GCnfl+Ct7nO1M7gSyndqdQEZUTjoqJ0nlJKmcDFTuyvWb9kiVlPVuKbUC1ruljGikdDRSkkZK0kjpa2T8HIrOkgbuKtBrZkkPnW8IfXT9zi0iabdT2t0T8hbJYu71BLrolxT+RgZI6K96AR8Z8JEBHwC4K7gZ9ub57Z50F1aZeNpK0hM6vGivJXzHi0Yckqlrlr+JRF3Lcmie3jaz0/S+7LwlDpJzByKPp58Ym2/H7DVdd+QZXqBMER78FTNGhv4l0U+c+sZkaYSV1Do943aQydqpd0898PHz9q4HN83Oy1Q8/KZSbVlvI7xmiTrfntGPUMwt7GnMn41bkr8P3EwMH/GwEGtpTU2kM7W/mp28VSfGhBH7mT4+sLQSjb6sq7sxFobuFq8U0w2VBd+giJ+dDEP+eAU9L/0bR5ivqFNqe4fBpTEDVRsBPeNXlcHcda4lMuTI7NlGYwumv4/YBTuleL2iPQFVnLCRK+MQiNwSbz7Cs8r/pffDOu/pJVJ6xrzdgQiRv2dkUwBbUvpBqMVJrMNdvNrNBqc06kb0GuQ2bw9b6X+SoFaPblkyeOEpjvoVx6Jo9vgRx2t1m5t3d85///XGQb/eMEJOGQBu561mAe9+VxP5uYaeaedXfU+f/BdQSwMEFAAAAAgAul2ZWERl8uGNDgAAbkIAACYAAABweXBsYW5lbW9ub19taW5pbWFsL2VsZW1lbnRzL21pcnJvci5wee0bXW/cNvLdgP8DYz94N5W3zkevOANbNJf0oYf2kEt9vQfDWFBa7koXrbSguI43af77zQxJiaSo/YjzcAdURWOJHM4MZ4bDmSF3IesVm80WG7WRYjZjxWpdS8V4VdWKq6KumtOTc/ZL0SgGLWzTiPnpyQIHcWgy0NhtWldcrctalUU6WW/xzcIUTVEpIXmmintxemJaq81qvQVUrFobBDiKV2JVV/VsVVTFipeTpahXQsmtxfW2Blwv3iTsd5GpWuLbWxyUsHd8++JNiz2rq0WxXHPZCHl6cnqSlbxpNOjs10LKWo7q9D+AY3x9esLgOTs70y+vmIZd1JJx1gC+UjBijK1o4ATxIeRbLjkwJ2Sjvy/bR3/f14tFIxS7Zouy5iph9RrFykvdjc9NLti9kKrIeMkMeL1gKrfEWFGx1UoPyA/Dl9ey+FhX6gCM/KFoZl+FTcTUw/yVGA5xz4uVqBo0UMDMpeTbWVm8F0PoHfCIINhtKaqlyhP2oZjjn1wUy1zddTjedOO5FIyXTc14lommKVIwjQ+FylnJV+mcs8WmypSGbK47DI0oF5OZpjMaJ+ab6HWfmu5orIcBm4rvExyvlsBAb1JzsZRCGKPUlnttV0kckQbyEGmAtJZzsO99Yv5tLbJiUYiGEJhBZgVJwUtwEkXmLSJHOhbcJbIPNbDqYl5KcFjVElY9rP5KVGrSIfijW5aXN/Xa+br8w4Fig08H9YtYKPij/YeWqOl5h7o7DJv5C+R/YN98BOuUgmwmyvHfaqXqlcOxhemgb1W9TkAwCJiwElhMmHRM2HqrV0rJIt0oMeCtBlbVMWvJWFzdFDghNDrtrQNjs/0Re6tqCV4fRlr37g813ffUGRsPngS0zw35OBIXJoIiq2U1bI6IwEKYwdb4QAT0WdYp8JjVYKpFxZVgzbZRYuVY/K3WFimLpTx7nzB3OVAfqXCokwbCnlmpwZG6t+sEK3Ho+e0OrciAGCaHxl3EzxzoXQZ9zJ+e5f/Bs/wqVF7PfXeiP2APn9llPrIvY0f0sMerPa4Acej1PtJ/IuP3+gNE4qz3kfMeQbfHMyCyzgGOnnK5bCJYhnykwxFFOc3IRF6JjewSLyBLvCAqxq5GE3diqzW4+plxVSNn9GvdRUMCT9b58l2OLLE24v5L4bPZSMQC0gqI39VsNsLYxvVR7WMmOX32ItptZj19eRXtduU0/cvku2EgiyiOx9HVFBKRCfmJ0e3L7wD8e/j/u6u7cRIZR+HZ9GWcLnmjKS3iUXS09TUuyauE/rsbR+DHjk9r8xR8XgPjSm7I+tEnotrcHEenMm3Cgk+YtOAThgL4BFmBz9VRaQs++T5sRyQt+MQSl2NZDNOKFu+jmY1h3hteWeSPTVfweXzKgs+RaUs32IkV3DSmP9dDEhh8BoILi2YwwPCZcXxUNz1rRFNr8SFA3gLkcQDPFqeeaUZBcx90AKvnmbqPeFIJIFqd173Rt1d34RjS4K4hz3pDtJZ3jXneG6O1MtXaCTu1YUy1gXSd5+zvm0YxWLMlW1F4QcZabxSYZ1MsK4zFVM1m3ZAZYCGcO/Y8TbNzu+YNrcHds6RYS7NnuS73nP2rEWxxCa4WyHftUqiNrNCsvLqS3ZY+fXZ3hzza6u1jka74KK30oJG0GhIltQWNenuCtl6gDI1jb7lMFhhgKZLIxIYlkQ3KeQi0jWcOgPVDnkMHHEPBcWGHQLcO7hBg6/4OgibJHyI/o4+xn8GfY14yny0K8JmwwcDutsX6ZFFyiWvC6axs3jJZbyfsnVhwChEAaNNg1LdaQYSb1XMx6cy/HW5iNnytIFQYDD7ewQDrtNdtVMF0hZiGTxyh/CaEKcrO1svVBMJDncVVTDxwrLE6idUrC0mzWfEtfiuOG2AtMXKFUZCMgaz01gVJCjiIuiq36E86PIY5AwYrBLxKKmimXxQTWZHATgS+oL8PUZ/Zhoh1oxWSyYAU9UzBJ7kV68lr+nhLH64j00ATRDpqFRTb64oFeomRhr+90JK4uBuzJ1P2fbDPS16AVfzOy434iTzY2U8PkBsrMUfdZKpEM3twdYya0LJFJs68zf+ey4JDlIF+9vbCLOyLhF3k3au75ttvp7/bV/CL9ogLZ39BwwEyyEZLLZgTzB8h8OCiqFgohuv+GuwL4dcCdhzYbtp5s0+fw5lbBwm0xnE9QMJEknggrh88npHLhxh/sCzm0AO6ckXhtBoHgULxxfJebBMgALNAvB+L9Yg4SHokJgQEu+Q4EMY5e1NXF3TeA+oX2YT9BDswzF48rMsiK9Ac9F7sTATjtgXb1hu9yFDs76v6A/uQc8pVt3bxJYSXQ0RDa5KDC0PgFtPEZwYZGC3OtK/9BJP7DLKkYHL0iSbweXwWZExr2KTVCECj7TQoqqmdAViXp2niD+NOnaFkb12d3U0akJoaXSQX47uhiORY/K32B5Bbo/hxLes15EDbzsubRadjnMsftCyvXSsyUY0XHbcIzfcE/ldCxtEa+zNBPxL5Bzjra8834ZFgo3iVCa2RxABHMxAnRCfDdlQlykZEvdnNdt1zZhYPeGXYBYjgE2s9EVHxnpCiIvLid4OM9wTEDxONGz21lm5tdpDTfECpu/k16PIBlebDKn2ELnNfl1+oyXxAk4MSyg6TzX1El1lPMtkRurzfqcsdHLtb5GHM+4mntUSnsW+UIY2vp+cgKX6MsqmaMrR2hx3dlwjNUft938cdofZg+qHud2v9qOXs1xBcrQ8t7B4NO6Wvo/Svs8JJ6Ucv8/xLZOYoPe97wWOVPuS8NZVBzp1zBTsFiAmqOUUFQ/MIy0IGe9fcm05AZlDzXoryGx4y7DrZcIK2oIKJ1cfGnLPN/QrjYCFzgItIVGYMbFColG+38qQizZAoTZHKosKvnvA6dK09EM5DQxwNHF05tlb2mCWjgyO9VvQJomWgjXIGJUUp1mGLx6nYGXTU0pNWh7K/ekICfk3QEcLwhm6KfIcvFjPC39t1W3+Hd7Ab7l296VTi7OdqvVE22VpWtRTzpD1SM9VInfs7ufOTszALiNQtB6dtIv8jpt2WOp1pm7betF3sdtp92477Buf8fNAxWJgdXuErnqn/T5yqO/5uz2l6T7RRH9IpfEzlACzyaEVNpy/7NRBelrqb/cCuQteDT1gZDxwQPhEnhE+/YPILOfSGNXm9KefohvT5/r2YuEY/6NSiFahnb+xNUZy0ObrShx4vz8Z+Bd+7dqCN2H62d5H2Oms7ImlHDHvsSXuBYdpS+kLvbYi1Ppvy/xY9qcWJfexszQUJPVf90V172jtVPaC7S7trpuaqxdRQ+cJZWkr+NO01jmCS53hXIS0qc2AZeqvgOoaWAV3KuHaWCSzgoaAtdGT7YpwO+NCCMXGz47zXVNawlk2n91IIgF1ugAXVtCf6bpjXjX+HQu7R77671eTT/FnPChZVKujOTEcQQm4sxrnsDIZj53aHs6uxRm2iSzLFQQhEbFVvwl7zigp/Ktcn44I88qpZTlyM/8YaYegLyI2hGOe10Pzl/N5STVhTsywX2Xs8FcBMoXYwaphZvZgRgil5y+DWji6Ue2BT9iy6ELzYE0G9s1VRRlG92I+qLf4FrB3iKBdOrX6vMXVUE7YEQVrNLdgnn/HPtD7xmKTvcuzlJRMk6M/2onIefLuJsN/oQ+6pn9hD1TB2smls/5JULw0fuR9RwNwF7DC6YaEfqe2MwoKLOo+9dOVYbMX4fK73BVhkqr0AgYvPuNJYFOY5DwoR+96ra+iuwXaz820xchX2sLn4aG4HL5riE1w2DXr712Gj/cMIhm7F+qQjnb0bvDsIY7/jKGJvwZFgd9OCPVyzZ9+CCmC3HD04ZmuTJeiai+Vzyef6lJ7aQ7gZHjD+9Ypd9nM4H8bBZhodVNzetOjfWcnart7Nl/u2K34zJvf7e6g/tP3mYN7x722XPeHv+uYds94PK/A5v/FMzl0Yqlx8hJGXoxEHaWXsKWpDy2I8hi8QEMRPbcM3LPfGbmlsxr71AQGuH0AzTeJpj0BWNw6Be4/AAxL48O1zrxHaTPg4QpCEOKF/P3pHs+d/C9dL15fqidP8v2Hzpx4fHthWg22BeQJzpmkeD7zPcepxnBLHKXGc9ji+8de/M23Z8us1Wu68RuTBF5r0hCZJaJKEJgeEFuUi1VykHhep5iL1uEgjXKQeFylxkRIXaY+LG9dTudpPW7VdstLXhwfmqK0c0i6AxQws9QwsJQNLycDSHQbmM5paRtM99mUYTSP25YHF7Cr17Colu0rJrkJGbzzn7hpGy6bXaJnyGiNm5YlKkqgkiUoOiCrGRKqZSD0mUs1E6jGRRphIPSZSYiIlJtKQCb/4qG8sKwzrYBWQeiPQdst3D62DjRMwBC0ybEl7MGkPBuj38IQtaQ8GJtk13HkTiNcDdf+PdFVa3zl0Yz4d0sywiqdvR2Vl012OootAbXHZ3AAcDAKlwCCItzdI/rwpdcxNKcPjlIEG3N3cBLnd/bXIxSijeXs3uFOvFIsSJu1XD+inxOwPhr8BGjPQLr4MafWVvahKUyBskKZtMSb+avUD89vmUIpERhf8DWUxPy7Kb4fNCNc1zRQVE6H4qu1sRxEHgyWCAPmU3UajYHNVjZJfzJivDi8Ocsxh8dfoaONAxC0zegScopdJ3BOt3YCWqRP0kvvwmlVRzQW4VawvYTWjgiRbwtrWk+iXYekaWscCDDO/V4+VZIerZ9ou9e/Ww2tPSm4juGaJzg1n9At8u7ynXmWv7fonMhagFQ+ZWCtH+hEi+jhkcQHsoXWQbNgn+vO5q9q0ZMyCwE0GVzzV9jK+Qc6eXER+/oIerajCqjQW1HSBb4rvE/0bMB/G+O62dNmvZwY4XYN1sZv3S/ZcR+hzCNnb5sSng0G813AQjUgr5RAlJM7lkrgdRYDGO5ADWjKYUd8CkhjBXbiaCV+vRTX3eYiuNuNq/eGnJ/8FUEsDBBQAAAAIALddmViBVE7ZyhMAAIVsAAAjAAAAcHlwbGFuZW1vbm9fbWluaW1hbC9lbGVtZW50cy9wZ20ucHntPWuP2ziS3wPkP/A6H1ruqBXb3VnMGOi9m5vsZg+3cxfMBPfhfIYh27StjSwZlNy2e27++xZfEosP2f3AbBaIg3RaZLHeLBZLpLNk5YZMp8tdvWN0OiXZZluymqRFUdZpnZVF9frVksNs0nqbl3WezZL0QCsN+AP8/vqVeih2m+2RpBUptu6obVrP1+3AT/yRNEPnZbHMVtuUVZSpsdvjNk8LuimLcrrJimyT5smKlhtas2ODpcyK+uZDTH5Ojzcf1MBqnm2PSQUEszTXkD+WxT09/GWX5y5reVa0jP0VHoYfOnigOd3Qom4l4RDTnzLGShaTjwzIFqvXr16/mudpVZFPH3+Kytnf6LzujV6/IvC5uLiQv/xAJMiyZCTlgKSi9W6b8MG8/1PKUhCXsko+Xzcf+byStMiopUrU5/OaNt3zEhgtgGVSLkkNHUBJQm4E0zDelAEjUSB+HEqMumbZbFfTr5VNDsTSYwUY8qyq8UjRUZdkRsmWldt0ldZ0AWNZuVutMY4ZTTfTcrkEKwGqZV6mFq57yupsDk6ngBQTfBzJCrLZGHj22aJe+9HIrq7Ba5qt1gEmVF9guPz5E63X5QLbS+mJpovpMstpxH8U4H+9Fv3P0Cn8dNt4JhHzJCUcOiEt6C+Uqkk93a42Ccwd6eYFoYd0swVgzLWEFWhItS53+YI31SmwnjYukhYLeFK2rmBKQYBSeBrbRVcpW1UG0590jzI1tmwz5TjogqX7aZUt6H1G91F6MLB8gK5KDBIDSMn5Ol4/cMJ/k5zItlV2T+HfQ1aZSOtyeybOQyfOmKR5CZrYZ/W6te+yLOstg1CoaYoQo8jTJQR40H89nUYVzZdxo8478l8wWWKtUP14dfVlL3Q4alltYlbrQ/wDUbWq2W5ew3BuXq1UEdcS3wg7phkO2Pgg/3QEDe0ypwMH/5wIHhrZyQDCP1ozgA1j+E963JcMnJOtdnJx0NowXdemYWpIz5mPBrzJsVQplYgXFCZGXjULBVYxstUb8h/1ZUV2xTynKSP7dVqTrCLrdLulBSe0powKarX4bZ/lOY+FMCDd8ThCOXVY7JZEyQ6jITngyzw9bMFL6cIQA8C0xADH/WmEZVS9U4XsjoxxP/9c8gV5uqBFldXHy9gDQAvKVv6u+XLpbQfzUObt0Swtsg0nCS59iaEmHSJMv9Dj1yHGOez7BdGWkDaBJKuODj3haAe+dGCTdSmDY1lk8zp6yLaRq6YYUez1MCYem5JpG5vUTIiurjCNnun1NK9sD7PxrOz4gbxVzUm/s8rObl+9l2u91yTrjj4ezaddgwVAFwbFnWF3HxRM6zrtdmhTzC5//seJ+jwZvdKecHpk+g59IZd3FBmb1PwO3yy+ZrQHp0dErJFn+H+DdqMWPJ86JKhIi0ATE7vDzHfvyODG2y+T1Tvyh+TWD6Dy0Tvy3u6W4Q96hrf9Ps5XGN0yla+YaQiDPIkVfIXj2yo1s+9+/S0m/1dIQdXDjP8L/zQcGs+SIWjoAZ4ELA5bQUEpUQhj4vrYIz8CneTI47BPQWYY4yUxCuW8JEKp3Z652+AmXXFjQxIuvM2xK0pZPipQma+baaWZqzvDDC/pg0+JikCkCgRRP3a1SK4H/X6/5xe+c2C/d/34QZJaz8vw4ByGyVtHze+GT5YigC0k2lNwSc686NAizoZniX/9ouL7sfV75NGm7WQMC3rjCHptTUU+8mmeeh6mkwI+hiEs3K0j3IvJ9jKiPVUyvEwycAE2gL8wnN3A39sJB25DXVtCkdvtppASCnhfaVnl8Zt2LSnsj6vas8kWfWpjLViqS6EtIe3JsI4S+6SzUGXmQN2QoMWpUtIdqkInP4qHT+Ih8o4QmMPkm/RGFOmidtz4knvc5WSsN4ATZyxOvcIIDLgQFp2gnUAiwEI4mhzuBBIJ12AxZwVwOBV5evfi/wsIzN0jLVZ54yva5oExRrKVCBLAaD95T64ISuuSNN+u02vUNAPoZq7/Gy8iUlYfTb79PKtE1KHcoBJPCQhdU+ZHF5P7NN+hqCDQaQlEb7eQCqSDe+lgnexrVUhQM28zMGp8+/Segruv6nUI52B4833y3e3g++9ub26G/f7w/TtBxoNeNjVK4m1vSEHpgguWLcT7JxHe1EwS4saEJquEFGVx/UBZ6RVVqVaVx3vXf7Q397Dxz6qsqOq0mNNI4Y0EdAy7v7rXE0FRdJA/kr5vi4X15hrMszUTNVpNrj5uFWl7Y8jSrKLkf3jXn8Ru8OJPqtKmNSHfV6RkW1ZZnd1TKei/XPSChlPcSquBQlR1JeATU1Q0UUi1wKa9bNSN5hX+c3WvwU/UcnwqJj7lfQbl2rrTpVVNW7iWwt2oLqhAOfUa/Zm79ZASN0atWeFVE9hWoYG80aBJoXdKfyHgVolNQeC0m4ZViCrSSI8SfZcHths/UB9/DzcWyeIkpD0Oj3THGxzNNVgbvRmoPd6HcjlDFUG2jRW24V7MNpfv68GVs3oj7Ea7I4hN5wVimNcPcGYBLD/HHwQ1YX8DbeME3Xo9pc0TqnQVeJ7anN1beBlFphH50SN4FvCu9UWz3/gthRdev+78CxhOD5/jBnwxLugqbZei1icE/tPh1UgfH6FkOcDVsmz3q9kg8nvquUmhz1W0d/3v0rSkIFTd4cyqrgzMUzan21bbapfcvZi1407YU7+zeTQdZ6BJKEhuvlye5TY6hwF4hBGeHW/ROF86mxx0ZZNA9Lk+wlH4E0Qyy1YryuupKSTqylO0uIJmu0LzlxojswjAGyAhTxnPdX+V+z194OVydH6R2txumsO6K9Fof2kOk03hcegl7Agr2+wLY1Cb9JEv7Q+P4i9wR45tw/Dyxa41QjSGx3jeXFsI2p6TWJKZoOagUM3h8Soy6Bd8I7RVvT/lDWr02jt6feZo9IYRozC7zsPjZ8XsOonHNYjCco49FA75UhMPF20nR1qGVGNV629OYGwndrNsiMMmG3FIzAwRvO7DS3WymjbPq7a4OWqC46ePP4WKOz8yyt/ryLOO3yqc6gNi8tpjXllVxu7CpTIewCELNcfg5MolDsONZFme/L/YG3Eb1TtQZMhKZx6Ye7zyrtTZKXVY19ad9ySmvZPgn5+F6C6xtkEHRkCpDn1yo0gtyMO4Fab/QwNkHAIVDJUsW2WFcqManemyUhTMpJ0vGXykDDBP8+wLDTFRtyfSGgSVqXInS3o0ekcIhB85xBTcE1XU+Qm2XU2n85LBKoj8toVtVj0XGGtJWMmiwOgyBys5hzlNw9qEFtlyyVI+SGPtdZjjjow1WCKzJFVsbFhSp0D475MuzQMmgy2MzOTXOEqFUba/vSFOni1il5sVizN4MOMhg1lwzPqIp13p8Mjtz+TbIT4JA1k5/6hAZIgWOyRiHwIzbuGTtzJ2pYeRuF8QfFfwtDO5j49b6QFml3UBwg1fHD0PX1wUIBucTUo3ajpoLz49s7QGrYEd08xPcdraR7c8tF6hmsaj0TAeTGxI0TychFFzTMU2ESEoGttkHMLHSS/5bLp/e02DVNt/dXpy0SMTE7Kr+EH9kkBCtWNU+AEt6gx+ZXTFbQ/2gIUz55EctsxskdOqMlHyaM83o0RkRkZesQYqRtW5ZSpy5O35orKhabvpwZhMtq597UNP6Alo2yHlUrf0LeRsCsOGmC4lJGd6SLhiXW2MDYyJ3BzSKu47fhQE5Wq4ZJc9l5bL0tg0E6Z2NrCgN7t0X/fj80r+FciMcyjC6bmJs7GEozIwvZGvgy5+gbBHeNzj50OgZXRhIh7fmO9klyIjWNBDTNSSQovdRnAaGZzZpV82xa7iKUBw5sYC9aRZwpIHa69hsKVAbQhDC48BIW8JP3dxxRfQe8rvE4yvB9axywmykhTr8CSx7G27K5YN4eH5HBCfWMOTYvGyBMglb6JFjE9kkDSGfU1esjvYr1NaXMYCTJ5tHMBDOqP53eWHrNqCw0PIg2S3urReLMJcSheLKR8Y8R/ew2j8repURET9mgStMzoza7QbGyPuPrMd7QWXvi7vtcg+zoO/Iq/7ujwlPQYc5X9B3eS/ubphOyUsKqoV5zsMMmxOIV4uprD8sox6jo+L257RMp1TyVk0iPvwZ9CLCV2scGM/uek1bMpXjZf28TAHn8Bm45ONCJ96B4wQGloGeaUo0RrSbsgX7rBkgKecg3iXebkHzTFRjYzBr4u6yh7o3eAP8JAW8+OsPIi5EJNqnS7KvZ4YpmIPa6HX412/MdgsT+dflMWq+pjTu8vra2xBkMZCcy/QHJ6BxsrD9WU1Kw13C9+BbBzGX4v1LMKX2Xp679mk6/xhvmMM1GsKRXGebtxm45+NP3f25syBbNmbJRuwzeRuGr2hsjtT6ErdGwJ+roLJuzPUlt3ciptpxHSAMpQpP3EcTFLGg0kQzxDjGXbiGYbx3GA8N514bsJ4bjGe2048tziE2ttUT+QyNTjuT5K6nIo9Q2SHJFNF5wLenAt4iwFR7OooTXjkQT7QSR5Z+WzIbpGQpc6SSSmhueGqXhO57c37VWHteZrPjU4enCPH2p6s3qHjdpwm5NrBk/WrQzTNUHnr28j9LVZaFG9ICIVkzYsDXcsw+dCnojyMBJTi4cRF0rIS0qA3UoqCWwvpiXqWP4/tefcQOzPsMInDgwYvNOj25CAPe2qQ4fveesKjFOLM24fYnaEuo05geJlhAbWcYvKEYpqjO/3k/ZW5ECbqFE1PX0nR2xbd3rsKa67PywHPaDtlxtZ4dstbYh5xOmX6cF+L51SxZjzylGWgURVgYnFW2tgv6ET8ZGFGIXZbValFYQbDuUm5n2lXToN5bycnNddpcAfLIcRd/Qq33IRj3CuWLSJeBgbSZb2GhHu/zubr5klILp0WD+Rn4w91Nv9SRcI502JFI3ERJSb6Z4/LW5TMs5M4Z3g7/s9pXnkQHJ9JP882YK3C52Z8aHrwOkrPw0gQ0yCMaYAwvbF8nsH+Q78Vx45v9WDvx3ZqkRp0JwRNFxPc8jUPD4EuPFEGPhbMkR5kj51tDV69XM3ydp2C3yGuqIf8jGag3OI5GD3o93bwPtDMJVjpaYNE+Hf+pSd/1pPTL4nWhxDFeAAC+ik/r4PL0z4ezD78YGDYBzscqQzu/6nLKEGEDoMCHULIlpZNSaTPspNf/fnwKBkufyObDTl4IFT2qUDOYXPwRDabiwvk10C6bDIayoVbTs2Ve2It4+eVpnbbLWXgSktcmRqeqEyhS0qyADStGaioORH4rfjDAwx/7UiO5Y4RdXRavJ+Xd6KIPEJqvGR8fK3oDa5vdLw/b+T8h1SXAu/BnlFnCmF8esUphPHptacQxm9VqG9VqH+GKtS3Sktj32+Vlm+VllOmf1ylRZ2Ec2a4Z/VGKUKbePnmsXwL145UNxzVNZrJyeO8PwLOXc6P84rsC1A2B5SbNNb8slCVmenjT+rrd6RQLdb9mhbqXB3vNoK9iav5mkovNvPrD32p0Lnn8wzi7SlYpR//cd/PT2XZ8kXG0x3GMxTGkwo2vUXLxumDysIcI2lAl8XnGcv82tfGKwxvdXgHh7cd1DC4uicIw5JFpu46wXBj+WrWJEBowtz2PLNErWz6Bh+aBXxLQ6flsp0K3V8agV1cDn+63rzfW3ralIrsSHuea87nMhaQHr8P7ePw3u/MRPsTn2k6sNmq4eZaZrALNW9Ij/zZrfeInM/W3mPb6OAyMO5NOPFJZQT11GO34R0S7nFfrQX7W5kVCOyZJeINTQv72OzYU6f3nMy9dZveTyaxOJZ813e5e0kqLnafiK5Sm+TCPTMMSJKD6dgJ2nAlD5MeufZqMmQHSayDCeAhz4o0XyVFyTbWMHKF4UE57zjTsyqy270ZSYiK4a6chum9LQXc6l4CQhzEFk0zkOPoKoc9PbT+ruGyMwT+jpPbVt/vN3GVsW0G8NppVWx07U5niIYcJffGPN3MFik5jMiAOxus2JH5DeX6i4aga0FXQ5Yu0BZAdNvgU35k/vu+/lY89bVILoiBUzWa74IsG+qblwb/NsS9DXFvQ5hXQY2sxQu2dtP7vQ2oNjotRG5DqK9KMkAWjmDy6wjMEPoZlgNev+WXBgvEQp0v+THY6yhKefSDgAFmlOrr8fABOq2yoml4S9Zo7FGMnZN3GBDg8OwTH0niyiEwLyuDwD0iwA/GXu/fDU2ehTjipKSWpxnAhDRcKNR4lI1H1MhR+zALRc3S+ReTkZnGCyLkV0hYBKYpabBWNgR2QiyLOlPUZ0gqRWuGpJo1Uhlt0KS/sZBDxGKw+Pngy9aiiAsaC/X3YhJxrcZCY/JpJp5m8ikXTyBR+w2H5rc1hMKGJulx9Wbb7/r63oFxZsxMxhd84RwFDAyrg8tbgqFEH4QS6JVg3Jrb7N3gu76pspn0jOsofzfsaYPrsT0E57P5jJ053DCsiVS4+2na3mk0Y+eN9s6UxlVmwgG4eNwdZsI5Zkw/LcWTdJyZcCrOjK76GymEz03G/B755Mw8Qi24+Korf5OineCJSYXCOxKX2j0pBaard1nGf86QFWpzluflXu7AFpRZlxFmZV2Xmzb0xLqljQcxAhKBz4KSbRhxbQa0WDyaKGu0MJj9VmTF98vVtRdPHf7CluQi9gO0XIQgWr66cfhBkODe3g4OsFo6Rsv+tjt8t+4RtyutkVPuecT4UvhG/c6hqM4XcU/KYLuIWxmtbynxieJc3XNnVvO1ERX/P8Pm+nsjeBOPFrtiwWc+oBD1THOrsU35jcy/A1BLAwQUAAAACABxW5lYC52S6yUAAAAuAAAAKAAAAHB5cGxhbmVtb25vX21pbmltYWwvZ2VvbWV0cnkvX19pbml0X18ucHlLK8rPVdBLT83PTS0pqlTIzC3ILypR0OLlUk4Dy+RkpmeUwIUBUEsDBBQAAAAIANlcmVgKGpQ22A0AADZGAAAoAAAAcHlwbGFuZW1vbm9fbWluaW1hbC9nZW9tZXRyeS9nZW9tZXRyeS5wee0ca4/buPH7AvsfeJsPsVzb2Qda4BbwIWlyh7sPSa9JkBY4BAYt0V41sqToYVs+5L93hg+JFClZXido0Z4RrC1yXpwZDmdIKldXV5cXL8gmCcqIET+JCxrGYbwmfkTznOVklWQkDzcp9N69ImuWbFiRVZcXZc4CEsYkoxUpMuojTrIi/5xiQ5IWoZ/PLi+Adlk8JNk9+ZUWWeh/Iv+g8fry4scNDaN7korG2Q4anwch3SRxMKP+rPyEqB9YlodJfE+uZ7ez28uLV7Rg9+T2+vZuev399ObPCHOF8q+yZEMWi1VZlBlbLAiIm2QFCcJtiAQmJM3CuID+2C/g+fJCAsTlJq0IzUmcIi0+ZPKWVnevRsnyX8wvvPvLCwIfzgV/vBB64Vqhml5g0EgBQX6lGQUdgezieVp/xHOa5CFKQUAnCYh190q04+f9A2v6QZsFPHPS2LkFgYDtPfnAf7TxZHcbS/x9zcAKQYdEi0XG0gz0dk/yImuovmWgzzjHgYKZwL4IxnIGPmIJKNVTAOCyLNh/fuwtwwVsBeME1y4Wi1HOotWkZjaR6MrY+EGI2aIWZ14DNyACabGha+iO01kUxjRaz+Ik24wkwQY4XBnwc3KtMcNPRsOckQ80KtmPWZZkoysxUgLwIHQZwOSkcZwUZMnIgWXJldeWViphrrTxTGOp9CHUIMzN1aAP+gmBSU1WU2Htpj3jfkBWV2JqKFXMf+d81eMXpUfZLh6+eNIAz9MsSVlWVI0gCtMSRDI0jaC783PVOMtZAVOtgyZIhArtNSyHMGlbgoqh9IspYAxCoskSUaPWKWBjS+wHU7YdjKM1QesXsDEbFrRuX0F8BOjZ0IC1C4PiAabeKkpoYc470SWnHacq+h9YuH4o3Diyz4G0gIANOBAXTAwI00vGZzesJOEB16ioDu5S6O1x5C0YNfRN1G8fHeUAj4cjrsuJVM9EaGMixmX5h9D7XOC0+qR+55JSu5fraS7It/q2sm/b9A2IGnIWXAkX5BLNf/+iBiJ+IkH+ayt/eVcz8MYNLUbNeCa6/BNN3IkmHvf5xu/lKnLqcp0i2uAJsHc78h7SpSQLYFYWTFmbExZglRur6sc6uLEO3Vjf3oU18RYLGgSckLV+vwiCnBS7RIDDz2QNMqnAt1jk5dKN+K5cYgJZ6NgKiX3mOMskiRqElw/M/5Tjmqqxoxkj7HNJI4Uas1NQcWU10EH4sGAbTqNlEKU21M1+AhYF7+oxkBx+N713rDiRGFDK+iSjMUEQypMiiHs2hYjFnIARL/WBAcC6ie0G7gPNHxQycWMjiBPXT9LK7QaNMyKMEzlgLB1CAOG6qPDmx7APwrygsc9srf8UxoEYdg2zZMWOsdjyaB6ZOpcAtP+EHFz5Cqqap5k0g/R29JsE/TghQVGlbM5F8gameZ0p3pWKp3serSv+92DH670MyZX8Pnj2csEDhRxYgoHAsWgodoIo+ZMAbMjXLTWjusXFkoeYIyxVAaF4Ti2eU4vntIcnRqgjLJXVFjzAjDSTShz55KCOQewYdYhcZ3Co45xk84lVPak40PgNID4Sh/JtQj35d02ozsCNWcHjW1eqgb36GD0hik6Ah7cufOg00O2xiAjXhY+9OoFZkYj5NPIctETA6qJlzoAB06qJgVLPG7ZJzieMJL+SjCoIdvmtKDNFSFO1FtS/CAZBFJYu6vssz/mGkua7rmmll0R6pJx2e72jvNsfK0DRWa8/GlT2Vlm3P1ZyCipth3fI02kIndKNKU9lyVMNkedmiDyHIfLcmvIcLHkOQ+S5HSJPBA42QCSYlhyyNr8qGuolwKoauuoFu7g/sWZQ9cImTWJIr1V6odOtbIyqH+NgYxz6MYxa4X54sTCwUNBZNZWCuWVXlwkCuLtOMNHMIkHiKpRNGTlQtLQs4ZEmKH2hFZsCVJa9FPwsAbfop0GXeTsnbwg023hOXcVs3csf+kHT2w5sq0oyyxyl6eMlUjfe0PqoqzbqccrO2shZF/USctVFvTWRiW4VRd0FkYmoV0Q2pl4MmXh1MWPa3V2LmKhGLdSFbhVCOg1ZCZ3KGidTh5Mfm2diFp0zy3Clf9QUQ0QahQdmsX+jenILicbriHWxE516oWdImiUFVu+WfnmzzgqmV1LGAfon3YcG9mJ/Aj6fKDYJh4l7SVQ2icOJJA6SRL2sGqn9oIK33v/+KhVvfYBRr/x7eUixF1WuyGhFrSuy2vrcQic/pKRt15eyXoXMr13UQvLVrmoh//kvKWv5ktrFE9aHEPJzmebz7gkZ8WpTWEUH7hZyLDGFgMbTQTx51jh1TK5dHZnrVsefHRwFFC713bUJOJwIQ5mMhHFK4oD7IFmWRT0GwvYpw3xE+iVJMSPMG1J+KtyXUxvpbl3X5NYxYVtPfop+A39v+F+nd/C0o8vlnTWSwVYnxbOQLlK1UFNVB05VITjtrFYfuzvSpyhT4sfvjwzlccoOiSDCdzYc8/iEHRKN0JlbJJ3jGrhH0ok/eJNEnoOesUvSChxfcZvkVMp9+ySn0oJ06YjvnhvtmtjjjHVdsax7ZIPimTXQOvacGaHqJG6gBZ7xL07XU9ZwtB30Nospz/OGxDDfT6Re0LAC9NlIIy2tJPlYjES2JTlhBjURvHV+2AzxAL9mjTZ6VhDpQWg3kE7QA7cZ3cDqbzR6Y050L78ABrphkZfd4xFvr8Z17sCfD+K58ibmgq9/pM8OFqGSXx0iSJZ7JcJeinRUhMNwEQ7yq0MEybJSIkit7LtsulB7g5Y9+yNHS+CpNo5GJh24aW1Cgzm+DgGr0wS0NNknmMoP9mdJeDhLwqlTSRPSJ1hL/c4wfvpuslzYz91Orsmcv58sSZ27oVyTOX9HWZI6d0u5JuPKoIpE7BILSaY/qFMOjUpdueLnZRLjBSKj5i0SQu2TZANt6BGKdqUlovHAq1xygzpFDDW2v1K8mJvEXM5dkn3C3ZDXtIDHHfmZxsHQWy9jmq21cubHkB/QUHlwQ3HHQi7IpE4DcFMtY0xdrAA9i8vE/CgdpZw0qXgUfmLD740iz3uiYyrBXsheOWRDGVI+NyK/HaYPoD7010l804s1gpGgNOSqC8Jb+7gweDAijODvfeiKXQOOW6I8I5EdoABQ0l1gbNwYJYe+dcPdo7UpgEUDb3bdcOV3sEdXb2DOZOtyw9BB1uGW4fVszp+CDbNwHcZkB76mTDO6nhD4d+MRZB9CwgP+/R15nzEaEB9UsSqjqPpOvw7bRAD73oSgdv3RCS5Z2vA3H+UU7Rrs7X0fewSrI34HSw6DMbiBYlGbzV2LzfZGYUKQm7r5bG8b6jqMzsmtApHpb28gwN569h3UNkSvBTS2BkAAfVOd9UxVRc3hre6DXXdaeq608HjKafHrLIKNfadF3ZfQhflW9z3ktQUMok5gwV1BO2Rx3qauV7PeY1GTDD8otS9RK1L9x7X6TGluJHfKN+y2ty3imVe9TxVUqLtfTAFjyCndty2lRq1TRjvuKCH1CSWenoAgMSzcTRxffG64NWuB7qOQNRdJNL9h0794nfnNOUsFftr5BH7a6yV+BJ17kecgJf5WgTlUXJrd/BQEDsi+iadw6TJPIkgnIEOLWMZv5K2SzHlG1U4Ccn1Mch3vH5C55HIRspJ1arLoGNuE/ESjXPbtYJXTVCuyRwR9k8TMHq/MgDT7Y5ZxugRI3SVA7SnGCmifAXCbdmz+y33YMPejJGfNvogM+UaogxV3di29Fv94Eznw1uJoS8CdqS1BuBrGXW47wZJvcm+Rw88OZquK5fJdElljti4rqc+K+vVSpzHe4cLaK41NilttURsU3wOAmhUZjImOqgrZDomkXdBZJ22arsjTaD5nDo3YbzC9r50PFzo8QMHMFc9JoohFV55J+okSCE/3wLIkCFcrluFZP9RZeh9/3S9ccarcDegy2WreKjLNp2/A5A8AE0G++LR+b+CJeFdG1lE0wjyyEpUKC/54neaP12laff8Hr9PwkwIa+Yslo5tFjjvKLALPz5KYP0m/c++v1pBArRdwR7dM3KHpBVO3R3uBBtABR10kK5B/vaH5/M4NBKsHejFKz7ahz+ZPyzgoI7wj9NQj0x8Eg3YAeAm6QiDGPRKVRlBNZKlvvSi9iC4MVaAglq0ZjG1wrDDM4J7/Jh8onstNC1fM5D7URjJOIKMy0WpMxtfP9CEpgB6LAbhCSP3I2+x08hMgpMFnH+SE6Hy14r3+UgWP+6jbPCkzH5O7JiTUWQ6Rw5dyOymaV7lqJyDCCTQihhP1h0MJAzLh7ebdA4v5nEI/UTtgtaeofRvT+doREenz9Y7ndaaME3wbGF8F1hwW87inu3C9hpT36QSjDC2jAldSDUiPQ0Z223Y9h9revn6nbNg4PS0aA6HiNlZwDlf2UOdzXSg9HnPTCn+fi6ikNZlxaaI56EQa1bNIiSCsU4KWkT47jtBpqvr8cwYRthFnPL7FU6SG7FipwoMub3zD7saGC6mZaSRQInGCbOUX3M3FjTEWyAzqb3FUkVpPaEq/zDAlgua8TPE/MWCBvvUlcpw6oHeqToVOPSrLFv3JOxoCc31CmlEQqqxtGMDvtI5y3zzwWXHLnWc1/YAXb/RJ8VXixuPnl67Jhl6t95YvmkYd8wJfOmUzRmz+fix+Pxvd4qlWGqJ/ep7LWdqzw+UqxPQV8hhn0Radr+syj1vv/lc8xxxbvZQf9yAMXz0OhJ4jQ6Pn/RtQSwMEFAAAAAgA5l2ZWEadvYKEAgAARQQAACkAAABweXBsYW5lbW9ub19taW5pbWFsLTEuMC5kaXN0LWluZm8vTElDRU5TRV1SS2/bMAy+G/B/IHJqAaMbuttuqq00wvyCrDTLUbGVWJtjBZayoP9+pJO264AAgUh+L9KFUJDb1ozexFHqTq+TPfQB7tp7ePz6+A1qHSbb/obtuTfjATZ6PMRRHNVmOlrvrRvBeujNZHavcJj0GEyXwH4yBtwe2l5PB5NAcKDHVziZySPA7YK2o0U2DS0qxhGOhh55vNuHi54MTnegvXet1UgInWvPRzMGHUhwbwfj4S70BhbNDbG4n1U6o4c4siNQ860HFxt6dw4wGU9hiCQBO7bDuSMXb+3BHu1NguDzInwcIe3ZYwiymsDRdXZP/2ZOdjrvBuv7BDpL3LtzwKKn4rzShJJ8cRN4M6AxpLBofY774W8eIvcnWmq4rclT5dK74+csFh3tz9OIomYGdQ7XNmv+Mm2gCs3v3TC4C6Vr3dhZCuW/0+EUNvXO/TFznuuxRxfQ7tUFneH0cdxby/d6GGBnbltDZdyx/jfSRA58wA/A6gFObpol/4/6MFtYcWiqpdowyUE0UMvqRWQ8gwVr8L1IYCPUqlorwAnJSrWFagms3MIPUWYJ8J+15E0DlYwjUdS54FgUZZqvM1E+wxMCywq/alEIhayqAlK8cQneEFvBZbrCJ3sSuVDbJI6WQpXEuqwkMKiZVCJd50xCvZZ11XA0kCFvKcqlRBle8FI9oCzWgL/gA5oVy3PSiiO2xgCSLEJa1VspnlcKVlWecSw+cfTGnnJ+1cJcac5EkUDGCvbMZ1SFNBiP5q4GYbPiVCNFhr9UiaqkJGlVKonPBINK9Y7diIYnwKRoaCdLWRWYkXaKkGpmQWDJrzS0b/h0Fhyh97rh74yQcZYjWUPgOeXb9MNfUEsDBBQAAAAIAOZdmVgATVrDRAIAACYEAAAqAAAAcHlwbGFuZW1vbm9fbWluaW1hbC0xLjAuZGlzdC1pbmZvL01FVEFEQVRBfVPbTtxADH2PlH+w1FeSFlAltGpREZd2JRZQl5a+Vd6Js3GZW2cmLPn7epKFskitFEUZe87x8bGzoIQNJqy+U4js7AwO6v2yuEJDM/CD12jJOOt+GrZsUJfF88X9+l1ZLHtjMAwz+FEFHCAFVGzX0LoAIxbWAVOOZBLVBWcwuVDDYqKDh4kNNpw6sA7YJgotKoLkYPnl5Oz6ri6Lkz51LlRkkPUMbjAFVvdwh8L7wU+neiOnTw2jFGpqVHV/f1wWpxpj5JYpCCw4EWNMVnMpl3tcE8wkPgi5zV+Hu4BLVmTjeOd6OYcT74N7oCafF/Pbp/Qu5trTtuHlEBOZCQxz25AnedlUFl/pd8+BYjVVnsHxx8P6KLt5RlEF9kkcqU6dWGFTdTt4GUWix/RWnL5v3MaWxbZ2dcFakpfz0/Or5fkL5jOOaQa2N34Q9v364DDTv0pHxdv0UZ75q6wMymuXNK9Gfe/rg7Ioizcvl6J6XoqyuO04gjwIY5CjGPU0XNdC6kiMvsnIhSBBrPxFKu3BpmPVTUCFWvUac/cQe040rlFGrskZSmF4Yvrvao1KAnkXWc4DKDES2UZwVg/TK3MoF2inJFpRzLFHzXGKtL1V+UMiiSmON0T7529zQRvvrMwnlkUOS0nrkvB5XGnKOsdNRjUqHLd72mbA3KoPVIkFimLMki+kz7bXeqfisCddtBTyn/DC9G2D8hhCm3J2RdDIzAKv+iS2j9Vyi9Iri09//6l/D2ICGXxk0xvwLiRccRZR5+H+AVBLAwQUAAAACADmXZlY/A57S1wAAABcAAAAJwAAAHB5cGxhbmVtb25vX21pbmltYWwtMS4wLmRpc3QtaW5mby9XSEVFTAvPSE3N0Q1LLSrOzM+zUjDUM+ByT81LLUosyS+yUkhKySwuiS8HqVHQMNAzMdYz0OQKys8v0fUs1g0oLUrNyUyyUigpKk3lCklMt1IoqDTWzcvPS9VNzKvk4gIAUEsDBBQAAAAIAOZdmViGVnG/FgAAABQAAAAvAAAAcHlwbGFuZW1vbm9fbWluaW1hbC0xLjAuZGlzdC1pbmZvL3RvcF9sZXZlbC50eHQrqCzIScxLzc3Py4/PzczLzE3M4QIAUEsDBBQAAAAIAOZdmVjYDGm7SAIAAEcEAAAoAAAAcHlwbGFuZW1vbm9fbWluaW1hbC0xLjAuZGlzdC1pbmZvL1JFQ09SRI3Ty5KiMBSA4X0/C9iAQGAxC24qKghIi+OGQjtgxIQI4TZPP27ssqasnt6dbL7/JFWhI71mBOKKVClGBOHs+p6m94Gl6YSOXHPOJEX9JQPbCelFW5jbjE9jFye8srRgG8KoxIrv0WVymE/P23b2wQlv9AUKrxBDwppXutVV47Q+rQZbNWF0XP32+3zYF0PclscYRNm5SC6ikg0u6TlV+Z4v6owhUjzpbuhpe2wG3dod0wsb4iqXDNb7Qd6SeXTuiEwMGSmttus5EUy1/+yPUV1X9ZPvuyjuLdQ0lHlD7o63zQ4bNQiBFecyMiWSCeEBbPaOot19QVC/92mBn/AxW6y02e50AGUALruZsDlYqli0cupIUmK2evGpllJai6rHSQBo4ku8gBWGrB5fPb4UnJWRDxM7Ol+kOcahCojTV4AxtGog5aMpsWwJQS0+cfLr3b/4x/DEZ/5nJBvTgSyCq30KOrnf8JEUbjTDXoP1Vj4AxHcNpdWf8v46OpBfFXhxIkw+UcN4RPLqfe1ajr91vm4AG+qQ3D/eTHs5JmQsFarHEE+Z5yQndFsIhcD3+v1UcKKgT39Q8JzYsI3YeCQEnuTeVlatUbnc6mo0slui0TUg+/JWB4c2d4/b3KlT0TLuCVX6QSJZOM764c+XgKVlYs7G/pgVKwVWult99OtErcYNjFc45HW0mO38IeT0n+isoukVdvA6YQN7VKq2AAUKQ2Qm5y3xTvIgz4tOb2Wal4aP9qy7uF3pGXA4cdLLb/BPJXKsTWRz3NtfUEsBAhQAFAAAAAgAcVuZWAAAAAACAAAAAAAAAB8AAAAAAAAAAAAAALaBAAAAAHB5cGxhbmVtb25vX21pbmltYWwvX19pbml0X18ucHlQSwECFAAUAAAACABxW5lY05YJpCkAAABBAAAAKAAAAAAAAAAAAAAAtoE/AAAAcHlwbGFuZW1vbm9fbWluaW1hbC9lbGVtZW50cy9fX2luaXRfXy5weVBLAQIUABQAAAAIALxdmViGlHaXdA8AAORDAAAnAAAAAAAAAAAAAAC2ga4AAABweXBsYW5lbW9ub19taW5pbWFsL2VsZW1lbnRzL2dyYXRpbmcucHlQSwECFAAUAAAACAC6XZlYRGXy4Y0OAABuQgAAJgAAAAAAAAAAAAAAtoFnEAAAcHlwbGFuZW1vbm9fbWluaW1hbC9lbGVtZW50cy9taXJyb3IucHlQSwECFAAUAAAACAC3XZlYgVRO2coTAACFbAAAIwAAAAAAAAAAAAAAtoE4HwAAcHlwbGFuZW1vbm9fbWluaW1hbC9lbGVtZW50cy9wZ20ucHlQSwECFAAUAAAACABxW5lYC52S6yUAAAAuAAAAKAAAAAAAAAAAAAAAtoFDMwAAcHlwbGFuZW1vbm9fbWluaW1hbC9nZW9tZXRyeS9fX2luaXRfXy5weVBLAQIUABQAAAAIANlcmVgKGpQ22A0AADZGAAAoAAAAAAAAAAAAAAC2ga4zAABweXBsYW5lbW9ub19taW5pbWFsL2dlb21ldHJ5L2dlb21ldHJ5LnB5UEsBAhQAFAAAAAgA5l2ZWEadvYKEAgAARQQAACkAAAAAAAAAAAAAALaBzEEAAHB5cGxhbmVtb25vX21pbmltYWwtMS4wLmRpc3QtaW5mby9MSUNFTlNFUEsBAhQAFAAAAAgA5l2ZWABNWsNEAgAAJgQAACoAAAAAAAAAAAAAALaBl0QAAHB5cGxhbmVtb25vX21pbmltYWwtMS4wLmRpc3QtaW5mby9NRVRBREFUQVBLAQIUABQAAAAIAOZdmVj8DntLXAAAAFwAAAAnAAAAAAAAAAAAAAC2gSNHAABweXBsYW5lbW9ub19taW5pbWFsLTEuMC5kaXN0LWluZm8vV0hFRUxQSwECFAAUAAAACADmXZlYhlZxvxYAAAAUAAAALwAAAAAAAAAAAAAAtoHERwAAcHlwbGFuZW1vbm9fbWluaW1hbC0xLjAuZGlzdC1pbmZvL3RvcF9sZXZlbC50eHRQSwECFAAUAAAACADmXZlY2Axpu0gCAABHBAAAKAAAAAAAAAAAAAAAtIEnSAAAcHlwbGFuZW1vbm9fbWluaW1hbC0xLjAuZGlzdC1pbmZvL1JFQ09SRFBLBQYAAAAADAAMAAAEAAC1SgAAAAA=", "type": "binary"}, {"name": "pyplanemono_minimal\\dist\\pyplanemono_minimal-1.0.tar.gz", "content": "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", "type": "binary"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\__init__.py", "content": "", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\__init__.py", "content": "from .mirror import *\nfrom .grating import *\nfrom .pgm import *", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\grating.py", "content": "from __future__ import annotations\nimport numpy as np\nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Plane, Ray3D\nfrom scipy.constants import c, h, e\n\n\nclass Grating(object):\n    \"\"\"\n    A class for a simple grating\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    dimensions : array_like\n        The dimensions of the grating in mm [length, width, height],\n        dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    \n    Attributes\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    alpha : float\n        The incident angle of the beam in degrees\n    beta : float    \n        The diffraction angle of the beam in degrees\n    dimensions : array_like\n        The dimensions of the grating in mm\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    Methods\n    -------\n    set_angles(alpha, beta)\n        Set the incident and diffraction angles of the grating\n    energy_to_wavelength()\n        Calculate the wavelength of the beam in Angstroms\n    compute_corners()\n        Compute the corners of the grating in the global coordinate system\n    diffract(*args)\n        A method to diffract rays off the grating\n    compute_beta(alpha, line_density, energy, order)\n        Calculate the diffraction angle beta from the incident angle alpha\n    reflect(*args)\n        A method to 'reflect' rays off the grating\n    \"\"\"\n    # Run a code formatter and linter to fix code style adn syntax errors. Black & Falke8 are good for this.\n    def __init__(self, \n                 line_density=600, \n                 energy=2400, \n                 cff=2, \n                 order=1, \n                 dimensions = np.array([200,40,50]), \n                 borders = np.array([0,0,0,0])):\n\n        self._line_density=line_density\n        self._energy=energy\n        self._cff=cff\n        self._order=order\n        self._alpha = None\n        self._beta = None\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._borders = borders\n        _,_ = self.compute_angles()\n        _ = self.compute_corners()\n\n\n\n    def __repr__(self):\n        # Use f-strings\n        return f\"Grating(line_density={self.line_density},\\n energy={self.energy}, \\n cff={self.cff}, \\n order={self.order}, \\n dimensions={self.dimensions},\\n borders={self.borders})\"\n    \n    def read_file(self, filename):\n        \"\"\"\n        Read grating parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['grating']) != 6:\n            # You could add config['grating'] into the error message\n            raise ValueError(\"Expected exactly five parameters in grating file\")\n\n        # Could use tuple instead of list\n        variables = ('line_density', 'energy', 'cff', 'order', 'dimensions')\n        for var in variables:\n            if var not in config['grating']:\n                raise ValueError(\"Missing parameter {} in grating file\".format(var))\n            \n        # You already check if variables in config['grating'] above and repeat below.\n        # Could use sets to create items from variable and config['grating'] to avoid list comprehension.\n        items = [x for x in variables if x in config['grating'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['grating'].values()):\n            setattr(self, key, value)\n            print(key)\n            print(value)\n        \n        self._order = int(self._order)\n        self._dimensions = np.array([float(x) for x in config['grating']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['grating']['borders'].split(',')])\n\n    @property\n    def line_density(self)-> float:\n        return self._line_density\n    \n    @line_density.setter\n    def line_density(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive line density\")\n        else:\n            self._line_density = value\n\n    @property\n    def energy(self)-> float:\n        return self._energy\n    \n    @energy.setter\n    def energy(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive energy\")\n        else:\n            self._energy = value\n        \n    @property\n    def cff(self)-> float:\n        return self._cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if value <= 1:\n            raise ValueError(\"Expected positive cff\")\n        else:\n            self._cff = value\n    \n    @property\n    def order(self)-> int:\n        return int(self._order)\n    \n    @order.setter\n    def order(self, value: int)-> None:\n        if value >= 1 and isinstance(value, int):\n            self._order = value\n            print(\"order set!\")\n        else:\n            raise ValueError(\"Expected positive integer order\")\n\n    @property\n    def alpha(self)-> float:   \n        return self._alpha\n    \n    @alpha.setter\n    def alpha(self, value)-> None:\n        if np.abs(value) <= 180 and isinstance(value, (float, int)):\n            self._alpha = value\n        else:\n            raise ValueError(\"Expected float alpha with magnitude less than 180 degrees\")\n\n    @property\n    def beta(self)-> float:\n        return self._beta\n    \n    @beta.setter\n    def beta(self, value: float)-> None:\n        self._beta = value\n    \n    @property\n    def dimensions(self):\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value):\n        if len(value) != 3:\n            raise ValueError(\"Expected exactly three values for dimensions\")\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._grating_plane\n    \n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._grating_plane = value\n        else:\n            raise TypeError(\"Expected Plane object for plane\")\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value: np.ndarray)-> None:\n        if len(value) != 4 or not isinstance(value, np.ndarray):\n            raise ValueError(\"Expected exactly 1D array of length 4 for borders\")\n        else:\n            self._borders = value\n\n\n    def set_angles(self, alpha: float, beta: float)-> None:\n        \"\"\"\n        Set the incident and diffraction angles of the grating.\n\n        Parameters\n        ----------\n        alpha : float\n            The incident angle in degrees\n        beta : float \n            The diffraction angle in degrees\n\n        Raises\n        ------\n        ValueError\n            If the wavelength is zero\n\n        \"\"\"\n        wavelength = (np.sin(np.deg2rad(alpha)) + np.sin(np.deg2rad(beta))) / (self.line_density*1000*self._order)\n        \n        if wavelength <= 0:\n            raise ValueError(\"Expected positive, non-zero wavelength\")\n\n        else:\n            self._energy = 12398.42 / wavelength #converts wavelength to eV\n        \n        self._alpha = alpha\n        self._beta = beta\n        self._cff = self.cff\n\n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value:any)-> None:\n        print(\"Input ignored, corners are computed from dimensions\")\n        self._corners = self.compute_corners()\n\n    def compute_beta(self)-> float:\n        \"\"\"\n        Compute the diffraction angle beta from the incident angle alpha.\n\n        Returns\n        -------\n        beta : float\n            The diffraction angle in degrees\n        \n    \n        \"\"\"\n        beta = 0\n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        u = self.order*self.line_density*1000*wavelength - np.sin(np.deg2rad(self.alpha))\n        beta = np.rad2deg(np.arcsin(u))\n        \n        \n        return beta\n\n    def compute_angles(self)-> tuple[float, float]:\n        \"\"\"\n        Compute the incident and diffraction angles of the grating.\n        The incident angle is calculated from the diffraction angle\n        using the fixed focus constant.\n\n        Returns\n        -------\n        alpha : float\n            The incident angle in degrees\n\n        beta : float\n            The diffraction angle in degrees\n        \n        \"\"\"\n        \n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        print(self.energy,\n              self.order,\n                self.line_density,\n                self.cff,\n               wavelength)\n        \n        lambda_u = self.order*self.line_density*1000*wavelength/(1-self.cff**2)\n        sin_alpha = lambda_u + np.sqrt(1+lambda_u**2*self.cff**2)\n        self._alpha = np.rad2deg(np.arcsin(sin_alpha))\n        self._beta = -np.rad2deg(np.arccos(np.cos(np.arcsin(sin_alpha))*self.cff))\n\n        return self._alpha, self._beta\n\n    # Could add type annotations on all your functions\n    def diffract(self, *args: Ray3D | list )-> list:\n        \"\"\"\n        A method to diffract rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be diffracted\n\n        Returns\n        -------\n        diffracted_rays : list of Ray3D\n            A list of diffracted rays\n\n        Raises\n        ------\n        raises ValueError too\n        TypeError\n            If the rays are not Ray3D objects\n\n        \"\"\"\n        diffracted_rays = []\n        \n\n        if isinstance(args[0], list):\n            args = args[0]\n\n        elif len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n\n        for _, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            raydotplane = ray.vector.dot(self._grating_plane.normal)\n            angle = np.arccos(raydotplane/np.linalg.norm(self._grating_plane.normal))\n            alpha = np.rad2deg(np.pi/2-angle)\n            beta = self.compute_beta()\n            diff_ray = self.reflect(ray)[0]\n            angle = -90 - beta - alpha\n            diff_ray.vector[2] += np.cos(np.deg2rad(angle))\n            diff_ray.vector[1] += np.sin(np.deg2rad(angle))\n            diff_ray.vector = diff_ray.vector/np.linalg.norm(diff_ray.vector)\n            diffracted_rays.append(diff_ray)\n        return diffracted_rays\n    \n    \n\n    # rename something like energy_to_wavelength\n    def energy_to_wavelength(self, energy: float)-> float:\n        return h*c/(e*energy)\n    \n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the grating in the global coordinate system.\n\n        Returns\n        -------\n        corners : array_like\n            The corners of the grating in the global coordinate system:\n            [bottom left back, \n            bottom right back, \n            bottom left front, \n            bottom right front,\n            top left back,\n            top right back,\n            top left front,\n            top right front]\n        \"\"\"\n        \n        beta = np.deg2rad(self._beta)\n        # beta_g not used\n        beta_g = np.deg2rad(self._beta + 90)\n        l = self._length()\n        w = self._width()\n        d = self._height()        \n        #Bottom left back\n        blbz = (l/2)*np.sin(beta)\n        blby = -(l/2)*np.cos(beta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        #Bottom left front\n        blfz = -(l/2)*np.sin(beta)\n        blfy = (l/2)*np.cos(beta)\n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = blbz - d*np.cos(beta)\n        tlby = blby - d*np.sin(beta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Top right back\n        trbz = brbz - d*np.cos(beta)\n        trby = brby - d*np.sin(beta)\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Top left front\n        tlfz = blfz - d*np.cos(beta)\n        tlfy = blfy - d*np.sin(beta)\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Top right front\n        trfz = brfz - d*np.cos(beta)\n        trfy = brfy - d*np.sin(beta)\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        self._grating_plane = Plane(\n            Point3D(blfx, blfy, blfz),\n            Point3D(brfx, brfy, brfz),\n            Point3D(blbx, blby, blbz)\n        )\n\n        self._corners = np.array([\n            blb,\n            brb,\n            blf,\n            brf,\n            tlb,\n            trb,\n            tlf,\n            trf\n        ])\n\n        return self._corners\n\n    def reflect(self, *args, zero_order = False)-> list:\n        \"\"\"\n        A method to reflect rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        # Check after determining if list\n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        # se isinstance\n        if type(args[0]) == list:\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._grating_plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect grating, tread with caution!')\n                continue\n            ray_array = ray.vector\n            grating_normal = self._grating_plane.normal\n            if zero_order:\n                \n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, -grating_normal) * grating_normal\n            else:\n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, grating_normal) * grating_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n\n    @classmethod\n    def grating_from_file(cls, filename):\n        \"\"\"\n        Create a grating from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        grating = cls()\n        grating.read_file(filename)\n        return grating\n    \n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\mirror.py", "content": "from __future__ import annotations\n# List not used\nfrom ast import List\nfrom matplotlib.pyplot import isinteractive\nimport numpy as np\nfrom pyplanemono_minimal.geometry import Point3D, Vector3D, Plane, Ray3D\nimport configparser\n\nclass Plane_Mirror(object):\n    \"\"\"\n    A class for a simple plane mirror.\n\n    Parameters\n    ----------\n    voffset : float, optional\n        The vertical offset of the mirror in mm\n    hoffset : float, optional\n        The horizontal offset of the mirror in mm\n    axis_voffset : float, optional\n        The vertical offset of the mirror axis in mm\n    axis_hoffset : float, optional\n        The horizontal offset of the mirror axis in mm\n    dimensions : array_like, optional\n        The dimensions of the mirror in mm [length, width, height]\n        Dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    theta : float, optional\n        The angle of the mirror in degrees\n    plane : Plane, optional\n        The plane of the mirror\n    borders: array_like, optional\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    \n\n    Attributes\n    ----------\n    dimensions : array_like\n        The dimensions of the mirror in mm\n    position : Point3D\n        The position of the mirror\n    normal : Vector3D\n        The normal vector of the mirror\n    orientation : Vector3D\n        The orientation of the mirror\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    plane : Plane\n        The plane of the mirror\n    \n    borders: array_like\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    Methods\n    -------\n    set_position(position)\n        Set the position of the mirror\n    set_normal(normal)\n        Set the normal vector of the mirror\n    set_orientation(orientation)\n        Set the orientation of the mirror\n    set_dimensions(*args)\n        Set the dimensions of the mirror\n    set_offsets(voffset, hoffset, axis_voffset, axis_hoffset)\n        Set the offsets of the mirror\n    compute_corners()\n        Compute the corners of the mirror in the global coordinate system,  \n    \n    \n    \"\"\"\n\n    def __init__(self, \n                 voffset=13, \n                 hoffset=40, \n                 axis_voffset=6.5, \n                 axis_hoffset=0, \n                 dimensions = np.array([450, 70, 50]),\n                 theta=45, \n                 plane=Plane(),\n                 borders = np.array([0,0,0,0])\n                 ):\n        \"\"\"\n        Constructor for the Plane_Mirror class.\n\n        Parameters\n        ----------\n        voffset : float\n            The vertical offset of the mirror in mm\n        hoffset : float\n            The horizontal offset of the mirror in mm\n        axis_voffset : float\n            The vertical offset of the mirror axis in mm\n        axis_hoffset : float\n            The horizontal offset of the mirror axis in mm\n        dimensions : array_like\n            The dimensions of the mirror in mm [length, width, height]\n            Dimensions are also accessible with lambda functions as:\n            self._length(), self._width(), self._height()\n\n        \n        theta : float\n            The angle of the mirror in degrees\n        plane : Plane\n            The plane of the mirror\n        \n        \"\"\"\n\n        self._voffset = voffset\n        self._hoffset = hoffset\n        self._axis_voffset = axis_voffset\n        self._axis_hoffset = axis_hoffset\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._plane = plane\n        self._theta = theta\n        # Just call method without assigning to _\n        _ = self.compute_corners()\n        self._borders = borders\n\n\n    def __repr__(self):\n        # Use f-string\n        return \"\"\"Plane_Mirror(voffset={}, \n        hoffset={}, \n        axis_voffset={}, \n        axis_hoffset={}, \n        length={}, \n        width={}, \n        height={}, \n        plane={},\n        borders={})\n        \"\"\".format(self.voffset,\n                            self.hoffset, \n                            self.axis_voffset, \n                            self.axis_hoffset, \n                            self._length(), \n                            self._width(), \n                            self._height(), \n                            self.plane,\n                            self.borders)\n    \n\n    # read_file is very similar to read_file in grating.py. Refactor to use common code.\n    def read_file(self, filename):\n        \"\"\"\n        Read mirror parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['mirror']) != 7:\n            raise ValueError(\"Expected exactly six parameters in mirror file\")\n\n        variables = ['voffset', 'hoffset', 'axis_voffset', 'axis_hoffset', 'dimensions', 'theta']\n        for var in variables:\n            if var not in config['mirror']:\n                raise ValueError(\"Missing parameter {} in mirror file\".format(var))\n        \n        items = [x for x in variables if x in config['mirror'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['mirror'].values()):\n            # Don't use exec. Either explicitly assign variables or if you will not know what they will be, use a dictionary not variables.\n            exec(f\"self._{key} = float({value})\")\n            print(key)\n            print(value)\n        \n        \n        self._dimensions = np.array([float(x) for x in config['mirror']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['mirror']['borders'].split(',')])\n        \n\n    @property\n    def voffset(self)-> float:\n\n        return self._voffset\n\n    @voffset.setter\n    def voffset(self, value: float)-> None:\n        if isinstance(value, float):\n            self._voffset = value  \n        else:\n            raise TypeError(\"Expected voffset to be float!\")\n    @property\n    def a(self)-> float:\n        return self._hoffset\n    \n    @a.setter\n    def a(self, value: float)-> None:\n        self.hoffset = float(value)\n\n    @property\n    def hoffset(self)-> float:\n        return self._hoffset\n\n    @hoffset.setter\n    def hoffset(self, value: float):\n        if isinstance(value, float):\n            self._hoffset = value\n        else:\n            raise TypeError(\"Expected hoffset to be float!\")\n\n    @property\n    def c(self)-> float:\n        return self._voffset\n    \n    @c.setter\n    def c(self, value: float)-> None:\n        self.voffset = float(value)\n\n    \n\n    @property\n    def axis_voffset(self)-> float:\n        return self._axis_voffset\n\n    @axis_voffset.setter\n    def axis_voffset(self, value: float):\n        if isinstance(value, float):\n            self._axis_voffset = value\n        else:\n            raise TypeError(\"Expected axis voffset to be float!\")\n\n    @property\n    def v(self)-> float:\n        return self._axis_voffset\n    \n    @v.setter\n    def v(self, value: float)-> None:\n        self.axis_voffset = float(value)\n\n\n    @property\n    def axis_hoffset(self)-> float:\n        return self._axis_hoffset\n\n    @axis_hoffset.setter\n    def axis_hoffset(self, value:float):\n        if isinstance(value, float):\n            self._axis_hoffset = value\n        else:\n            raise TypeError(\"Expected axis hoffset to be float!\")\n\n    @property\n    def h(self)-> float:\n        return self._axis_hoffset\n    \n    @h.setter\n    def h(self, value: float)-> None:\n        self.axis_hoffset = float(value)\n    \n\n    @property\n    def dimensions(self)-> np.ndarray:\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value:float):\n        \"\"\"\n        Sets the dimensions of the mirror.\n        The dimensions are specified as:\n        [length, width, height]\n\n        \"\"\"\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._plane\n\n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._plane = value\n        else:\n            raise TypeError(\"Expected value to be Plane instance!\")\n    \n    @property\n    def theta(self)-> float:\n        return self._theta\n    \n    @theta.setter\n    def theta(self, value: float)-> float:\n        self._theta = value\n    \n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value):\n        print(\"Input value ignored, corners computed from parameters!\")\n        self.compute_corners()\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value)-> None:\n        \"\"\"\n        Sets the borders of the mirror.\n        The borders are specified as:\n        |-----------Top------------|\n        |                          |\n         Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n        \"\"\"\n        if isinstance(value, np.ndarray) and len(value)==4:\n            if all(value > 0):\n                self._borders = value\n            else:\n                raise ValueError(\"Lengths should be positive.\")\n        else:\n            raise ValueError(\"Expected 1D numpy array with length 4\")\n\n\n    def set_position(self, position: Point3D)-> None:\n        if isinstance(position, Point3D):\n            self._plane.position = position\n        else:\n            raise TypeError(\"Expected Point3D instance for position value!\")\n\n    def set_normal(self, normal: Vector3D)-> None:\n        if isinstance(normal, Vector3D):\n            self._plane.normal = normal\n        else:\n            raise TypeError(\"Expected Vector3D instance for normal value!\")\n\n    # Combine with setter\n    def set_dimensions(self, *args: np.ndarray | float)-> None:\n        \"\"\"\n        Set the dimensions of the mirror.\n\n        Parameters\n        ----------\n        *args : array_like\n            Either one or three arguments for the dimensions\n\n        Raises\n        ------\n        ValueError\n            If the number of arguments is not one or three\n\n        \"\"\"\n        # compute length once and assign to variable. Can use this in error msg.\n        # Will raise ValueError if args does not have length, so check that too.\n        length_of_args = len(args)\n        if length_of_args == 1:\n            self._dimensions = args[0]\n        elif length_of_args == 3:\n            self._dimensions = np.array(args)\n        else:\n            raise ValueError(f\"Expected either one or three arguments for dimensions, got length of {length_of_args} instead.\")\n\n    def set_offsets(self, voffset: float, hoffset: float, axis_voffset: float, axis_hoffset: float)-> None:\n        self.voffset(voffset)\n        self.hoffset(hoffset)\n        self.axis_voffset(axis_voffset)\n        self.axis_hoffset(axis_hoffset)\n\n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the mirror in the global coordinate system,\n        in addition to the plane and normal of the mirror.\n    \n\n        Returns\n        -------\n        corners : np.ndarray\n            The corners of the mirror in the global coordinate system\n            [top left front,\n            top right front,\n            bottom left front,\n            bottom right front,\n            top left back,\n            top right back,\n            bottom left back,\n            bottom right back]\n        \n        \n        \"\"\"\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.theta)\n        theta_g = 90 - self._theta\n        theta_g = np.deg2rad(theta_g)\n        a = self._hoffset\n        c = self._voffset\n        v = self._axis_voffset\n        h = self._axis_hoffset\n        w = self._width()\n        l = self._length()\n        d = self._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Bottom left front\n        blfz = tlfz + d*np.cos(theta)\n        blfy = tlfy - d*np.sin(theta)        \n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Bottom left back\n        blbz = tlbz + d*np.cos(theta)\n        blby = tlby - d*np.sin(theta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        self._plane = Plane(tlf, trf, tlb)\n\n        self._corners = np.array([\n            tlf,\n            trf,\n            blf,\n            brf,\n            tlb,\n            trb,\n            blb,\n            brb\n        ])\n\n        return self._corners\n\n    @classmethod\n\n    def mirror_from_file(cls, filename: str)-> Plane_Mirror:\n        \"\"\"\n        Create a mirror from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        mirror = cls()\n        mirror.read_file(filename)\n        return mirror\n\n    def reflect(self, *args: Ray3D | list) -> list:\n        \"\"\"\n        A method to reflect rays off the mirror.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list of Ray3D\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        if isinstance(args[0], list):\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect mirror, tread with caution!')\n                continue\n            ray_array = ray.vector\n            mirror_normal = self._plane.normal\n            reflected_ray_array = ray_array - 2 * np.dot(ray_array, mirror_normal) * mirror_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\pgm.py", "content": "from __future__ import annotations\nfrom matplotlib.axes import Axes\nimport numpy as np\nfrom matplotlib.patches import Patch \nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Ray3D\nfrom scipy.spatial import ConvexHull\nfrom matplotlib.lines import Line2D\nfrom pyplanemono_minimal.elements import Plane_Mirror, Grating\n\nclass PGM(object):\n    \"\"\"\n    A class for a PGM setup.\n\n    Parameters\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n\n    Attributes\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n    rays : list\n        The rays to be propagated through the PGM\n    beam_offset : float\n        The vertical offset of the beam in mm\n    beam_width : float\n        The width of the beam in mm\n    beam_height : float\n        The height of the beam in mm\n    \n    Methods\n    -------\n    read_file(filename)\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n    propagate(*args)\n        Propagate rays through the PGM setup.\n    draw_sideview(ax)\n        Draws the setup on a y-z projection on a given axis.\n    draw_topview(ax)\n        Draws the setup on a x-z projection on a given axis, along with the beam footprints.\n    \"\"\"\n\n    def __init__(self, grating = None, mirror = None, **kwargs):\n        \"\"\"\n        \n        Constructor for the PGM class.\n        \n        Parameters\n        ----------\n        grating : Grating\n            The grating component of the PGM\n        mirror : Plane_Mirror\n            The mirror component of the PGM\n        **kwargs : \n            Keyword arguments for the grating and mirror components.\n            See Grating and Plane_Mirror classes for details.\n\n        \n        \"\"\"\n        # It's unclear what is happening here and there will be uncaught errors if kwargs is not as expected.\n        if grating is None:\n            grating_kwargs = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'grating_dimensions'\n            ]\n            grating_kwarg_keys = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'dimensions'\n            ]\n        \n            grating_args = [kwargs.get(x) for x in grating_kwargs]\n            grating_kwargs = dict(zip(grating_kwarg_keys, grating_args))\n            self._grating = Grating(**grating_kwargs)\n\n        else:\n            self._grating = grating\n        \n        if mirror is None:\n            mirror_kwargs = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'mirror_dimensions',\n                'theta'\n            ]\n            mirror_kwarg_keys = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'dimensions',\n                'theta'\n            ]\n        \n            mirror_args = [kwargs.get(x) for x in mirror_kwargs]\n            mirror_kwargs = dict(zip(mirror_kwarg_keys, mirror_args))\n            self._mirror = Plane_Mirror(**mirror_kwargs)\n            \n        else:\n            self._mirror = mirror\n\n        \n        self._rays = []\n        self._beam_offset = 13\n        self._beam_width = 6.43\n        self._beam_height = 5\n        self._energy = 2400\n\n    def __repr__(self):\n        return \"\"\"PGM(grating={}, \\nmirror={}, \\nb={},\\nbeam_width={},\\nbeam_height={})\"\"\".format(self.grating, \n                                                               self.mirror,\n                                                               self.beam_offset,\n                                                               self.beam_width,\n                                                               self.beam_height)\n    \n    def generate_rays(self):\n        \"\"\"\n        Generate rays for the PGM setup.\n        \"\"\"\n        \n        r0 = Ray3D(Point3D(0, self.beam_offset, -1000),\n                   Point3D(0, self.beam_offset, 0)-\n                   Point3D(0, self.beam_offset, -1000))\n        \n        r1 = Ray3D(Point3D(0, self.beam_offset + self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset + self.beam_height/2, 0)-\n                     Point3D(0, self.beam_offset + self.beam_height/2, -1000)\n                   )\n\n        r2 = Ray3D(Point3D(0, self.beam_offset - self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset - self.beam_height/2, 0) -\n                   Point3D(0, self.beam_offset - self.beam_height/2, -1000))\n\n        r3 = Ray3D(Point3D(-self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(-self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(-self.beam_width/2, self.beam_offset, -1000))\n\n        r4 = Ray3D(Point3D(self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(self.beam_width/2, self.beam_offset, -1000))\n\n        self._rays = [r0, r1, r2, r3, r4]\n\n\n    def read_file(self, filename):\n        \"\"\"\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        \n        self._grating.read_file(filename)\n        self._mirror.read_file(filename)\n        pgm_config = configparser.ConfigParser()\n        pgm_config.read(filename)\n        self._energy = float(pgm_config['beam']['energy'])\n        self._beam_offset = float(pgm_config['beam']['beam_offset'])\n        self._beam_width = float(pgm_config['beam']['beam_width'])\n        self._beam_height = float(pgm_config['beam']['beam_height'])\n    \n\n    def set_theta(self):\n        \"\"\"\n        Set the angle of the grating.\n        \"\"\"\n        self.mirror.theta = 0.5 * (self.grating.alpha-self.grating.beta)\n\n    @property\n\n    def theta(self):\n        return self.mirror.theta\n\n    @theta.setter\n\n    def theta(self, value):\n        self.theta = value\n        self.mirror.theta = value\n\n    @property\n\n    def energy(self):\n        return self.grating.energy\n    \n    @property\n    def wavelength(self):\n        return 1239.8419843320025/self.energy\n    \n    @energy.setter\n    # need validation for energy value, e.g. non-zero\n    def energy(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 0:\n            self.grating.energy = value\n        else:\n            print(value, type(value))\n            raise ValueError(\"Expected energy to be a positive float!\")\n    @property\n    def grating(self)-> Grating:\n        return self._grating\n    \n    @grating.setter\n    def grating(self, value: Grating)-> None:\n        if isinstance(value, Grating):\n            self._grating = value\n        else: \n            raise TypeError(\"Expected Grating instance for grating!\")\n    \n    @property\n    def mirror(self)-> Plane_Mirror:\n        return self._mirror\n    \n    @mirror.setter\n    def mirror(self, value: Plane_Mirror):\n        if isinstance(value, Plane_Mirror):\n            self._mirror = value\n        else:\n            raise TypeError(\"Expected Plane_Mirror instance for mirror!\")\n    @property\n    def rays(self)-> list[Ray3D]:\n        return self._rays\n    \n    @rays.setter\n    def rays(self, value: list[Ray3D])-> None:\n        self._rays = value\n    \n    @property\n    def beam_offset(self)-> float:\n        return -1*self._beam_offset\n    \n    @beam_offset.setter\n    def beam_offset(self, value: float)-> None:\n        if isinstance(value, (float, int)):\n            self._beam_offset = -1*value\n        else:\n            raise TypeError(\"Expected float for beam_offset!\")\n        \n    @property\n    def b(self)-> float:\n        return self._beam_offset\n    \n    @b.setter\n    def b(self, value: float)-> None:\n        self.beam_offset = value\n\n    @property\n    def beam_width(self)-> float:\n        return self._beam_width\n    \n    @beam_width.setter\n    def beam_width(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_width = value\n        else:\n            raise TypeError(\"Expected non-negative float for beam_width!\")\n    \n    @property\n    def beam_height(self)-> float:\n        return self._beam_height\n    \n    @beam_height.setter\n    def beam_height(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_height = value\n        else:\n            raise ValueError(\"Expected non-negative float for beam_height!\")\n\n\n    @property\n    def mirror_intercept(self)-> Point3D:\n        return self._mirror_intercept\n    \n    @property\n    def grating_intercept(self)-> Point3D:\n        return self._grating_intercept\n    \n    \n    @property\n    def cff(self)-> float:\n        return self.grating.cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 1:\n            self.grating.cff = value\n        else:\n            raise ValueError(\"Expected cff to be a positive float bigger than 1!\")\n\n    def values(self)-> dict:\n\n        dictionary = {'beam_vertical': self.beam_offset,\n                      'beam_width': self.beam_width,\n                      'beam_height': self.beam_height,\n                      'line_density': self.grating.line_density,\n                      'energy': self.grating.energy,\n                      'cff': self.grating.cff,\n                      'order': self.grating.order,\n                      'grating_dimensions': self.grating.dimensions,\n                      'grating.borders': self.grating.borders,\n                      'mirror_voffset': self.mirror.voffset,\n                      'mirror_hoffset': self.mirror.hoffset,\n                      'mirror_axis_voffset': self.mirror.axis_voffset,\n                      'mirror_axis_hoffset': self.mirror.axis_hoffset,\n                      'mirror_dimensions': self.mirror.dimensions,\n                      'mirror_theta': self.mirror.theta,\n                      'mirror_borders': self.mirror.borders}\n        return dictionary\n\n    @classmethod\n\n    def pgm_from_file(cls, filename:float)-> PGM:\n        \"\"\"\n        Create a PGM from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        pgm = cls()\n        pgm.read_file(filename)\n        return pgm\n\n    def propagate(self, *args: Ray3D | list)-> tuple:\n        \"\"\"\n        Propagate rays through the PGM setup.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be propagated\n        \n        Returns\n        -------\n        grating_ray : list of Ray3D objects\n            A list of propagated rays originating at the grating intercept\n        \n        mirror_intercept : list of array_like\n            A list of the mirror intercepts\n\n        grating_intercept : list of array_like\n            A list of the grating intercepts\n\n        \"\"\"\n        _ = self._mirror.compute_corners()\n        _ = self._grating.compute_corners()\n\n        mirr_ray = self._mirror.reflect(*args)\n        grating_ray = self._grating.diffract(*mirr_ray)\n        mirror_intercept = [mirr_ray.position for mirr_ray in mirr_ray]\n        grating_intercept = [grating_ray.position for grating_ray in grating_ray]\n        \n        # _mirror_intercept and _grating_intercept not defined in __init__\n        self._mirror_intercept = mirror_intercept\n        self._grating_intercept = grating_intercept\n        return grating_ray, mirror_intercept, grating_intercept\n\n\n    def draw_sideview(self, ax: Axes):\n        \"\"\"\n        Draws the setup on a y-z projection on a given axis.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes\n            The axis to draw on\n\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        grating_corners = self.grating.compute_corners()\n        mirror_corners_y, mirror_corners_z = mirror_corners[::2,1], mirror_corners[::2,2]\n        mirror_corners_yz = np.array([mirror_corners_z, mirror_corners_y]).T\n        # ConvexHull sp?\n        # ConvelHull method used to ensure the entire region is filled regardless\n        # of point order.\n        hull_grating = ConvexHull(mirror_corners_yz)\n\n        grating_corners_y, grating_corners_z = grating_corners[::2,1], grating_corners[::2,2]\n        grating_corners_yz = np.array([grating_corners_z, grating_corners_y]).T\n        hull_mirror = ConvexHull(grating_corners_yz)\n\n        ax.fill(mirror_corners_yz[hull_mirror.vertices,0], mirror_corners_yz[hull_mirror.vertices,1], 'r')\n        ax.fill(grating_corners_yz[hull_grating.vertices,0], grating_corners_yz[hull_grating.vertices,1], 'b')\n\n        self.generate_rays()\n        grating_ray, mirror_int, grating_int = self.propagate(self.rays)\n        #print(\"Side view r3 int:\", mirror_int[3])\n        for index, ray in enumerate(grating_ray):\n            r_z = np.array([\n            self.rays[index].position.z,\n            mirror_int[index].z,\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            self.rays[index].position.y,\n            mirror_int[index].y,\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='green', linewidth=1, label='Dispersed Rays')\n            ax.add_line(line)\n        \n        zero_order_rays = self.grating.reflect(self.rays, zero_order=True)\n\n        \"\"\"\n        for index, ray in enumerate(zero_order_rays):\n            r_z = np.array([\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='gray', linewidth=1, label='Zero Order Reflections')\n            ax.add_line(line)\n        \"\"\"\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n        ]\n        ax.legend(handles=legend_entries, loc = 'lower right', fontsize=16, fancybox=True, shadow=True)\n        ax.axhline(y=0, color='black', linestyle='--', linewidth=1.3)\n        ax.axvline(x=0, color='black', linestyle='--', linewidth=1.3)\n        \n    def draw_topview(self, ax: Axes)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        \n        self.generate_rays()\n        \n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        _, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        _, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        _, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        _, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n        #print(\"Mirror footprint width:\", mirror_footprint_width)\n       # print(\"Mirror footprint height:\", mirror_footprint_height)\n        #print(\"Grating footprint width:\", grating_footprint_width)\n       # print(\"Grating footprint height:\", grating_footprint_height)\n        \n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        ax.fill(mirror_corners[:,0], mirror_corners[:,1], 'r',alpha=1, label='Mirror')\n        ax.fill(grating_corners[:,0], grating_corners[:,1], 'b',alpha=0.5, label='Grating')\n        ax.fill(mirr_footprint_corners[:,0], mirr_footprint_corners[:,1], c='black')\n        ax.fill(grating_footprint_corners[:,0], grating_footprint_corners[:,1], c='green')\n        ax.grid(axis='both', which='both', alpha = 0.5)\n        ax.set_xticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xticks(np.arange(-1000, 1000, 100), minor=False)\n        ax.set_yticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xlim(min(mirror_corners[:,0]), max(grating_corners[:,0]))\n        ax.set_ylim(min(mirror_corners[:,1]), max(grating_corners[:,1]))\n        #ax.fill(mirror_rect_borders[:,0], mirror_rect_borders[:,1], 'r',alpha=0.5)\n        #ax.fill(m_corners[:,] , 'r',alpha=1)\n        #x.fill(grating_rect_borders[:,0], grating_rect_borders[:,1], 'b',alpha=1)\n        #ax.fill(grating_rect[:,0], grating_rect[:,1], 'b',alpha=0.5, label='Grating')\n        #ax.fill([mirror_blz, mirror_blz + mirror_l, mirror_blz + mirror_l, mirror_blz], [mirror_blx, mirror_blx, mirror_blx + mirror_w, mirror_blx + mirror_w], 'g', alpha=0.5, label='Beam Footprint')\n        #ax.fill([grating_blz, grating_blz + grating_l, grating_blz + grating_l, grating_blz], [grating_blx, grating_blx, grating_blx + grating_w, grating_blx + grating_w], 'g', alpha=0.5)\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n            Patch(facecolor=(0,0,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Mirror): {mirror_footprint_width:.2f} mm x {mirror_footprint_height:.2f} mm'),\n            Patch(facecolor=(0,1,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Grating): {grating_footprint_width:.2f} mm x {grating_footprint_height:.2f} mm')\n\n        ]\n\n        ax.legend(handles=legend_entries, loc = 'upper left', fontsize=12, fancybox=True, shadow=True)\n\n\n    def topview_trace(self)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        # use your _width and _length setters\n        \n        self.generate_rays()\n        \n        # _, mirror_intercept, grating_intercept\n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        grating_ray, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        grating_ray, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        grating_ray, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        grating_ray, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n\n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        return mirror_intercepts, grating_intercepts\n        \n\n    def calc_footprint_size(self, intercepts: list[Point3D])-> tuple:\n        \"\"\"\n        Calculate the size of the footprint of the beam on the grating or the mirror\n        when given the intercepts of the beam with the grating or the mirror.\n         \n        \n        Parameters\n        ----------\n        intercepts : list of Point3D objects\n            The intercepts of the beam with the grating or the mirror\n            [r_1, r_2, r_3, r_4]\n\n        Returns\n        -------\n        size : tuple\n            The size of the footprint of the beam on the grating or the mirror in mm\n        \"\"\"\n\n        r_1, r_2, r_3, r_4 = intercepts\n    \n        width = r_1.distance(r_2)\n        height = r_3.distance(r_4)\n\n        return width, height\n\n\n    def centre_of_footprint(self):\n        \"\"\"\n        Calculate the centre of the footprint of the beam on the grating or the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the footprint of the beam on the grating or the mirror\n        \"\"\"\n        _, mirror_int_0, grating_int_0 =  self.propagate(self.rays[0])\n\n        return mirror_int_0, grating_int_0\n        \n    def find_offset(self):\n\n        mirror_int, grating_int = self.centre_of_footprint()\n        mirror_int = mirror_int[0]\n        grating_int = grating_int[0]\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        #print(mirror_corners)\n        centre_of_mirror_top = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        #print([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]])\n        #print(centre_of_mirror_top)\n        mirror_offset =  np.array([mirror_int.x, mirror_int.y, mirror_int.z]) - centre_of_mirror_top\n        #print(mirror_offset)\n        mirror_offset = np.linalg.norm(mirror_offset) * mirror_offset[1]/np.abs(mirror_offset[1])\n\n        grating_offset = np.linalg.norm(grating_int) * grating_int[1]/np.abs(grating_int[1])\n        return mirror_offset, grating_offset\n    \n    def centre_of_mirror(self):\n        \"\"\"\n        Calculate the centre of the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the mirror\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        centre_of_mirror = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        return centre_of_mirror\n\n\n    def mirror_corners(self)-> tuple:\n\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.mirror.theta)\n        theta_g = 90 - self.theta\n        theta_g = np.deg2rad(theta_g)\n        a = self.mirror._hoffset\n        c = self.mirror._voffset\n        v = self.mirror._axis_voffset\n        h = self.mirror._axis_hoffset\n\n        w = self.mirror._width()\n        l = self.mirror._length()\n        d = self.mirror._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        return ((tlfz, tlfx), (trfz, trfx), (trbz, trbx), (tlbz, tlbx))\n\n    def grating_corners(self)-> tuple:\n        \n        l = self.grating._length()\n        w = self.grating._width()\n        beta = self.grating.beta\n        \n        beta_g = 90 + beta\n        beta_rad = beta_g*np.pi/180\n\n        blbz = -(l/2)*np.cos(beta_rad)\n        blbx = -w/2\n\n        brbz = -(l/2)*np.cos(beta_rad)\n        brbx = w/2\n\n        blfz = (l/2)*np.cos(beta_rad)\n        blfx = -w/2\n\n        brfz = (l/2)*np.cos(beta_rad)\n        brfx = w/2\n\n        return ((blbz, blbx), (brbz, brbx), (brfz, brfx), (blfz, blfx))\n    \n    def corners(self)-> tuple[dict]:\n        \"\"\"\n        Calculate the corners of the mirror and grating.\n        \n        Returns\n        -------\n        corners : dict\n            The corners of the grating and mirror in the following order:\n            bottom left back, bottom right back, bottom left front, bottom right front,\n            top left back, top right back, top left front, top right front\n        \"\"\"\n        positions = [\n            \"bottom left back\",\n            \"bottom right back\",\n            \"bottom left front\",\n            \"bottom right front\",\n            \"top left back\",\n            \"top right back\",\n            \"top left front\",\n            \"top right front\"\n        ]\n        grating_corners = self.grating.compute_corners()\n        grating_corners_dict = dict(zip(positions, grating_corners))\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners_dict = dict(zip(positions, mirror_corners))\n\n        return grating_corners_dict, mirror_corners_dict\n            \n\n    @staticmethod\n    def undulator_size():\n        pass\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\geometry\\__init__.py", "content": "from .geometry import *\n#from .light import *", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\geometry\\geometry.py", "content": "\"\"\"\nA module containing classes for simple 3D geometry\nused in ray tracing of X-ray optics.\n\nAuthor: Patrick Wang\nEmail: patrick.wang@diamond.ac.uk\n\nVersion: 0.2.2\nDate: 2023-09-15\n\n\"\"\"\nfrom __future__ import division, print_function\nimport numpy as np\n\nclass Ray3D(object):\n    \"\"\"\n    A class for a simple 3D ray\n\n    Parameters\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n    \n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the ray\n\n    Attributes\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n\n    \"\"\"\n    def __init__(self, position, vector):\n        self._position = position\n        vector_mag = np.linalg.norm(vector)\n        if vector_mag == 0:\n            raise ValueError(\"Vector magnitude cannot be zero\")\n        self._vector = vector / vector_mag\n\n    def __repr__(self):\n        # use f-string\n        return f\"Ray3D(position={self.position}, vector={self.vector})\"\n    @property\n    def position(self):\n        return self._position\n    \n    @position.setter\n    def position(self, value):\n        self._position = value\n    \n    @property\n    def vector(self):\n        return self._vector\n    \n    @vector.setter\n    def vector(self, value):\n        self._vector = value / np.linalg.norm(value)\n\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\n\n\nclass Point3D(object):\n    \"\"\"\n    A class for a simple 3D point.\n\n    Parameters\n    ----------\n    x : float\n        The x coordinate of the point\n    y : float\n        The y coordinate of the point\n    z : float\n        The z coordinate of the point\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the point\n    __add__ : Point3D\n        Adds two points together\n    __sub__ : Point3D\n        Subtracts two points\n    __eq__ : bool\n        Checks if two points are equal\n    __ne__ : bool\n        Checks if two points are not equal\n    __getitem__ : float\n        Returns the x, y or z coordinate of the point\n    __setitem__ : float\n        Sets the x, y or z coordinate of the point\n    __iter__ : float\n        Returns an iterator over the point\n    __len__ : int\n        Returns the length of the point\n    __hash__ : int \n        Returns the hash of the point\n    __copy__ : Point3D\n        Returns a copy of the point\n    __deepcopy__ : Point3D\n        Returns a deep copy of the point\n    copy : Point3D\n        Returns a copy of the point\n    distance : float\n        Finds the distance between two points\n    \"\"\"\n\n    def __init__(self, x, y, z):\n        self._point = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        # f-string\n        return \"Point3D(x={}, y={}, z={})\".format(self.x, self.y, self.z)\n    \n    def __add__(self, other):\n        return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other._point)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._point, other._point)\n    \n    def __getitem__(self, key):\n        return self._point[key] \n    \n    def __setitem__(self, key, value):\n        self._point[key] = value\n\n    def __iter__(self):\n        return iter(self._point)    \n\n    def __len__(self):\n        return len(self._point)\n    \n    def __hash__(self):\n        return hash(self._point.tostring())\n    \n    def __copy__(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Point3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def distance(self, other):\n        # use point property rather than accessing other._point\n        return np.linalg.norm(self._point - other._point)\n    \n    @property\n    def x(self):\n        return self._point[0]\n    \n    @x.setter\n    def x(self, value):\n        self._point[0] = value\n\n    @property\n    def y(self):\n        return self._point[1]\n    \n    @y.setter\n    def y(self, value):\n        self._point[1] = value\n\n    @property\n    def z(self):\n        return self._point[2]\n    \n    @z.setter\n    def z(self, value):\n        self._point[2] = value\n\n    @property\n    def list(self):\n        return self._point.tolist()\n    \n\nclass Vector3D(object):\n    \"\"\"A class for a simple 3D vector\n    \n    Parameters\n    ----------\n    x : float\n    The x component of the vector\n    y : float\n    The y component of the vector\n    z : float\n    The z component of the vector\n    \n    Methods:\n    ----------\n    __repr__ : str\n    Returns a string representation of the vector\n    __add__ : Vector3D\n    Adds two vectors together\n    __sub__ : Vector3D\n    Subtracts two vectors\n    __mul__ : Vector3D\n    Finds the dot product of two vectors\n    __div__ : Vector3D\n    Finds the cross product of two vectors\n    __abs__ : float\n    Finds the magnitude of the vector\n    __neg__ : Vector3D\n    Finds the negative of the vector\n    __eq__ : bool\n    Checks if two vectors are equal\n    __ne__ : bool\n    Checks if two vectors are not equal\n    __getitem__ : float\n    Returns the x, y or z component of the vector\n    __setitem__ : float\n    Sets the x, y or z component of the vector\n    __iter__ : float\n    Returns an iterator over the vector\n    __len__ : int\n    Returns the length of the vector\n    __hash__ : int\n    Returns the hash of the vector\n    __copy__ : Vector3D\n    Returns a copy of the vector\n    __deepcopy__ : Vector3D\n    Returns a deep copy of the vector\n    copy : Vector3D\n    Returns a copy of the vector\n    dot : float\n    Finds the dot product of two vectors\n    cross : Vector3D\n    Finds the cross product of two vectors\n    norm : float\n    Finds the magnitude of the vector\n    normalize : Vector3D\n    Normalizes the vector\n    angle : float\n    Finds the angle between two vectors\n    rotate : Vector3D\n    Rotates the vector around an axis\n    rotate_x : Vector3D\n    Rotates the vector around the x axis\n    rotate_y : Vector3D\n    Rotates the vector around the y axis\n    rotate_z : Vector3D\n    Rotates the vector around the z axis\n\n    \"\"\"\n    def __init__(self, x, y, z):\n        self._vector = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        return f\"Vector3D(x={self.x}, y={self.y}, z={self.z})\"\n    \n    def __add__(self, other):\n        return Vector3D(self.x + other[0], self.y + other[1], self.z + other[2])\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __mul__(self, other):\n        if isinstance(other, (int, float)):\n            return Vector3D(self.x*other, self.y*other, self.z*other)\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def __div__(self, other):\n        # np.cross returns np ndarray but Vector3D expects x, y, z params\n        cp = np.cross(self._vector, other._vector)\n        return Vector3D(cp[0],cp[1],cp[2])\n    \n    def __abs__(self):\n        return np.linalg.norm(self._vector)\n    \n    def __neg__(self):\n        return Vector3D(-self.x, -self.y, -self.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._vector, other._vector)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._vector, other._vector)\n    \n    def __getitem__(self, key):\n        return self._vector[key]\n    \n    def __setitem__(self, key, value):\n        self._vector[key] = value\n\n    def __iter__(self):\n        return iter(self._vector)\n    \n    def __len__(self):\n        return len(self._vector)\n    \n    def __hash__(self):\n        return hash(self._vector.tostring())\n    \n    def __copy__(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def dot(self, other):\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def cross(self, other):\n        # Vector3D expects x, y, z\n        return Vector3D(np.cross(self._vector, other._vector))\n    \n    def norm(self):\n        return np.linalg.norm(self._vector)\n    \n    def normalize(self):\n        return Vector3D(self.x/self.norm(), self.y/self.norm(), self.z/self.norm())\n    \n    def angle(self, other):\n        return np.arccos(self.dot(other)/(self.norm()*other.norm()))\n    \n    def rotate(self, axis, angle):\n        axis = axis.normalize()\n        return Vector3D(self.x*np.cos(angle) + (1 - np.cos(angle))*axis.x*axis.x + np.sin(angle)*(axis.y*self.z - axis.z*self.y),\n                        self.y*np.cos(angle) + (1 - np.cos(angle))*axis.y*axis.y + np.sin(angle)*(axis.z*self.x - axis.x*self.z),\n                        self.z*np.cos(angle) + (1 - np.cos(angle))*axis.z*axis.z + np.sin(angle)*(axis.x*self.y - axis.y*self.x))\n    \n    def rotate_x(self, angle):\n        return Vector3D(self.x, self.y*np.cos(angle) - self.z*np.sin(angle), self.y*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_y(self, angle):\n        return Vector3D(self.x*np.cos(angle) + self.z*np.sin(angle), self.y, -self.x*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_z(self, angle):\n        return Vector3D(self.x*np.cos(angle) - self.y*np.sin(angle), self.x*np.sin(angle) + self.y*np.cos(angle), self.z)\n    \n    @property\n    def x(self):\n        return self._vector[0]\n    \n    @x.setter\n    def x(self, value):\n        self._vector[0] = value\n\n    @property\n    def y(self):\n        return self._vector[1]\n    \n    @y.setter\n    def y(self, value):\n        self._vector[1] = value\n\n    @property\n    def z(self):\n        return self._vector[2]\n    \n    @z.setter\n    def z(self, value):\n        self._vector[2] = value\n\n    def to_point(self)-> Point3D:\n        \"\"\"\n        Converts the vector to a Point3D\n        \"\"\"\n        return Point3D(self.x, self.y, self.z)\n\n\nclass Plane(object):\n    \"\"\"\n    A class for a simple plane\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    *args\n        Either a point and a normal vector, or three points defining the plane, np.array_like\n\n    Attributes\n    ----------\n    point : array_like\n        A point on the plane\n\n    normal : array_like\n        The normal vector of the plane\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the plane\n    __eq__ : bool\n        Checks if two planes are equal\n    intersectQ : bool\n        Checks if the plane intersects another plane or ray3d\n\n    \"\"\"\n\n    def __init__(self, *args):\n        if len(args) == 0:\n            print(\"No arguments given, plane at origin with normal (0, 0, 1) initialised! Tread carefully!\")\n            self._point = np.array([0, 0, 0])\n            self._normal = np.array([0, 0, 1])\n\n\n        if len(args) == 2:\n            self._point = args[0]\n            self._normal = args[1]\n\n        elif len(args) == 3:\n            v1 = args[2] - args[0]\n            v2 = args[1] - args[0]\n\n\n            self._normal = np.cross(v1, v2) / np.linalg.norm(np.cross(v1, v2))\n            self._point = args[0]\n\n        self.d = -self._normal.dot(self._point)\n\n    def __repr__(self):\n        #f-string\n        return \"Plane(point={}, normal={})\".format(self._point, self._normal)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other.point) and np.array_equal(self._normal, other.normal)\n    \n    @property\n    def point(self):\n        return self._point\n    \n    @point.setter\n    def point(self, value):\n        self._point = np.array(value)\n\n    @property\n    def position(self):\n        return self._point\n    \n    @position.setter\n    def position(self, value):\n        self._point = np.array(value)\n\n    @property\n    def normal(self):\n        return self._normal\n    \n    @normal.setter\n    def normal(self, value):\n        self._normal = np.array(value)\n            \n    # rename intersect_q\n    def intersectQ(self, other, atol=1e-6):\n        \"\"\"\n        Checks if the plane intersects another plane or ray3d\n\n        Parameters\n        ----------\n        other : Plane or Ray3D\n            The other plane or ray3d\n        atol : float\n            The absolute tolerance for the dot product of the normal vectors\n\n        Returns\n        ----------\n        bool\n            True if the plane intersects the other plane or ray3d, False otherwise\n        Point3D or None\n            The point of intersection if the plane intersects the other plane or ray3d, None otherwise\n        \"\"\"\n    \n        if isinstance(other, Plane):\n            return not np.isclose(self.normal.dot(other.normal), 1.0, atol=atol), None\n\n        elif isinstance(other, Ray3D):\n            if not np.isclose(self.normal.dot(other.vector), 0.0, atol=atol):\n                w = other.position - self.point\n                fac = -self.normal.dot(w) / self.normal.dot(other.vector)\n                plane_intersect = w + fac * other.vector + self.point\n                return True, plane_intersect\n            \n            else:\n                raise ValueError(\"The plane and ray are parallel\")    \n        # return type is different to return type from if and elif above\n        print('Not handled!')\n\n\n\n# Image class already defined\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\ndef calc_beam_size(electron_size: float,\n                   electron_div: float,\n                   wavelength: float,\n                   distance: float,\n                   length: float,\n                   num_of_sigmas=3,\n                   insertion_device='undulator') -> float:\n    \"\"\"\n    Calculate the beam size based on the electron size and divergence.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n    electron_div : float\n        The electron divergence in urad\n    wavelength not photon_energy in params\n    photon_energy : float\n        The photon energy in eV\n    distance : float\n        The distance from the source to the image plane in m\n    length : float\n        The length of the insertion device in m\n    num_of_sigmas : int\n        The number of sigmas to use when calculating the beam size\n    insertion_device : str\n        The type of insertion device, can be 'undulator' or 'wiggler', default is 'undulator'\n    \n    Returns\n    ----------\n    float\n        The RMS photon beam size at distance in mm\n\n    \"\"\"\n    if insertion_device == 'undulator':\n        source_size = calc_source_size(electron_size, wavelength, length)\n        source_div = calc_source_div(electron_div, wavelength, length)\n        return np.sqrt(source_size**2 + (source_div*distance)**2)*1e3*num_of_sigmas\n    else:\n        raise NotImplementedError(\"Only undulator is currently supported\")\n        \n\n\ndef calc_source_size(electron_size: float, wavelength:float, length:float)-> float:\n    \"\"\"\n    Calculates the source size based on provided parameters.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source size in m\n    \"\"\"\n    return np.sqrt((electron_size*1e-6)**2 + (wavelength*1e-9*length/(2*np.pi**2)))\n\ndef calc_source_div(electron_div: float, wavelength: float, length: float)-> float:\n    \"\"\"\n    Calculates the source divergence based on provided parameters.\n\n    Parameters\n    ----------\n    electron_div : float\n        The electron divergence in urad\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source divergence in rad\n    \"\"\"\n    return np.sqrt((electron_div*1e-6)**2 + (wavelength*1e-9/(2*length)))", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\PKG-INFO", "content": "Metadata-Version: 2.1\nName: pyplanemono_minimal\nVersion: 1.0\nSummary: X-ray tracing for plane grating monochromator. Minimal version with no interface to SHADOW.\nAuthor-email: Patrick Wang <patrick.wang@diamond.ac.uk>\nClassifier: Programming Language :: Python :: 3\nClassifier: License :: OSI Approved :: MIT License\nClassifier: Operating System :: OS Independent\nRequires-Python: >=3.8.0\nDescription-Content-Type: text/markdown\nLicense-File: LICENSE\nRequires-Dist: numpy>=1.23.0\nRequires-Dist: scipy>=1.8.1\nRequires-Dist: matplotlib>=3.5.2\n\n# pyplanemono-minimal\n\nThis is a minimised version of the PyPlaneMono project, which is a calculation suite for the geometry of the plane grating monochromator. This repository contains only only the core calculation and visualisation functionalities and no GUI components\nand is not capable of interacting with SHADOW as a pre-processor. For full functionality, refer to pyplanemono. This is meant to be distributed with the online interface of the PyPlaneMono project with maximum portability.\n\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\SOURCES.txt", "content": "LICENSE\nREADME.md\npyproject.toml\npyplanemono_minimal/__init__.py\npyplanemono_minimal.egg-info/PKG-INFO\npyplanemono_minimal.egg-info/SOURCES.txt\npyplanemono_minimal.egg-info/dependency_links.txt\npyplanemono_minimal.egg-info/requires.txt\npyplanemono_minimal.egg-info/top_level.txt\npyplanemono_minimal/elements/__init__.py\npyplanemono_minimal/elements/grating.py\npyplanemono_minimal/elements/mirror.py\npyplanemono_minimal/elements/pgm.py\npyplanemono_minimal/geometry/__init__.py\npyplanemono_minimal/geometry/geometry.py", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\dependency_links.txt", "content": "\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\requires.txt", "content": "numpy>=1.23.0\nscipy>=1.8.1\nmatplotlib>=3.5.2\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\top_level.txt", "content": "pyplanemono_minimal\n", "type": "text"}]