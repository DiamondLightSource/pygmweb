[{"name": "app.py", "content": "import seaborn as sns\nfrom faicons import icon_svg\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\nfrom shiny import App, reactive, render, ui\napp_dir = Path(__file__).parent\nfrom pyplanemono_minimal.elements import *\nfrom pyplanemono_minimal.geometry import calc_beam_size\nimport plotly.express as px\nfrom shinywidgets import output_widget, render_widget, render_plotly\n\n\nH = 6.62607015e-34\nE = 1.602176634e-19\nC = 299792458\nto_wavelength = lambda x: H*C/(E*x)\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.layout_column_wrap(\n        ui.card(\n            \"Energy (eV)\",\n            ui.input_numeric(\"energy\", \"\", 500, min=0, step=10),\n            fill=False\n        ),\n        ui.card(\n            \"Order\",\n            ui.input_slider(\"order\", \"\", 1, 10, value=1),\n            fill=False\n        ),\n        ui.card(\n            r'\\(\\mathit{c_{ff}}\\)',\n            ui.input_numeric(\"c_ff\", \"\", 1.4, min=1, max=15, step=0.1),\n            fill=False\n        ),\n        ui.card(\n            \"Line Density (l/mm)\",\n            ui.input_numeric(\"line_density\", \"\", 400, min=0, max=3600),\n            fill=False\n        ),\n        fill=False,\n    ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Beam Configurations\",\n                ui.input_checkbox(\"calc_beam_height\", \"Calculate Beam Height Automatically\", value=False),\n                ui.output_ui('beam_height_calc_ui'),\n                ui.input_numeric(\"beam_width\",\"Beam Width (mm)\",5,step=0.1,min=0, max=100),\n            ),\n            open=True\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Mirror Configurations\",\n                ui.input_numeric('mirror_height', \"Mirror Height (mm)\", 40,min=0),\n                ui.input_numeric(\"mirror_length\", \"Mirror Length/Tangential (mm)\", 450, min=0),\n                ui.input_numeric('mirror_width', \"Mirror Width/Sagittal (mm)\", 40, min=0),\n            ),\n            open=False\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Grating Configurations\",\n                ui.input_numeric('grating_height', \"Grating Height (mm)\", 40, min=0),\n                ui.input_numeric('grating_length', \"Grating Length (mm)\", 150, min=0),\n                ui.input_numeric('grating_width', \"Grating Width (mm)\", 45, min=0),\n            ),\n            open=False\n        ),\n        ui.accordion(\n            ui.accordion_panel(\n                \"Offsets Configurations\",\n                ui.img(src='pgm.png'),\n                ui.input_numeric('beam_vertical_offset', \"Beam Vertical Offset (mm) \\(b\\)\" , -13, min=-100, max=100),\n                ui.input_numeric('mirror_horizontal_offset', \"Mirror Horizontal Offset \\(a\\) (mm)\", 0, min=-100, max=100),\n                ui.input_checkbox(\"calculate_offsets\", \"Calculate Offsets Automatically\", value=True),\n                ui.input_numeric('mirror_vertical_offset', \"Mirror Vertical Offset \\(c\\) (mm)\", 13, min=-100, max=100),\n                ui.input_numeric('mirror_axis_horizontal_offset', \"Mirror Axis Horizontal Offset \\(h\\) (mm)\", 0, min=-100, max=100),\n                ui.input_numeric('mirror_axis_vertical_offset', \"Mirror Axis Vertical Offset \\(v\\) (mm)\", 6.5, min=-100, max=100),\n            ), open=False),\n        title=\"PGM Configurations\"),\n    \n\n    ui.card(ui.card_header(\"Side View\"),ui.output_plot(\"top_view\", brush=True, inline=False, fill=False),full_screen=True, fill=True),\n    ui.card(ui.card_header(\"Side View\"),ui.output_plot(\"side_view\", brush=True, inline=False, fill=False),full_screen=True, fill=True),\n\n    ui.include_css(app_dir / \"styles.css\"),\n    ui.tags.head(ui.tags.script(src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"),\n    ui.tags.script(id=\"MathJax-script\", src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\")),\n    title=\"Plane Grating Monochromator Simulator\",\n    fillable=True\n)\n\n\ndef server(input, output, session):\n\n    @render.plot\n    def top_view():\n        fig, ax = plt.subplots(figsize=(10,10))\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        if input.calc_beam_height():\n            beamsize = calc_beam_size(float(input.electron_size()), \n                                  float(input.electron_divergence()), \n                                  to_wavelength(float(input.energy()))/1E-9, \n                                  float(input.distance_to_mirror()), \n                                  float(input.length_of_id()), \n                                  num_of_sigmas = float(input.num_of_sigmas()))\n            pgm.beam_height = beamsize\n        else:\n            pgm.beam_height = input.beam_height()\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        pgm.mirror.dimensions = [float(input.mirror_length()),float(input.mirror_width()),float(input.mirror_height())]\n        pgm.grating.dimensions=[float(input.grating_length()),float(input.grating_width()),float(input.grating_height())]\n        pgm.beam_offset=float(input.beam_vertical_offset())\n        pgm.mirror.hoffset=float(input.mirror_horizontal_offset())\n        pgm.mirror.voffset=float(input.mirror_vertical_offset())\n        pgm.mirror.axis_hoffset=float(input.mirror_axis_horizontal_offset())\n        pgm.mirror.axis_voffset=float(input.mirror_axis_vertical_offset())\n        _ = pgm.mirror.compute_corners()\n        _ = pgm.grating.compute_corners()\n        pgm.generate_rays()\n        pgm.grating.compute_angles()\n        pgm.set_theta()\n        pgm.draw_sideview(ax)\n        ax.set_xlim(-200,100)\n        ax.set_ylim(-60,60)\n        ax.set_aspect(\"equal\")\n        #pgm.draw_topview(ax2)\n        return fig\n\n    @render.plot\n    def side_view():\n        fig, ax = plt.subplots()\n        pgm = PGM(grating=Grating(), mirror=Plane_Mirror())\n        if input.calc_beam_height():\n            beamsize = calc_beam_size(float(input.electron_size()), \n                                  float(input.electron_divergence()), \n                                  to_wavelength(float(input.energy()))/1E-9, \n                                  float(input.distance_to_mirror()), \n                                  float(input.length_of_id()), \n                                  num_of_sigmas = float(input.num_of_sigmas()))\n            pgm.beam_height = beamsize\n        else:\n            pgm.beam_height = input.beam_height()\n        \n        pgm.beam_width = input.beam_width()\n        pgm.energy=float(input.energy())\n        pgm.grating.order=int(input.order())\n        pgm.cff=float(input.c_ff())\n        pgm.grating.line_density=float(input.line_density())\n        pgm.mirror.dimensions = [float(input.mirror_length()),float(input.mirror_width()),float(input.mirror_height())]\n        pgm.grating.dimensions=[float(input.grating_length()),float(input.grating_width()),float(input.grating_height())]\n        pgm.beam_offset=float(input.beam_vertical_offset())\n        pgm.mirror.hoffset=float(input.mirror_horizontal_offset())\n        pgm.mirror.voffset=float(input.mirror_vertical_offset())\n        pgm.mirror.axis_hoffset=float(input.mirror_axis_horizontal_offset())\n        pgm.mirror.axis_voffset=float(input.mirror_axis_vertical_offset())\n        _ = pgm.mirror.compute_corners()\n        _ = pgm.grating.compute_corners()\n        pgm.generate_rays()\n        pgm.grating.compute_angles()\n        pgm.set_theta()\n        #pgm.draw_sideview(ax)\n        #ax.set_xlim(-250,250)\n        #ax.set_ylim(-100,100)\n        ax.set_aspect(\"equal\")\n        pgm.draw_topview(ax)\n        ax.get_legend().set_visible(False)\n\n        #ax.set_xlim(-250,250)\n        #ax.set_ylim(-100,100)\n        ax.set_aspect(\"equal\")\n        return fig\n    \n    @render.text\n    def beam_size_mirror():\n        \n        beamsize = calc_beam_size(float(input.electron_size()), \n                                  float(input.electron_divergence()), \n                                  to_wavelength(float(input.energy()))/1E-9, \n                                  float(input.distance_to_mirror()), \n                                  float(input.length_of_id()), \n                                  num_of_sigmas = float(input.num_of_sigmas()))\n        return f\"Beam Height : {beamsize:.3f} mm\"\n    \n    @render.ui\n    @reactive.event(input.calc_beam_height)\n    def beam_height_calc_ui():\n        if input.calc_beam_height():\n            return ui.TagList(\n                \"This calculates the vertical beam size at the grating and mirror from an undulator source for the given PGM energy.\",\n                ui.input_numeric('electron_size', \" Vertical Electron Beam Size (um)\", 50, min=0),\n                ui.input_numeric('electron_divergence', \"Electron Beam Vertical Divergence (urad)\", 20, min=0),\n                ui.input_numeric('distance_to_mirror', \"Distance to Image Plane (m)\", 15, min=0),\n                ui.input_numeric('length_of_id', \"Length of ID (m)\", 2, min=0),\n                ui.input_numeric('num_of_sigmas', \"Number of Sigmas\", 5, min=0),\n                ui.output_text(\"beam_size_mirror\", \"Vertical Beam Height Mirror:\"),)\n        else:\n            return ui.input_numeric(\"beam_height\", \"Beam Height (mm)\", 5,step=0.1,min=0, max=100)\n\n\napp = App(app_ui, server, static_assets=app_dir / \"static\",)\n", "type": "text"}, {"name": "Untitled.ipynb", "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 26,\n   \"id\": \"408be1f8-f6ee-4b9f-8134-b669ef507008\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import matplotlib.pyplot as plt\\n\",\n    \"import plotly.express as px\\n\",\n    \"import plotly.graph_objects as go\\n\",\n    \"from pyplanemono_minimal.elements import *\\n\",\n    \"%matplotlib widget\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 96,\n   \"id\": \"9bec6fd3-02a1-4835-8639-3e9f4a25ec77\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"name\": \"stdout\",\n     \"output_type\": \"stream\",\n     \"text\": [\n      \"2400 1 600 2 5.166008268050012e-10\\n\"\n     ]\n    },\n    {\n     \"data\": {\n      \"application/vnd.jupyter.widget-view+json\": {\n       \"model_id\": \"1b99b76fe49b4bcab0f174554ad7fed5\",\n       \"version_major\": 2,\n       \"version_minor\": 0\n      },\n      \"image/png\": \"iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAA10dzkAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjguNCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8fJSN1AAAACXBIWXMAAA9hAAAPYQGoP6dpAABMJUlEQVR4nO3dd3hTZf/H8U9b6AI6mGW0spfsAqUKiFABRXwQVB5FpYIbGYILfdwKKggqVvSnDH3EhVuWIHsUBARkVkCR1VYQ2jI7z++PlvDUprSQNCfJeb+uK1fb5M7JN6RNPnzvc+7jYxiGIQAAAFiGr9kFAAAAwLUIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgAAAABZDAAQAALAYAiAAAIDFEAABAAAshgAIAABgMQRAAAAAiyEAAgAAWEw5swvwZHl5eTp8+LAqVaokHx8fs8sBAAClYBiGTpw4oVq1asnX15q9MAKgAw4fPqzIyEizywAAAJfgwIEDqlOnjtllmIIA6IBKlSpJyv8FCgkJMbkaAJLUqFEjSdLu3btNrgSAu8rIyFBkZKTtc9yKCIAOODftGxISQgAE3MS56Rz+JgGUxMq7b1lz4hsAAMDCCIAAAAAWwxQwAK8yZcoUs0sAALdHAATgVW666SazSwAAt8cUMAAAgMUQAAF4lf79+6t///5mlwEAbo0pYABeJTEx0ewSAMDt0QEEAACwGAIgAACAxRAAAQAALIYACAAAYDEcBALAq4SFhZldAgC4PQIgAK+yc+dOs0sAALfHFDAAFCMvT1q6VFq3zuxKAMC5CIAAvMqOHTu0Y8cOh7Zx6JA0bpzUqJHUvbu0ebNzagMAd8EUMACv0qNHD0lScnLyRd0vO1uaO1eaNk2aNy+/+3eOYTizQgAwHwEQgKX99lt+6PvwQyk11exqAMA1CIAALOf0aenLL6UPPpBWrix5PB1AAN6GAAjAEgxD2rgxP/R9+qmUkXFx9wUAb0IABODVjh2TZs3Kn+bdssXsagDAPRAAAXilJUvyu31ffy1lZjq2LTqAALwNARCA1zh4UGrdeozWr5cKDgYGANhBAATg0bKzpTlz8rt9CxZIeXmPOP0x6AAC8DYEQAAeKSnp/PItf/1ldjUA4FkIgAA8xqlT0uzZ+cFv1ariRo0p+Pq60x6XDiAAb0MABODWDEPasOH88i0nTpR0j08KvjovAAKAtyEAAnBLf/+dv3zLBx9IW7eaWwsdQADehgAIwG3k5eUv3zJtWv7yLVlZZleUjwAIwNsQAAGY7uBBacYMafp0ad8+s6sBAO9HAARgmjNnpAEDpB9/zO/+uSs6gAC8DQEQgGkyM6X5882uAgCshwAIwMvscPoW6QAC8DYEQACm8fEpi62Gl8VGAcCr+JpdAAA41+mCi/PQAQTgbegAAjBN2XQAGxR8TS6LjQOAV6ADCAAloAMIwNsQAAGYpmw6gACAkhAAAZjGUwIgHUAA3oYACAAlIAAC8DYEQACm8ZQOIAB4G44CBuBlBjh9i3QAAXgbAiAA05RNB/DtstgoAHgVpoABoAR0AAF4GwIgANOUTQfwrYILAKA4TAED8DLjC76OcNoW6QAC8DaW6AC+8sor8vHx0ahRo2zXnT17VsOGDVOVKlVUsWJFDRgwQKmpqeYVCVgQRwEDgDm8PgCuX79e7733nlq1alXo+ocfflg//PCDZs+ereXLl+vw4cPq37+/SVUCcGd0AAF4G68OgCdPntSgQYP0/vvvKzw83HZ9enq6pk2bpkmTJql79+6Kjo7WjBkztGbNGq1du9bEigFr8ZQOIAEQgLfx6gA4bNgw9enTR3FxcYWu37hxo7Kzswtd37RpU0VFRSkxMbHY7WVmZiojI6PQBcCl85QACADexmsPAvnss8/0yy+/aP369UVuS0lJkb+/v8LCwgpdX6NGDaWkpBS7zfHjx+v55593dqkA3BwdQADexis7gAcOHNDIkSM1a9YsBQYGOm27Y8eOVXp6uu1y4MABp20bsKKy6QDOL7gAAIrjlR3AjRs36q+//lK7du1s1+Xm5mrFihV6++239eOPPyorK0tpaWmFuoCpqamKiIgodrsBAQEKCAgoy9IBOKyN07dIBxCAt/HKANijRw9t3bq10HV33XWXmjZtqscff1yRkZEqX768Fi9erAED8s8bmpSUpP379ys2NtaMkgFLYh9AADCHVwbASpUqqUWLFoWuq1ChgqpUqWK7fujQoRo9erQqV66skJAQDR8+XLGxserUqZMZJQNwmtYFX7c4bYt0AAF4G68MgKUxefJk+fr6asCAAcrMzFSvXr30zjvvmF0WYCll0wH8qyw2CgBexTIBcNmyZYV+DgwMVEJCghISEswpCIDHoAMIwNt45VHAADwD+wACgDkIgABQAjqAALwNARCAaTylA0gABOBtLLMPIAD3UzYBMLosNgoAXoUACMDLzHH6FukAAvA2TAEDAABYDAEQgJf5oeDiPHQAAXgbpoABmMrHx9kB696Cr8nO3CgAeBU6gABQAjqAALwNARCAqTxlKRgA8CYEQAAoAR1AAN6GAAjAVJ7QASQAAvA2BEAAAACL4ShgAKZyfgfwHWdvkA4gAK9DAATgZW40uwAAcHtMAQMwFfsAAoDrEQABmMr5AfBfBRcAQHGYAgbgZX52+hbpAALwNnQAAZjKE6aAAcDbEAABoAR0AAF4GwIgAFPRAQQA1yMAAkAJ6AAC8DYcBALAVM7vAFZ29gYJgAC8DgEQgJfZbnYBAOD2mAIGYCpP2AeQDiAAb0MABOBlfi24AACKwxQwAFM5vwPYq+BrstO2SAcQgLehAwjAVJ4wBQwA3oYACAAloAMIwNsQAAGYig4gALgeARAASkAHEIC3IQACMJUndAAJgAC8DUcBA/Ayj5tdAAC4PQIgAFM5vwM4ytkbpAMIwOswBQwAAGAxBEAApnJ+B3BkwcV56AAC8DYEQABe5ouCCwCgOARAAKbiKGAAcD0CIAAAgMUQAAGYig4gALgeARCAqTwhAAKAtyEAAkAJ6AAC8DYsBA3AVM7vAP7m7A0SAAF4HQIgAC9TyewCAMDtMQUMwFTO7wCeKLg4Dx1AAN7GawPg+PHj1aFDB1WqVEnVq1dXv379lJSUVGjM2bNnNWzYMFWpUkUVK1bUgAEDlJqaalLFAJyjccEFAFAcrw2Ay5cv17Bhw7R27VotWrRI2dnZ6tmzp06dOmUb8/DDD+uHH37Q7NmztXz5ch0+fFj9+/c3sWrAejzhKGA6gAC8jdfuA7hgwYJCP8+cOVPVq1fXxo0b1bVrV6Wnp2vatGn65JNP1L17d0nSjBkz1KxZM61du1adOnUyo2wAAIAy57UdwH9KT0+XJFWuXFmStHHjRmVnZysuLs42pmnTpoqKilJiYqLdbWRmZiojI6PQBYBj6AACgOtZIgDm5eVp1KhRuvLKK9WiRQtJUkpKivz9/RUWFlZobI0aNZSSkmJ3O+PHj1doaKjtEhkZWdalAwAAOJ0lAuCwYcO0bds2ffbZZw5tZ+zYsUpPT7ddDhw44KQKAeuiAwgArue1+wCe89BDD2nOnDlasWKF6tSpY7s+IiJCWVlZSktLK9QFTE1NVUREhN1tBQQEKCAgoKxLBizF+QHwFmdvkAAIwOt4bQfQMAw99NBD+uabb7RkyRLVq1ev0O3R0dEqX768Fi9ebLsuKSlJ+/fvV2xsrKvLBeA0bxZcAADF8doO4LBhw/TJJ5/ou+++U6VKlWz79YWGhiooKEihoaEaOnSoRo8ercqVKyskJETDhw9XbGwsRwADLsQUMAC4ntcGwKlTp0qSunXrVuj6GTNmKD4+XpI0efJk+fr6asCAAcrMzFSvXr30zjvvuLhSAM71RsHXUSbWAADuzWsDoFGK/7IHBgYqISFBCQkJLqgIgD3O7wC+WvB1lNO2SAcQgLfx2n0AAQAAYB8BEICp2AcQAFyPAAgAAGAxBEAApqIDCACuRwAEAACwGK89ChiAZ3B+B/BHZ2+QDiAAr0MABGAq5wfAVs7eIAEQgNdhChgAAMBiCIAATOX8DuDlBRfnoQMIwNswBQzAyxwzuwAAcHt0AAGYimVgAMD1CIAAAAAWQwAEYCo6gADgegRAAAAAi+EgEACmcn4HsKOzN0gHEIDXIQAC8DLfOX2LBEAA3oYpYACm8oR9AAHA2xAAAXiZbwouzkMHEIC3YQoYgKmc3wF8sODrjc7eMAB4DTqAAEzlCVPAdAABeBsCIAAAgMUQAAGYig4gALgeARAAAMBiCIAATEUHEABcj6OAAXiZ/zO7AABwewRAAKZyfgewr7M3SAcQgNdhChgASkAABOBtCIAATOX8DuD1BRcAQHGYAgbgZTY6fYt0AAF4GzqAAEzlCUcBA4C3IQACMJUnBEA6gAC8DQEQAADAYgiAAExFBxAAXI+DQAB4mepmFwAAbo8ACMBUzu8AbnH2Bh3qAGZkZmjPsT3OKwawmObVmiuwXKDZZXgdAiAAlOBSAmBOXo7+b+P/6emlT+vYmWPOLwqwiKSHktS4SmOzy/A6BEAApnJ+B3Bzwdc2zt5wqS3bt0wj5o/Qtr+2aUjbIbov+j6V8+XtFrgUUaFRZpfglXhHAuBlri34muy0LZa2A/hn2p96ZNEj+nLHl4qtE6v196xXdK1op9UBAM5CAARgKk84Crgkp7NP69VVr+q1Na+pclBlfXzjx7qt5W3y8YYnB8ArEQABoATFdQANw9DsHbP1yMJHlHoqVWNix+jJLk+qon9F1xYIABeJAAjAVJ7aJNuSskUjF4zU8j+X64YmN2hSz0lqULmB2WUBQKkQAAGYyt0DYESEdO2153/++/Tfenrp03pv43tqXKWxfrz9R/Vs0NO8AgHgEhAAAeAffH2lPn2koUOl666TypfPX9bl3Q3v6pmlzyjXyNXrPV/XsA7DVN6vvNnlAsBFIwACMJXzO4BjL/meDRrkh77Bg6Vatc5fv+SPJRq5YKS2/7VdQ9sO1cs9Xlb1CpxxBIDnIgAC8DIjLmp0YKA0YIB0991S16753b9z9qXt0yMLH9FXO7/SFZFXsKwLAK/hW/IQ75aQkKC6desqMDBQMTEx+vnnn80uCbAUs/YBbNtWevtt6fBh6eOPpW7dzoe/09mn9czSZ9QsoZkSDybq4xs/1qq7VhH+AHgNS3cAP//8c40ePVrvvvuuYmJi9MYbb6hXr15KSkpS9epM7wCe6aGCr28XuSU0VBo0KH+at127ovc0DENfbP9Cjy56VKmnUvVI7CMa22Usy7oA8Do+huHIac49W0xMjDp06KC3387/oMjLy1NkZKSGDx+uJ554osT7Z2RkKDQ0VOnp6QoJCSnrcgGv1LGjtH69M7dYs+Dr+TOBdOuWH/oGDJCCguzfa3PKZo1cMFIr/lyhfzX5l17v+TrLugBeis9vC3cAs7KytHHjRo0de36HcV9fX8XFxSkxMdHEygA4xDdH8stUpatfU3QHqWMHqUpV6bCkKb8UHX4q65QW7l2otYfWqnpwdd3d9m41qtJIX+38yuWlA+7gvnb3KTQo1OwyUMYsGwCPHj2q3Nxc1ahRo9D1NWrU0K5du+zeJzMzU5mZmbafMzIyJEmNGjWSr2/h3SmvvfZaTZ8+XZL0wQcf6Omnn7a7za+++kpXXHGFJCk2Nlb79u0rMqZZs2ZasmSJJOmnn37SHXfcYXdbEydO1KBBgyRJt956q5YtW1ZkTFBQkH7//XdJ0p49e9SlSxe72xo+fLiefPJJSdLYsWM1c+ZMu+M2b96sGjVqKCcnR5GRkXbHXH/99Xr//fclSe+9956ee+45u+O+/fZbxcTESJI6dOiggwcPFhnTsmVLLVy4UJL0448/Kj4+3u623njjDQ0cOFCSdMstt2jlypVFxlSsWFG7d++WJCUlJalbt252tzVy5EhbR/jRRx/Vxx9/bHfctm3bVKVKFWVmZqpu3bp2x/Tr109Tp06VJL3zzjt68cUX7Y774Ycf1L59e0lSu3btlJxc9Ly2rVu31oIFCyRJ8+bN09ChQ+1ua8qUKbrpppskSf3797f7H5ywsDDt3LlTkrRjxw716NHD7rbGjBmjRx55xPb9J598Ynfcjh07FB4ertOnT6tBA/tdtAEDBujtt98u2AfwLUnj7Y6T5ktqU/B9a0l/2RkTLfnPkoZ2lmYclTKlE2se17I10rL/HdZHUrOC7z+VdKjwVv7SX/og6ANpWMEVKZLsv9zSlZJi/6fE7cWMGy4pQFKmpCnFjLlc509hnChpdTHjbpcUUfB9gqQzdsbUlnRrwfc7Jc0tZlt9JTUp+H6W7J86uYKkBwq+Ty4YZ09nSZ0Kvp9b8Lj2jJDkX1B3QjFjWkrqVfD9auX/e9hzp6Rze+q8LemsnTF1JP274Pvtyn+d7LlBUuOC7/8rKdXOmIqS7i/4/pDyf3/s6SqpY8H3cyTZ/ziRRin/E/i0pHeKGdNK0rklJldKWlfMuHhJVQu+f0tSlp0xUZJuKfh+m6QFxWyrn9TpxU7qWrerevbsqa1btxYZUqdOHa0vaNuvW7dO/fr1s7up5557Tvfdd58k6Z577tGcOXPsjjtw4IDKlSun1NRUtWnTxu6Y+Ph4jR+f/x4xbtw4TZli/49p5cqVatiwoSSpfv36OnOm6B9Jt27d9N5779m9v5VYNgBeivHjx+v55583uwwA/+BXe4ty7wmTJNv5dyv4Vygyrs/lfdSsSzPtPb5Xn3/xubKUpXK+5RRQLkA+yr9fUHCQhl2VnwBT9qbo4y/sJ8ArG16p2KvyE+D8X+dr+277CXB45+EKCA5Q5ulMTXnP/ofW5bUv17VX5SfAxCOJWr3efgK8vf3timiQnwATZiToTG7RD7faVWrr1qvyE+BO352au8h+Auzboq+aXJGfAGctmKXkv4smwAoVKuiBq/ITYPKeZM2abT8Bdm7YWZ2uyk+AczfP1c699hPgiC4j5B/orzMnzijhffsJsGWdlup1VX4CXJ2yWokb7SfAOzvcqep18xPg29Pf1tm8ogmwTrU6+vdV+Qlwu7Zr/mL7CfCGljeocaf8BPjfuf9V6vGiCbBipYq6/6r8BHgo6ZA+/cp+AuzaqKs6XpWfAOf8Mke7frefAEd1GaVy/uV0Ov203vnAfgJsFdlKPa/KT4ArD63Uuk32E2B8h3hVjcpPgG+9/5ay7CTAqGpRuuWq/AS4LXebFiyxnwD7teyn1jVa270N3sWy+wBmZWUpODhYX375ZaH/vQwePFhpaWn67rvvitzHXgcwMjLS0vsQAI7q1ElaV1xn4wICA6W28R9pQ817lG1kyc/HT+N6jNPkmyZLkt2u6R/H/9Ajix7R1zu/1pWRV+qta99Su5p2jgYB4NXYB9DCy8D4+/srOjpaixcvtl2Xl5enxYsXKzY21u59AgICFBISUugCwLWio6Xn3tqrsBdrKzFisLKNLPVp1EeZT2XqsSsfs3ufU1mn9PSSp9UsoZnWHVynWf1naeVdKwl/ACzL0lPAo0eP1uDBg9W+fXt17NhRb7zxhk6dOqW77rrL7NIAyyjNOoBhYdLtt0t3xGfpia299dyfSyVJl4VephV3rVBUaJRt7N69e23fG4ahz7d/rkcXPaojp47okSse0ROdn2BZFwCWZ+kAOHDgQB05ckTPPPOMUlJS1KZNGy1YsKDIgSEAys6FAuDVV+efoePGG6VX1j6r2LkvKc/IU1C5IP33xv9qQPMBRe4THBwsSdqUvEkjF4zUyv0r1a9pP73e83XVD69fVk8DADyKpQOgJD300EN66KGHSh4IwCVq1ZLi46UhQ/LPzbvsj2WKeONfysjKkI98NKzDML19XdFFns/Zc2iPXl75sj5M+lDNqjXTojsWKa5+nOueAAB4AMsHQADm8vGR/Pykvn3zF2vu3VsqV046duaYmid01s6j+UeUtqvZTsvjlxc7fZudm62pG6Zq1DWjJEmTF07Wgx0eVHm/8q56KgDgMQiAAEw1Zox0xRVSRMT56wZ/M1gf/fqRJKlyYGXNHzRfHet0LGYL0k+//6SRC0Zq55GdCiwXqEr+lTSy08iyLh0APJZljwIG4B769z8f/j7a/JECXgrQR79+pHK+5TTxmon6+/G/iw1/vx//XTd+fqOu+e81qhxUWRvv3ajQgFD5+vDWBgAXQgcQgOl+O/qbun3YTckn89fuu77x9fr2lm/l5+dnd/yprFMav2q8Jq6ZqKrBVfXpgE818PKBtkWgAQAXRgAEYJqs3Cz1/G9PLf9zuSSpblhdrYpfpdqhte2ONwxDn237TI8uelRHTx/Vo1c8qic6P2H3rB8AgOIRAAGY4tmlz+qlleeXdZnVf5ZubHZjseM3JW/SiAUjtGr/Kt3Y9Ea93vN11Quv58KKAcB7EAABOOT4meM6dOJQqcevO7hOIxeM1KnsU/KRj269/FY92fVJSdK2v7YVGX/s9DG99fNb+mrnV2oQ3kDvX/++OkV20qnsU3bH9+zXs9htAe6oebXm7LcKl7PsuYCdgXMJwsoyczI1ee1kvbTiJZ3KPmV2OYDHyvxPpvz9/M0uw1L4/KYDCOAiGYahOb/N0cM/Pqx9afs0vONwDWwxUD4q/gCM55Y+pwW/L5AkhQSE6I3eb6h51ebFjl93aJ0mJ07WvvR96te0n+6Lvk/hgeFOfy6AOyjny0cxXI/fOgCltuvoLo1aMEo/7v1R19S/Rt/f+r2aVys+yM3cNFP3zblPWXlZKudbTq/GvarRsaOLHf/78d81+sfR+i7pO3WO6qyvB36ttjXbXlSNEydOlCQ98sgjF3U/ALASpoAdQAsZVpF+Nl0vLH9Bb/38lqJCozSp5yTd0OSGYpdd+eeyLjc0vkFf3/J1scu6nMw6qfErx2ti4kRVr1BdE66ZcMnLutSsWVOSlJycfNH3BWANfH7TAQRwAXlGnmZsmqEnlzypU1mn9EK3F/Rw7MMKLBdod3xWbpau+egardi/QlLplnX5ZOsneuynx/T36b/1+JWP6/ErH2dZFwAoYwRAAHatObBGI+aP0MbkjRrUcpBejXtVtUPsBzlJenrJ0xq3alypl3X5JfkXjZg/QqsPrFb/Zv018ZqJLOsCAC5CAARQyKGMQ3r8p8c1a+ssRdeM1uohq3VF5BXFjl/yxxL1+6yfTmSdkI98NKLjCL157ZvFjv/r1F96avFTmrZpmppXa67Fdy5W93rdy+KpAACKQQAEIEk6m3NWkxMn6+WVLyu4fLDe7/u+7mpzl/x87e+3d+zMMV057Urt+nuXJKl9rfZaMXiFgvyD7I7Pzs3W2z+/reeXPy8fHx+9de1bur/9/aU7AjI3V1q/Xpo7Vzp5Upo8+ZKfJwCAAAhYnmEY+uG3H/Twjw9rf/p+De84XM9c9YzCAsOKvc+grwbpk22fSJKqBFXRj7f/qOha0cWOX7h3oUYuGKnf/v5N97a7Vy92f1FVg6teuLBjx6Qff5TmzZMWLJCOHs2/Pi7uYp8iAOAfCICAhe08slOjfhylhXsXqleDXppz6xw1q9as2PHTfpmmB+c+aFvWZcI1EzSq06hix+89tlejF47W90nfq+tlXfXpgE/VJqKN/cGGIf36a37gmztXSkyU8vLsj7uAxYsXX/B2AAABELCktLNpen7Z83p7/du6LPQyff/v73V94+uLXXZl55Gd6v5hd6WcSpEk/avJv/TVzV9dcFmXcSvH6fXE11WjQg19NuAz3XL5LUW3f/KktHhxfuibN086eNDh59a8efHrEgIA8hEAAQvJzcvVjM0z9OTiJ3U6+7RevPpFPdzpYQWUC7A7Pis3S3EfxWnl/pWSpHph9bQyfuUFl3WZtXWWHv/pcR07c0xPXPmEHu/8uILLB58ftGdPfodv7lxp+XIpK+vingRLlwKAwwiAgEWs3r9aIxaM0C/Jv+j2Vrfr1bhXVatSrWLHP7X4Kb2y+hXlGXkKLh+sT/t/qhua3lDs+A2HN2jE/BFKPJioAc0GaGLPiaobVlfKzJQWLTo/tbt7dxk8u/OaNcufwt65c2eZPg4AeDICIODlDmUc0mM/PaZPtn6i6JrRWjNkjWIjY4sdv2jvIg34YoBtWZeRMSP1Ru83ih2fejJVTy5+UjM2z9Dl1S/PX9bFv4k0uyDw/fSTdOpUGTwz+9LS0lz2WADgqQiAgJc6m3NWkxInadzKcargX0HTbpim+Dbx8vXxtTv+yMkj6jKzi5L+TpIkdazdUcvuXFbssi5ZuVm2ZV38fPz0VpNRun9rgMrdOFrasqXMnhdTwADgOM4F7ICyOpfggfQDuu3r25y2PViLYRg6duaY/kj7Q5k5mapVqZYiQyMvuN7eriO7dPRM/jIr5XzLqUX1FqroX/GCj3Pg+J86cOKg7ktrqBe+OKKqh9Oc+TSKd/XV0pIlxd7MuYABlIRzAdMBdEvl/cqrfnh9s8uAB0o7m6b1h9Yr+WSyalWqpQ61Oig0MLTY8UlHk7T+0HrlKU8+8lH7mu3VrHoxy8AYyl+b79BB6eAhNU85ogd/llqnlu0+fUXr4P+sAOAoAqAbiqgYoQ/7fWh2GfAgaWfT9Nyy5zTr11mqG1ZXP9z6g/o06nPBZV2u/vBqpZ5KlST1a9JPX978ZdFlXU6cyN+H79wyLYcPl/VTAQC4AAEQ8GC5ebmavmm6nlzypM7mnNXL3V/WqE6jLrisS48Pe2jVgVWSpAbhDbRqyCpFVIzIH2AY+Ufpzp2bH/iWL5eys131dJwiNrb4A1wAAPkIgICHWrV/lUbMH6FNKZt0Z+s7Nb7H+Asu6zJ28Vi9tvo127Iun9/0ua5vfL109uz5U67NnSvt3evCZ3EJSpgC/vrrr11UCAB4LgIg4GEOZhzUY4se06fbPlWHWh2UODRRnep0Knb8or2L1P+L/jqZdVI+8tHDnR7WpOYP5we+R27IPxPH6dMufAYAALMRAAEPcTbnrF5f87rGrRqnSv6VNP2G6RrcZvAFl3XpPKOzfjv2mySpU0hzLfmrt4IeXSRtnezK0p2rhA7gl19+KUm66aabXFENAHgkloFxQFkdRv79ru/V/4v+TtsePJ8hQ3lGniTJRz7Fhr7/lWvkSpKq5vhr0WcBarPnRJnW6DJdu+bvm1gMloEBUBKWgaED6JaCygcpqJz9xXdhLXlGns7mnlWekSc/Hz8F+AVcOPzl5Uq5uVJOjsplSy8ulh7akCXpIs+3CwDwagRAN3RNg2t04kkv6dbgkhw/c1zPLXtOCesT1CC8gSb3mqw+jfsUHZiRcf48u/PmSSkpri/W1Zi0AACHEQABN5Kbl6tpm6bpqSVP6WzOWY3rMU4jY0aeX9bFMKSkpPyjdefOlVaulHJyzC0aAOBxCICAm/jfZV0Gtx6s8T3Gq2almtKZM9Ki+eeXafnjD7NLNRcdQABwGAEQMNmB9AN67KfH9Nm2z9SxdketHbpWMXk1pY+/zQ99ixfnh0AAAJyEAAiY5Ez2Gb2e+LrGrxqvSv6VNLPpE7rjl1z5vjFU2r7d7PLcVwkdwGnTprmoEADwXARAN3Qg/YDu+OYOs8tAGdt7dLdST6Vq1NGG+s/nyQo58orZJXmF6667zuwSAMDtEQDdUDnfcqoTUsfsMuBshiEdOyYdPiQdOqxmyX/r4USp8d9JZlcGALAYAqAbqlmppj7u/7HZZcAZ0tOlhQvz9+WbP19KTTW7Is9XwhRw7969JUkLFixwRTUA4JEIgIAzGYa0c+f5ZVpWr2aZFhfbsmWL2SUAgNsjAAKOOn1aWrYsP/DNmyft22d2Rd6NZWAAwGEEQMARr78u/ec/0tmzZlcCAECplXxGeQDF27uX8AcA8DgEQACehSlgAHAYU8CAI3x8zK4A/1CzZk2zSwAAt+eVHcB9+/Zp6NChqlevnoKCgtSgQQM9++yzysrKKjTu119/VZcuXRQYGKjIyEi99tprJlUMoNRK6AD+8ssv+uWXX1xUDAB4Jq/sAO7atUt5eXl677331LBhQ23btk333HOPTp06pYkTJ0qSMjIy1LNnT8XFxendd9/V1q1bNWTIEIWFhenee+81+RkAAACUHa8MgL1797YtBitJ9evXV1JSkqZOnWoLgLNmzVJWVpamT58uf39/XX755dq8ebMmTZpEAETpMQXseiV0ADds2CBJat++vSuqAQCP5JVTwPakp6ercuXKtp8TExPVtWtX+fv7267r1auXkpKSdPz4cTNKBOAEffv2Vd++fc0uAwDcmiUC4J49ezRlyhTdd999tutSUlJUo0aNQuPO/ZySkmJ3O5mZmcrIyCh0gcXRAQQAeCCPCoBPPPGEfHx8LnjZtWtXofscOnRIvXv31s0336x77rnHoccfP368QkNDbZfIyEiHtgfgErAMDAA4zKP2ARwzZozi4+MvOKZ+/fq27w8fPqyrr75aV1xxhf7v//6v0LiIiAilpqYWuu7czxEREXa3PXbsWI0ePdr2c0ZGBiEQAAB4HI8KgNWqVVO1atVKNfbQoUO6+uqrFR0drRkzZsjXt3CzMzY2Vk899ZSys7NVvnx5SdKiRYvUpEkThYeH291mQECAAgICHHsS8C5MAbseHUAAcJhHTQGX1qFDh9StWzdFRUVp4sSJOnLkiFJSUgrt23fbbbfJ399fQ4cO1fbt2/X555/rzTffLNThAwAA8EYe1QEsrUWLFmnPnj3as2eP6tSpU+g2o6B7EBoaqoULF2rYsGGKjo5W1apV9cwzz7AEDC4OHUC38/TTT5tdAgC4PR/DYD7lUmVkZCg0NFTp6ekKCQkxuxyYYeRI6a23zK7CWqKjpYK1/gDgUvD57aVTwAAAACgeARBwBFPArlfCpMUDDzygBx54wEXFAIBnIgAC8Crffvutvv32W7PLAAC3RgAEHEEHEADggQiAADwLx60BgMMIgIAj6AACADwQARCAZ6EDCAAOIwACAABYjFeeCQRwGaaAXa+EDuC+fftcUwcAeDACIACvEhAQYHYJAOD2mAIGHEEH0O38/fff+vvvv80uAwDcGh1AAJ6lhCngFi1aSJKSk5NdUQ0AeCQ6gAAAABZDAAQcwRSw67EMDAA4jAAIAABgMQRAwBF0AAEAHogACMCzMAUMAA7jKGAAXuX22283uwQAcHsEQMARTAG7XgkdwAkTJrioEADwXEwBAwAAWAwBEHAEHUDXK6ED+Morr+iVV15xUTEA4JkIgAC8yptvvqk333zT7DIAwK0RAAEAACyGAAg4gilg12MZGABwGAEQAADAYgiAgCPoALoeHUAAcBgBEAAAwGJYCBqAV1m2bJnZJQCA2yMAAo5gCtj1SpgCbtKkiYsKAQDPxRQwAACAxRAAAUfQAXS9EjqAjRo1UqNGjVxUDAB4JqaAAXiVkydPml0CALg9OoAAAAAWQwAEHMEUsOuxDiAAOIwACAAAYDEEQMARdABdjw4gADiMg0AAeJUuXbqYXQIAuD0CIOAIOoCuV0IH8IsvvnBRIQDguZgCBgAAsBgCIACv8vnnn+vzzz83uwwAcGtMAQOOYArY9UqYAh41apQkaeDAgS4oBgA8Ex1AAAAAiyEAAo6gA+h6LAMDAA4jAAIAAFgMARAAAMBivD4AZmZmqk2bNvLx8dHmzZsL3fbrr7+qS5cuCgwMVGRkpF577TVzioTnYgrY9ZgCBgCHef1RwI899phq1aqlLVu2FLo+IyNDPXv2VFxcnN59911t3bpVQ4YMUVhYmO69916TqgXgqJkzZ5pdAgC4Pa8OgPPnz9fChQv11Vdfaf78+YVumzVrlrKysjR9+nT5+/vr8ssv1+bNmzVp0iQCIEqPDqDrldAB7NWrl4sKAQDP5bVTwKmpqbrnnnv03//+V8HBwUVuT0xMVNeuXeXv72+7rlevXkpKStLx48ddWSoAAIBLeWUANAxD8fHxuv/++9W+fXu7Y1JSUlSjRo1C1537OSUlxe59MjMzlZGRUegCwMVK6AD27NlTPXv2dFExAOCZPCoAPvHEE/Lx8bngZdeuXZoyZYpOnDihsWPHOvXxx48fr9DQUNslMjLSqduHB2IK2O1s3bpVW7duNbsMAHBrHrUP4JgxYxQfH3/BMfXr19eSJUuUmJiogICAQre1b99egwYN0ocffqiIiAilpqYWuv3czxEREXa3PXbsWI0ePdr2c0ZGBiEQAAB4HI8KgNWqVVO1atVKHPfWW2/ppZdesv18+PBh9erVS59//rliYmIkSbGxsXrqqaeUnZ2t8uXLS5IWLVqkJk2aKDw83O52AwICioRKWBwdQNdjGRgAcJhHBcDSioqKKvRzxYoVJUkNGjRQnTp1JEm33Xabnn/+eQ0dOlSPP/64tm3bpjfffFOTJ092eb0AAACu5JUBsDRCQ0O1cOFCDRs2TNHR0apataqeeeYZloAB3B0dQABwmCUCYN26dWXY+dBo1aqVVq5caUJF8BpMAbudc11+AEDxLBEAAVjH+vXrzS4BANyeRy0DA7gdOoCuxxQwADiMAAjAq6xbt07r1q0zuwwAcGtMAQPwLCV0APv16ydJSk5OdkExAOCZ6AACjmAKGADggegAAvAs7APo1rKzs5WdnW12GbAIPz8/+fv7y4f/jF80AiDgCN50AEnSyZMndfjwYZ04ccLsUmAx/v7+Cg8PV82aNeXn52d2OR6DAAgAcEhmZqb27Nkjf39/1a1bV4GBgXRkUOYMw1BOTo7S09N15MgRnTx5Uo0aNSIElhIBEHAEH3KuxxSw2zl48KD8/PzUuHFjlSvHxwpcKzQ0VFWqVNFvv/2m3bt3EwJLib9UAF7lueeeM7sESzEMQydOnFD16tUJfzBNhQoVVLlyZR0+fFiLFi1Sjx49VL58ebPLcmv8tQLwLCV0AO+77z4XFQIpf/o3NzdXFStWNLsUWFxYWJiOHj2qHTt2KDg4WF27djW7JLfGMjCAI5gChsXl5eVJElNuMN25DnRoaKh27dqlrKwskytybwRAAF7lnnvu0T333GN2GZbDQR8w27nfwQoVKigjI0NHjhwxuSL3xhQw4Ag+9FyvhCngOXPmuKgQAO6oXLlyysnJoQNYAjqAAAAAFkMHEIBnYRkYz3PmjORp3Rh/fykoyGmbq1u3rv78809J0ogRI/Tmm28WO3bChAl67LHHJOXvW5mTk2O7rVu3blq+fLmWLl2qbt26Oa0+WA8BEHAEU8DAhZ05I735prRli9mVXJzWraWRI50aAs+ZNWuWJkyYIH9/f7u3T58+3emPCfwTARAAUHaysvLD32efmV3JxcvKcnoAbN++vTZs2KDvvvtON998c5Hb16xZo127dqlDhw5av359kds/+ugjnT59WlFRUU6tC9bDPoCAI+gAuh5TwPBgQ4YMkVR8l2/atGmFxv1TVFSUmjZtquDg4LIpEJZBAATgVQ4cOKADBw6YXQZgV8uWLdW+fXstXLhQhw4dKnTbyZMn9cUXX6hOnTrq2bOn3ft369ZNPj4+WrZsWaHr4+Pj5ePjo5kzZ2rbtm0aOHCgatasKT8/P9vZcf73vitXrlTfvn1VrVo1+fr6aubMmbZtHTx4UMOHD1ejRo0UGBio0NBQXXnllXrvvfeUm5tbpKaZM2fKx8dH8fHxOnbsmEaNGqUGDRooICCA/RTdGFPAADxLCR1ATkcGdzdkyBBt2LBBM2fO1FNPPWW7/osvvtDJkyc1cuRI+fpeWn9mzZo1uv/++1WzZk117dpVZ86cUaVKlQqNmT17tt599101bdpUcXFxOnbsmAICAiRJ69evV+/evXXs2DFFRUWpX79+Sk9P17Jly7RmzRp98803+v777+3uv3j06FG1b99eaWlp6tKli6Kjo4vdzxHm450ScARTwG4nNTVVklSjRg2TKwHsu+222zRmzJgiAXD69Ony8fEpdvq3NN5//3098cQTevnll4sNke+8844SEhL04IMPFro+MzNTN998s44dO6b7779fb731lu18ur///rt69OihH3/8Uc8//7xefvnlItudO3euevTooa+//lohISGX/BzgGkwBA/AsJXQA27RpozZt2rimFuAShIaGqn///tqzZ4+WL18uSUpKStLq1at11VVXqX79+pe87caNG+ull166YAexe/fuRcKflN8Z/PPPP1WrVi298cYbtvAnSfXr19fEiRMlSVOmTNHZs2eL3L98+fL6v//7P8KfhyAAAo6gAwjgEvzzYJBzXx3p/klSv379Sjwv80033WT3+nP7Ff773/+2TQn/r/79+ys8PFwnTpzQxo0bi9zetm1bh8IrXIsACACAi1199dWqV6+evvzySx0/flwfffSRQkJCig1npVW3bt1LHnPuoJR69erZvd3Hx8d22z8PYCntY8N9EAABeBaWgYEXOHfU7OnTpzV48GClpKTo3//+t4IcXHewNPd39DFcvV2U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vfH6uC9eG2vhIBAAAACLoQMIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgC728ssv64orrlBwcLDCwsLsjtm/f7/69Omj4OBgVa9eXY8++qhycnIKjVm2bJnatWungIAANWzYUDNnziyynYSEBNWtW1eBgYGKiYnRzz//XAbPyLvVrVtXPj4+hS6vvPJKoTG//vqrunTposDAQEVGRuq1114rsp3Zs2eradOmCgwMVMuWLTVv3jxXPQVL4XfeHM8991yRv5OmTZvabj979qyGDRumKlWqqGLFihowYIBSU1MLbaM073so2YoVK9S3b1/VqlVLPj4++vbbbwvdbhiGnnnmGdWsWVNBQUGKi4vT7t27C405duyYBg0apJCQEIWFhWno0KE6efJkoTGled+DmzPgUs8884wxadIkY/To0UZoaGiR23NycowWLVoYcXFxxqZNm4x58+YZVatWNcaOHWsb8/vvvxvBwcHG6NGjjR07dhhTpkwx/Pz8jAULFtjGfPbZZ4a/v78xffp0Y/v27cY999xjhIWFGampqa54ml7jsssuM1544QUjOTnZdjl58qTt9vT0dKNGjRrGoEGDjG3bthmffvqpERQUZLz33nu2MatXrzb8/PyM1157zdixY4fxn//8xyhfvryxdetWM56S1+J33jzPPvuscfnllxf6Ozly5Ijt9vvvv9+IjIw0Fi9ebGzYsMHo1KmTccUVV9huL837Hkpn3rx5xlNPPWV8/fXXhiTjm2++KXT7K6+8YoSGhhrffvutsWXLFuOGG24w6tWrZ5w5c8Y2pnfv3kbr1q2NtWvXGitXrjQaNmxo3HrrrbbbS/O+B/dHADTJjBkz7AbAefPmGb6+vkZKSortuqlTpxohISFGZmamYRiG8dhjjxmXX355ofsNHDjQ6NWrl+3njh07GsOGDbP9nJuba9SqVcsYP368k5+Jd7vsssuMyZMnF3v7O++8Y4SHh9teG8MwjMcff9xo0qSJ7edbbrnF6NOnT6H7xcTEGPfdd5/T67UyfufN8+yzzxqtW7e2e1taWppRvnx5Y/bs2bbrdu7caUgyEhMTDcMo3fseLt4/A2BeXp4RERFhTJgwwXZdWlqaERAQYHz66aeGYRjGjh07DEnG+vXrbWPmz59v+Pj4GIcOHTIMo3Tve3B/TAG7mcTERLVs2VI1atSwXderVy9l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\",\n      \"text/html\": [\n       \"\\n\",\n       \"            <div style=\\\"display: inline-block;\\\">\\n\",\n       \"                <div class=\\\"jupyter-widgets widget-label\\\" style=\\\"text-align: center;\\\">\\n\",\n       \"                    Figure\\n\",\n       \"                </div>\\n\",\n       \"                <img src='data:image/png;base64,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As+ZNWuWJkyYIH9/f7u3T58+3emPCfwTARAAUHaysvLD32efmV3JxcvKcnoAbN++vTZs2KDvvvtON998c5Hb16xZo127dqlDhw5av359kds/+ugjnT59WlFRUU6tC9bDPoCAI+gAuh5TwPBgQ4YMkVR8l2/atGmFxv1TVFSUmjZtquDg4LIpEJZBAATgVQ4cOKADBw6YXQZgV8uWLdW+fXstXLhQhw4dKnTbyZMn9cUXX6hOnTrq2bOn3ft369ZNPj4+WrZsWaHr4+Pj5ePjo5kzZ2rbtm0aOHCgatasKT8/P9vZcf73vitXrlTfvn1VrVo1+fr6aubMmbZtHTx4UMOHD1ejRo0UGBio0NBQXXnllXrvvfeUm5tbpKaZM2fKx8dH8fHxOnbsmEaNGqUGDRooICCA/RTdGFPAADxLCR1ATkcGdzdkyBBt2LBBM2fO1FNPPWW7/osvvtDJkyc1cuRI+fpeWn9mzZo1uv/++1WzZk117dpVZ86cUaVKlQqNmT17tt599101bdpUcXFxOnbsmAICAiRJ69evV+/evXXs2DFFRUWpX79+Sk9P17Jly7RmzRp98803+v777+3uv3j06FG1b99eaWlp6tKli6Kjo4vdzxHm450ScARTwG4nNTVVklSjRg2TKwHsu+222zRmzJgiAXD69Ony8fEpdvq3NN5//3098cQTevnll4sNke+8844SEhL04IMPFro+MzNTN998s44dO6b7779fb731lu18ur///rt69OihH3/8Uc8//7xefvnlItudO3euevTooa+//lohISGX/BzgGkwBA/AsJXQA27RpozZt2rimFuAShIaGqn///tqzZ4+WL18uSUpKStLq1at11VVXqX79+pe87caNG+ull166YAexe/fuRcKflN8Z/PPPP1WrVi298cYbtvAnSfXr19fEiRMlSVOmTNHZs2eL3L98+fL6v//7P8KfhyAAAo6gAwjgEvzzYJBzXx3p/klSv379Sjwv80033WT3+nP7Ff773/+2TQn/r/79+ys8PFwnTpzQxo0bi9zetm1bh8IrXIsACACAi1199dWqV6+evvzySx0/flwfffSRQkJCig1npVW3bt1LHnPuoJR69erZvd3Hx8d22z8PYCntY8N9EAABeBaWgYEXOHfU7OnTpzV48GClpKTo3//+t4IcXHewNPd39DFcvV2U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vfH6uC9eG2vhIBAAAACLoQMIAABgMQRAAAAAiyEAAgAAWAwBEAAAwGIIgC728ssv64orrlBwcLDCwsLsjtm/f7/69Omj4OBgVa9eXY8++qhycnIKjVm2bJnatWungIAANWzYUDNnziyynYSEBNWtW1eBgYGKiYnRzz//XAbPyLvVrVtXPj4+hS6vvPJKoTG//vqrunTposDAQEVGRuq1114rsp3Zs2eradOmCgwMVMuWLTVv3jxXPQVL4XfeHM8991yRv5OmTZvabj979qyGDRumKlWqqGLFihowYIBSU1MLbaM073so2YoVK9S3b1/VqlVLPj4++vbbbwvdbhiGnnnmGdWsWVNBQUGKi4vT7t27C405duyYBg0apJCQEIWFhWno0KE6efJkoTGled+DmzPgUs8884wxadIkY/To0UZoaGiR23NycowWLVoYcXFxxqZNm4x58+YZVatWNcaOHWsb8/vvvxvBwcHG6NGjjR07dhhTpkwx/Pz8jAULFtjGfPbZZ4a/v78xffp0Y/v27cY999xjhIWFGampqa54ml7jsssuM1544QUjOTnZdjl58qTt9vT0dKNGjRrGoEGDjG3bthmffvqpERQUZLz33nu2MatXrzb8/PyM1157zdixY4fxn//8xyhfvryxdetWM56S1+J33jzPPvuscfnllxf6Ozly5Ijt9vvvv9+IjIw0Fi9ebGzYsMHo1KmTccUVV9huL837Hkpn3rx5xlNPPWV8/fXXhiTjm2++KXT7K6+8YoSGhhrffvutsWXLFuOGG24w6tWrZ5w5c8Y2pnfv3kbr1q2NtWvXGitXrjQaNmxo3HrrrbbbS/O+B/dHADTJjBkz7AbAefPmGb6+vkZKSortuqlTpxohISFGZmamYRiG8dhjjxmXX355ofsNHDjQ6NWrl+3njh07GsOGDbP9nJuba9SqVcsYP368k5+Jd7vsssuMyZMnF3v7O++8Y4SHh9teG8MwjMcff9xo0qSJ7edbbrnF6NOnT6H7xcTEGPfdd5/T67UyfufN8+yzzxqtW7e2e1taWppRvnx5Y/bs2bbrdu7caUgyEhMTDcMo3fseLt4/A2BeXp4RERFhTJgwwXZdWlqaERAQYHz66aeGYRjGjh07DEnG+vXrbWPmz59v+Pj4GIcOHTIMo3Tve3B/TAG7mcTERLVs2VI1atSwXderVy9l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' width=640.0/>\\n\",\n       \"            </div>\\n\",\n       \"        \"\n      ],\n      \"text/plain\": [\n       \"Canvas(toolbar=Toolbar(toolitems=[('Home', 'Reset original view', 'home', 'home'), ('Back', 'Back to previous \u00e2\u20ac\u00a6\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"pgm = PGM(mirror=Plane_Mirror(), grating = Grating())\\n\",\n    \"pgm.set_theta()\\n\",\n    \"mirror_corners = pgm.mirror.compute_corners()\\n\",\n    \"grating_corners = pgm.grating.compute_corners()\\n\",\n    \"fig, ax = plt.subplots()\\n\",\n    \"pgm.draw_sideview(ax)\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 70,\n   \"id\": \"f17c6795-1afa-4681-a59f-d54c228f4a85\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"array([[ -35.        ,   -7.35938844,  -39.71041869],\\n\",\n       \"       [  35.        ,   -7.35938844,  -39.71041869],\\n\",\n       \"       [ -35.        ,  -57.34776597,  -38.63240584],\\n\",\n       \"       [  35.        ,  -57.34776597,  -38.63240584],\\n\",\n       \"       [ -35.        ,  -17.06150405, -489.60581648],\\n\",\n       \"       [  35.        ,  -17.06150405, -489.60581648],\\n\",\n       \"       [ -35.        ,  -67.04988158, -488.52780363],\\n\",\n       \"       [  35.        ,  -67.04988158, -488.52780363]])\"\n      ]\n     },\n     \"execution_count\": 70,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"mirror_corners\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 71,\n   \"id\": \"bf5041b3-585e-42ed-8094-4b4c12be9f08\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"array([[ -20.        ,   -2.87462665,  -99.95867407],\\n\",\n       \"       [  20.        ,   -2.87462665,  -99.95867407],\\n\",\n       \"       [ -20.        ,    2.87462665,   99.95867407],\\n\",\n       \"       [  20.        ,    2.87462665,   99.95867407],\\n\",\n       \"       [ -20.        ,   47.10471038, -101.3959874 ],\\n\",\n       \"       [  20.        ,   47.10471038, -101.3959874 ],\\n\",\n       \"       [ -20.        ,   52.85396369,   98.52136074],\\n\",\n       \"       [  20.        ,   52.85396369,   98.52136074]])\"\n      ]\n     },\n     \"execution_count\": 71,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"grating_corners\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 48,\n   \"id\": \"87df917f-ccd5-47ca-8438-3e8282535caf\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"mirror_z = np.array(\\n\",\n    \"    [mirror_corners[i][2] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"mirror_x = np.array(\\n\",\n    \"    [mirror_corners[i][1] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"\\n\",\n    \"grating_z = np.array(\\n\",\n    \"    [grating_corners[i][2] for i in [4,6,2,0,4]]\\n\",\n    \")\\n\",\n    \"grating_x = np.array(\\n\",\n    \"    [grating_corners[i][1] for i in [4,6,2,0,4]]\\n\",\n    \")\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 120,\n   \"id\": \"5d561b7f-d45d-430e-83ca-e93c565e9be3\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"ray1z = [pgm.rays[0].position.list[2],\\n\",\n    \"         pgm.mirror_intercept[0].z,\\n\",\n    \"         pgm.grating_intercept[0].z,\\n\",\n    \"         1000]\\n\",\n    \"\\n\",\n    \"ray1x = [pgm.rays[0].position.list[1],\\n\",\n    \"         pgm.mirror_intercept[0].y,\\n\",\n    \"         pgm.grating_intercept[0].y,\\n\",\n    \"         0]\\n\",\n    \"ray2z = [pgm.rays[1].position.list[2],\\n\",\n    \"         pgm.mirror_intercept[1].z,\\n\",\n    \"         pgm.grating_intercept[1].z,\\n\",\n    \"         1000]\\n\",\n    \"\\n\",\n    \"ray2x = [pgm.rays[1].position.list[1],\\n\",\n    \"         pgm.mirror_intercept[1].y,\\n\",\n    \"         pgm.grating_intercept[1].y,\\n\",\n    \"         pgm.grating_intercept[1].y + 1000*pgm.rays[1].vector[1]]\\n\",\n    \"\\n\",\n    \"ray3z = [pgm.rays[2].position.list[2],\\n\",\n    \"         pgm.mirror_intercept[2].z,\\n\",\n    \"         pgm.grating_intercept[2].z,\\n\",\n    \"         1000]\\n\",\n    \"\\n\",\n    \"ray3x = [pgm.rays[2].position.list[1],\\n\",\n    \"         pgm.mirror_intercept[2].y,\\n\",\n    \"         pgm.grating_intercept[2].y,\\n\",\n    \"         pgm.grating_intercept[2].y + 1000*pgm.rays[2].vector[1]]\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 84,\n   \"id\": \"1c25d5fd-a63f-4782-9288-f5726f84a185\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"text/plain\": [\n       \"0.0\"\n      ]\n     },\n     \"execution_count\": 84,\n     \"metadata\": {},\n     \"output_type\": \"execute_result\"\n    }\n   ],\n   \"source\": [\n    \"pgm.mirror_intercept[0].x\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 123,\n   \"id\": \"098d24f9-d4bf-4698-9def-f7528b1f0d8a\",\n   \"metadata\": {},\n   \"outputs\": [\n    {\n     \"data\": {\n      \"application/vnd.plotly.v1+json\": {\n       \"config\": {\n        \"plotlyServerURL\": \"https://plot.ly\"\n       },\n       \"data\": [\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"red\",\n         \"line\": {\n          \"color\": \"red\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"mode\": \"lines\",\n         \"name\": \"Mirror\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -489.605816475759,\n          -488.52780362965945,\n          -38.63240583968962,\n          -39.71041868578921,\n          -489.605816475759\n         ],\n         \"y\": [\n          -17.061504050152877,\n          -67.04988158237174,\n          -57.347765967475446,\n          -7.359388435256577,\n          -17.061504050152877\n         ]\n        },\n        {\n         \"fill\": \"toself\",\n         \"fillcolor\": \"blue\",\n         \"line\": {\n          \"color\": \"blue\"\n         },\n         \"marker\": {\n          \"size\": 0\n         },\n         \"mode\": \"lines\",\n         \"name\": \"Grating\",\n         \"type\": \"scatter\",\n         \"x\": [\n          -101.39598739535873,\n          98.52136074237498,\n          99.95867406886686,\n          -99.95867406886686,\n          -101.39598739535873\n         ],\n         \"y\": [\n          47.104710381449685,\n          52.85396368741717,\n          2.874626652983742,\n          -2.874626652983742,\n          47.104710381449685\n         ]\n        },\n        {\n         \"line\": {\n          \"color\": \"green\",\n          \"width\": 1.5\n         },\n         \"type\": \"scatter\",\n         \"x\": [\n          -1000,\n          -301.2704004904454,\n          -4.8850507880615623e-05,\n          1000\n         ],\n         \"y\": [\n          -13,\n          -13,\n          -1.4048502867680668e-06,\n          0\n         ]\n        },\n        {\n         \"line\": {\n          \"color\": \"green\",\n          \"width\": 1.5\n         },\n         \"type\": \"scatter\",\n         \"x\": [\n          -1000,\n          -185.34326262496376,\n          173.863701360518,\n          1000\n         ],\n         \"y\": [\n          -10.5,\n          -10.5,\n          4.999998595149596,\n          4.999998595149596\n         ]\n        },\n        {\n         \"line\": {\n          \"color\": \"green\",\n          \"width\": 1.5\n         },\n         \"type\": \"scatter\",\n         \"x\": [\n          -1000,\n          -417.19753835592684,\n          -173.86379906153314,\n          1000\n         ],\n         \"y\": [\n          -15.5,\n          -15.5,\n          -5.000001404850152,\n          -5.000001404850152\n         ]\n        }\n       ],\n       \"layout\": {\n        \"autosize\": true,\n        \"showlegend\": false,\n        \"template\": {\n         \"data\": {\n          \"bar\": [\n           {\n            \"error_x\": {\n             \"color\": \"#2a3f5f\"\n            },\n            \"error_y\": {\n             \"color\": \"#2a3f5f\"\n            },\n            \"marker\": {\n             \"line\": {\n              \"color\": \"#E5ECF6\",\n              \"width\": 0.5\n             },\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"bar\"\n           }\n          ],\n          \"barpolar\": [\n           {\n            \"marker\": {\n             \"line\": {\n              \"color\": \"#E5ECF6\",\n              \"width\": 0.5\n             },\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"barpolar\"\n           }\n          ],\n          \"carpet\": [\n           {\n            \"aaxis\": {\n             \"endlinecolor\": \"#2a3f5f\",\n             \"gridcolor\": \"white\",\n             \"linecolor\": \"white\",\n             \"minorgridcolor\": \"white\",\n             \"startlinecolor\": \"#2a3f5f\"\n            },\n            \"baxis\": {\n             \"endlinecolor\": \"#2a3f5f\",\n             \"gridcolor\": \"white\",\n             \"linecolor\": \"white\",\n             \"minorgridcolor\": \"white\",\n             \"startlinecolor\": \"#2a3f5f\"\n            },\n            \"type\": \"carpet\"\n           }\n          ],\n          \"choropleth\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"choropleth\"\n           }\n          ],\n          \"contour\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"contour\"\n           }\n          ],\n          \"contourcarpet\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"contourcarpet\"\n           }\n          ],\n          \"heatmap\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"heatmap\"\n           }\n          ],\n          \"heatmapgl\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"heatmapgl\"\n           }\n          ],\n          \"histogram\": [\n           {\n            \"marker\": {\n             \"pattern\": {\n              \"fillmode\": \"overlay\",\n              \"size\": 10,\n              \"solidity\": 0.2\n             }\n            },\n            \"type\": \"histogram\"\n           }\n          ],\n          \"histogram2d\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"histogram2d\"\n           }\n          ],\n          \"histogram2dcontour\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"histogram2dcontour\"\n           }\n          ],\n          \"mesh3d\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"type\": \"mesh3d\"\n           }\n          ],\n          \"parcoords\": [\n           {\n            \"line\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"parcoords\"\n           }\n          ],\n          \"pie\": [\n           {\n            \"automargin\": true,\n            \"type\": \"pie\"\n           }\n          ],\n          \"scatter\": [\n           {\n            \"fillpattern\": {\n             \"fillmode\": \"overlay\",\n             \"size\": 10,\n             \"solidity\": 0.2\n            },\n            \"type\": \"scatter\"\n           }\n          ],\n          \"scatter3d\": [\n           {\n            \"line\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatter3d\"\n           }\n          ],\n          \"scattercarpet\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattercarpet\"\n           }\n          ],\n          \"scattergeo\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattergeo\"\n           }\n          ],\n          \"scattergl\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattergl\"\n           }\n          ],\n          \"scattermapbox\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scattermapbox\"\n           }\n          ],\n          \"scatterpolar\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterpolar\"\n           }\n          ],\n          \"scatterpolargl\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterpolargl\"\n           }\n          ],\n          \"scatterternary\": [\n           {\n            \"marker\": {\n             \"colorbar\": {\n              \"outlinewidth\": 0,\n              \"ticks\": \"\"\n             }\n            },\n            \"type\": \"scatterternary\"\n           }\n          ],\n          \"surface\": [\n           {\n            \"colorbar\": {\n             \"outlinewidth\": 0,\n             \"ticks\": \"\"\n            },\n            \"colorscale\": [\n             [\n              0,\n              \"#0d0887\"\n             ],\n             [\n              0.1111111111111111,\n              \"#46039f\"\n             ],\n             [\n              0.2222222222222222,\n              \"#7201a8\"\n             ],\n             [\n              0.3333333333333333,\n              \"#9c179e\"\n             ],\n             [\n              0.4444444444444444,\n              \"#bd3786\"\n             ],\n             [\n              0.5555555555555556,\n              \"#d8576b\"\n             ],\n             [\n              0.6666666666666666,\n              \"#ed7953\"\n             ],\n             [\n              0.7777777777777778,\n              \"#fb9f3a\"\n             ],\n             [\n              0.8888888888888888,\n              \"#fdca26\"\n             ],\n             [\n              1,\n              \"#f0f921\"\n             ]\n            ],\n            \"type\": \"surface\"\n           }\n          ],\n          \"table\": [\n           {\n            \"cells\": {\n             \"fill\": {\n              \"color\": \"#EBF0F8\"\n             },\n             \"line\": {\n              \"color\": \"white\"\n             }\n            },\n            \"header\": {\n             \"fill\": {\n              \"color\": \"#C8D4E3\"\n             },\n             \"line\": {\n              \"color\": \"white\"\n             }\n            },\n            \"type\": \"table\"\n           }\n          ]\n         },\n         \"layout\": {\n          \"annotationdefaults\": {\n           \"arrowcolor\": \"#2a3f5f\",\n           \"arrowhead\": 0,\n           \"arrowwidth\": 1\n          },\n          \"autotypenumbers\": \"strict\",\n          \"coloraxis\": {\n           \"colorbar\": {\n            \"outlinewidth\": 0,\n            \"ticks\": \"\"\n           }\n          },\n          \"colorscale\": {\n           \"diverging\": [\n            [\n             0,\n             \"#8e0152\"\n            ],\n            [\n             0.1,\n             \"#c51b7d\"\n            ],\n            [\n             0.2,\n             \"#de77ae\"\n            ],\n            [\n             0.3,\n             \"#f1b6da\"\n            ],\n            [\n             0.4,\n             \"#fde0ef\"\n            ],\n            [\n             0.5,\n             \"#f7f7f7\"\n            ],\n            [\n             0.6,\n             \"#e6f5d0\"\n            ],\n            [\n             0.7,\n             \"#b8e186\"\n            ],\n            [\n             0.8,\n             \"#7fbc41\"\n            ],\n            [\n             0.9,\n             \"#4d9221\"\n            ],\n            [\n             1,\n             \"#276419\"\n            ]\n           ],\n           \"sequential\": [\n            [\n             0,\n             \"#0d0887\"\n            ],\n            [\n             0.1111111111111111,\n             \"#46039f\"\n            ],\n            [\n             0.2222222222222222,\n             \"#7201a8\"\n            ],\n            [\n             0.3333333333333333,\n             \"#9c179e\"\n            ],\n            [\n             0.4444444444444444,\n             \"#bd3786\"\n            ],\n            [\n             0.5555555555555556,\n             \"#d8576b\"\n            ],\n            [\n             0.6666666666666666,\n             \"#ed7953\"\n            ],\n            [\n             0.7777777777777778,\n             \"#fb9f3a\"\n            ],\n            [\n             0.8888888888888888,\n             \"#fdca26\"\n            ],\n            [\n             1,\n             \"#f0f921\"\n            ]\n           ],\n           \"sequentialminus\": [\n            [\n             0,\n             \"#0d0887\"\n            ],\n            [\n             0.1111111111111111,\n             \"#46039f\"\n            ],\n            [\n             0.2222222222222222,\n             \"#7201a8\"\n            ],\n            [\n             0.3333333333333333,\n             \"#9c179e\"\n            ],\n            [\n             0.4444444444444444,\n             \"#bd3786\"\n            ],\n            [\n             0.5555555555555556,\n             \"#d8576b\"\n            ],\n            [\n             0.6666666666666666,\n             \"#ed7953\"\n            ],\n            [\n             0.7777777777777778,\n             \"#fb9f3a\"\n            ],\n            [\n             0.8888888888888888,\n             \"#fdca26\"\n            ],\n            [\n             1,\n             \"#f0f921\"\n            ]\n           ]\n          },\n          \"colorway\": [\n           \"#636efa\",\n           \"#EF553B\",\n           \"#00cc96\",\n           \"#ab63fa\",\n           \"#FFA15A\",\n           \"#19d3f3\",\n           \"#FF6692\",\n           \"#B6E880\",\n           \"#FF97FF\",\n           \"#FECB52\"\n          ],\n          \"font\": {\n           \"color\": \"#2a3f5f\"\n          },\n          \"geo\": {\n           \"bgcolor\": \"white\",\n           \"lakecolor\": \"white\",\n           \"landcolor\": \"#E5ECF6\",\n           \"showlakes\": true,\n           \"showland\": true,\n           \"subunitcolor\": \"white\"\n          },\n          \"hoverlabel\": {\n           \"align\": \"left\"\n          },\n          \"hovermode\": \"closest\",\n          \"mapbox\": {\n           \"style\": \"light\"\n          },\n          \"paper_bgcolor\": \"white\",\n          \"plot_bgcolor\": \"#E5ECF6\",\n          \"polar\": {\n           \"angularaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"bgcolor\": \"#E5ECF6\",\n           \"radialaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           }\n          },\n          \"scene\": {\n           \"xaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           },\n           \"yaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           },\n           \"zaxis\": {\n            \"backgroundcolor\": \"#E5ECF6\",\n            \"gridcolor\": \"white\",\n            \"gridwidth\": 2,\n            \"linecolor\": \"white\",\n            \"showbackground\": true,\n            \"ticks\": \"\",\n            \"zerolinecolor\": \"white\"\n           }\n          },\n          \"shapedefaults\": {\n           \"line\": {\n            \"color\": \"#2a3f5f\"\n           }\n          },\n          \"ternary\": {\n           \"aaxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"baxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           },\n           \"bgcolor\": \"#E5ECF6\",\n           \"caxis\": {\n            \"gridcolor\": \"white\",\n            \"linecolor\": \"white\",\n            \"ticks\": \"\"\n           }\n          },\n          \"title\": {\n           \"x\": 0.05\n          },\n          \"xaxis\": {\n           \"automargin\": true,\n           \"gridcolor\": \"white\",\n           \"linecolor\": \"white\",\n           \"ticks\": \"\",\n           \"title\": {\n            \"standoff\": 15\n           },\n           \"zerolinecolor\": \"white\",\n           \"zerolinewidth\": 2\n          },\n          \"yaxis\": {\n           \"automargin\": true,\n           \"gridcolor\": \"white\",\n           \"linecolor\": \"white\",\n           \"ticks\": \"\",\n           \"title\": {\n            \"standoff\": 15\n           },\n           \"zerolinecolor\": \"white\",\n           \"zerolinewidth\": 2\n          }\n         }\n        },\n        \"xaxis\": {\n         \"domain\": [\n          0,\n          1\n         ],\n         \"range\": [\n          -500,\n          500\n         ],\n         \"scaleanchor\": \"y\",\n         \"scaleratio\": 1,\n         \"type\": \"linear\"\n        },\n        \"yaxis\": {\n         \"domain\": [\n          0,\n          1\n         ],\n         \"range\": [\n          -373.9445114595899,\n          373.9445114595899\n         ],\n         \"type\": \"linear\"\n        }\n       }\n      },\n      \"image/png\": \"iVBORw0KGgoAAAANSUhEUgAAA90AAAMgCAYAAAA+wgFBAAAAAXNSR0IArs4c6QAAIABJREFUeF7s3Quc5Gld3/unr3NdlwUUXEBQVBAvEBFdUQmKRoXgIRhQE5WLroTcFD1wQI4hmEMWWblogmTluGKCipBgFAOaxIhEQyKJQpADaiAguHJbFpidS9/P61/d1VPT2zvTM9/f09M9/Z689jXMdD/fqn5XSfjsv6p7am1tba35RYAAAQIECBAgQIAAAQIECJQLTInuclODBAgQIECAAAECBAgQIEBgJCC6PREIECBAgAABAgQIECBAgEAnAdHdCdYsAQIECBAgQIAAAQIECBAQ3Z4DBAgQIECAAAECBAgQIECgk4Do7gRrlgABAgQIECBAgAABAgQIiG7PAQIECBAgQIAAAQIECBAg0ElAdHeCNUuAAAECBAgQIECAAAECBES35wABAgQIECBAgAABAgQIEOgkILo7wZolQIAAAQIECBAgQIAAAQKi23OAAAECBAgQIECAAAECBAh0EhDdnWDNEiBAgAABAgQIECBAgAAB0e05QIAAAQIECBAgQIAAAQIEOgmI7k6wZgkQIECAAAECBAgQIECAgOj2HCBAgAABAgQIECBAgAABAp0ERHcnWLMECBAgQIAAAQIECBAgQEB0ew4QIECAAAECBAgQIECAAIFOAqK7E6xZAgQIECBAgAABAgQIECAguj0HCBAgQIAAAQIECBAgQIBAJwHR3QnWLAECBAgQIECAAAECBAgQEN2eAwQIECBAgAABAgQIECBAoJOA6O4Ea5YAAQIECBAgQIAAAQIECIhuzwECBAgQIECAAAECBAgQINBJQHR3gjVLgAABAgQIECBAgAABAgREt+cAAQIECBAgQIAAAQIECBDoJCC6O8GaJUCAAAECBAgQIECAAAECottzgAABAgQIECBAgAABAgQIdBIQ3Z1gzRIgQIAAAQIECBAgQIAAAdHtOUCAAAECBAgQIECAAAECBDoJiO5OsGYJECBAgAABAgQIECBAgIDo9hwgQIAAAQIECBAgQIAAAQKdBER3J1izBAgQIECAAAECBAgQIEBAdHsOECBAgAABAgQIECBAgACBTgKiuxOsWQIECBAgQIAAAQIECBAgILo9BwgQIECAAAECBAgQIECAQCcB0d0J1iwBAgQIECBAgAABAgQIEBDdngMECBAgQIAAAQIECBAgQKCTgOjuBGuWAAECBAgQIECAAAECBAiIbs8BAgQIECBAgAABAgQIECDQSUB0d4I1S4AAAQIECBAgQIAAAQIERLfnAAECBAgQIECAAAECBAgQ6CQgujvBmiVAgAABAgQIECBAgAABAqLbc4AAAQIECBAgQIAAAQIECHQSEN2dYM0SIECAAAECBAgQIECAAAHR7TlAgAABAgQIECBAgAABAgQ6CYjuTrBmCRAgQIAAAQIECBAgQICA6PYcIECAAAECBAgQIECAAAECnQREdydYswQIECBAgAABAgQIECBAQHR7DhAgQIAAAQIECBAgQIAAgU4CorsTrFkCBAgQIECAAAECBAgQICC6PQcIECBAgAABAgQIECBAgEAnAdHdCdYsAQIECBAgQIAAAQIECBAQ3Z4DBAgQIECAAAECBAgQIECgk4Do7gRrlgABAgQIECBAgAABAgQIiG7PAQIECBAgQIAAAQIECBAg0ElAdHeCNUuAAAECBAgQIECAAAECBES35wABAgQIECBAgAABAgQIEOgkILo7wZolQIAAAQIECBAgQIAAAQKi23OAAAECBAgQIECAAAECBAh0EhDdnWDNEiBAgAABAgQIECBAgAAB0e05QIAAAQIECBAgQIAAAQIEOgmI7k6wZgkQIECAAAECBAgQIECAgOj2HCBAgAABAgQIECBAgAABAp0ERHcnWLMECBAgQIAAAQIECBAgQEB0ew4QIECAAAECBAgQIECAAIFOAqK7E6xZAgQIECBAgAABAgQIECAguj0HCBAgQIAAAQIECBAgQIBAJwHR3QnWLAECBAgQIECAAAECBAgQEN2eAwQIECBAgAABAgQIECBAoJOA6O4Ea5YAAQIECBAgQIAAAQIECIhuzwECBAgQIECAAAECBAgQINBJQHR3gjVLgAABAgQIECBAgAABAgREt+cAAQIECBAgQIAAAQIECBDoJCC6O8GaJUCAAAECBAgQIECAAAECottzgAABAgQIECBAgAABAgQIdBIQ3Z1gzRIgQIAAAQIECBAgQIAAAdHtOUCAAAECBAgQIECAAAECBDoJiO5OsGYJECBAgAABAgQIECBAgIDo9hwgQIAAAQIECBAgQIAAAQKdBER3J1izBAgQIECAAAECBAgQIEBAdHsOECBAgAABAgQIECBAgACBTgKiuxOs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AIEhAdE9BGuWAAECBAgQIECAAAECBAiIbs8AAQIECBAgQIAAAQIECBAYEhDdQ7BmCRAgQIAAAQIECBAgQICA6PYMECBAgAABAgQIECBAgACBIQHRPQRrlgABAgQIECBAgAABAgQIiG7PAAECBAgQIECAAAECBAgQGBIQ3UOwZgkQIECAAAECBAgQIECAgOj2DBAgQIAAAQIECBAgQIAAgSEB0T0Ea5YAAQIECBAgQIAAAQIECIhuzwABAgQIECBAgAABAgQIEBgSEN1DsGYJECBAgAABAgQIECBAgIDo9gwQIECAAAECBAgQIECAAIEhAdE9BGuWAAECBAgQIECAAAECBAiIbs8AAQIECBAgQIAAAQIECBAYEhDdQ7BmCRAgQIAAAQIECBAgQICA6PYMECBAgAABAgQIECBAgACBIQHRPQRrlgABAgQIECBAgAABAgQIiG7PAAECBAgQIECAAAECBAgQGBIQ3UOwZgkQIECAAAECBAgQIECAgOj2DBAgQIAAAQIECBAgQIAAgSEB0T0Ea5YAAQIECBAgQIAAAQIECIhuzwABAgQIECBAgAABAgQIEBgSEN1DsGYJECBAgAABAgQIECBAgIDo9gwQIECAAAECBAgQIECAAIEhAdE9BGuWAAECBAgQIECAAAECBAiIbs8AAQIECBAgQIAAAQIECBAYEhDdQ7BmCRAgQIAAAQIECBAgQICA6PYMECBAgAABAgQIECBAgACBIQHRPQRrlgABAgQIECBAgAABAgQI/D9dgUwyWRLQkAAAAABJRU5ErkJggg==\",\n      \"text/html\": [\n       \"<div>                            <div id=\\\"81fac275-efe7-4173-9197-73c2fe633d3d\\\" class=\\\"plotly-graph-div\\\" style=\\\"height:800px; width:100%;\\\"></div>            <script type=\\\"text/javascript\\\">                require([\\\"plotly\\\"], function(Plotly) {                    window.PLOTLYENV=window.PLOTLYENV || {};                                    if (document.getElementById(\\\"81fac275-efe7-4173-9197-73c2fe633d3d\\\")) {                    Plotly.newPlot(                        \\\"81fac275-efe7-4173-9197-73c2fe633d3d\\\",                        [{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"red\\\",\\\"line\\\":{\\\"color\\\":\\\"red\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"mode\\\":\\\"lines\\\",\\\"name\\\":\\\"Mirror\\\",\\\"x\\\":[-489.605816475759,-488.52780362965945,-38.63240583968962,-39.71041868578921,-489.605816475759],\\\"y\\\":[-17.061504050152877,-67.04988158237174,-57.347765967475446,-7.359388435256577,-17.061504050152877],\\\"type\\\":\\\"scatter\\\"},{\\\"fill\\\":\\\"toself\\\",\\\"fillcolor\\\":\\\"blue\\\",\\\"line\\\":{\\\"color\\\":\\\"blue\\\"},\\\"marker\\\":{\\\"size\\\":0},\\\"mode\\\":\\\"lines\\\",\\\"name\\\":\\\"Grating\\\",\\\"x\\\":[-101.39598739535873,98.52136074237498,99.95867406886686,-99.95867406886686,-101.39598739535873],\\\"y\\\":[47.104710381449685,52.85396368741717,2.874626652983742,-2.874626652983742,47.104710381449685],\\\"type\\\":\\\"scatter\\\"},{\\\"line\\\":{\\\"color\\\":\\\"green\\\",\\\"width\\\":1.5},\\\"x\\\":[-1000.0,-301.2704004904454,-4.8850507880615623e-05,1000],\\\"y\\\":[-13.0,-13.0,-1.4048502867680668e-06,0],\\\"type\\\":\\\"scatter\\\"},{\\\"line\\\":{\\\"color\\\":\\\"green\\\",\\\"width\\\":1.5},\\\"x\\\":[-1000.0,-185.34326262496376,173.863701360518,1000],\\\"y\\\":[-10.5,-10.5,4.999998595149596,4.999998595149596],\\\"type\\\":\\\"scatter\\\"},{\\\"line\\\":{\\\"color\\\":\\\"green\\\",\\\"width\\\":1.5},\\\"x\\\":[-1000.0,-417.19753835592684,-173.86379906153314,1000],\\\"y\\\":[-15.5,-15.5,-5.000001404850152,-5.000001404850152],\\\"type\\\":\\\"scatter\\\"}],                        {\\\"height\\\":800,\\\"showlegend\\\":false,\\\"xaxis\\\":{\\\"range\\\":[-500,500],\\\"scaleanchor\\\":\\\"y\\\",\\\"scaleratio\\\":1},\\\"yaxis\\\":{\\\"range\\\":[-50,50]},\\\"template\\\":{\\\"data\\\":{\\\"histogram2dcontour\\\":[{\\\"type\\\":\\\"histogram2dcontour\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"choropleth\\\":[{\\\"type\\\":\\\"choropleth\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"histogram2d\\\":[{\\\"type\\\":\\\"histogram2d\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"heatmap\\\":[{\\\"type\\\":\\\"heatmap\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"heatmapgl\\\":[{\\\"type\\\":\\\"heatmapgl\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"contourcarpet\\\":[{\\\"type\\\":\\\"contourcarpet\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"contour\\\":[{\\\"type\\\":\\\"contour\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"surface\\\":[{\\\"type\\\":\\\"surface\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"},\\\"colorscale\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]]}],\\\"mesh3d\\\":[{\\\"type\\\":\\\"mesh3d\\\",\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}],\\\"scatter\\\":[{\\\"fillpattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2},\\\"type\\\":\\\"scatter\\\"}],\\\"parcoords\\\":[{\\\"type\\\":\\\"parcoords\\\",\\\"line\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterpolargl\\\":[{\\\"type\\\":\\\"scatterpolargl\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"bar\\\":[{\\\"error_x\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"error_y\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"marker\\\":{\\\"line\\\":{\\\"color\\\":\\\"#E5ECF6\\\",\\\"width\\\":0.5},\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"bar\\\"}],\\\"scattergeo\\\":[{\\\"type\\\":\\\"scattergeo\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterpolar\\\":[{\\\"type\\\":\\\"scatterpolar\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"histogram\\\":[{\\\"marker\\\":{\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"histogram\\\"}],\\\"scattergl\\\":[{\\\"type\\\":\\\"scattergl\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatter3d\\\":[{\\\"type\\\":\\\"scatter3d\\\",\\\"line\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}},\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scattermapbox\\\":[{\\\"type\\\":\\\"scattermapbox\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scatterternary\\\":[{\\\"type\\\":\\\"scatterternary\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"scattercarpet\\\":[{\\\"type\\\":\\\"scattercarpet\\\",\\\"marker\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}}}],\\\"carpet\\\":[{\\\"aaxis\\\":{\\\"endlinecolor\\\":\\\"#2a3f5f\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"minorgridcolor\\\":\\\"white\\\",\\\"startlinecolor\\\":\\\"#2a3f5f\\\"},\\\"baxis\\\":{\\\"endlinecolor\\\":\\\"#2a3f5f\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"minorgridcolor\\\":\\\"white\\\",\\\"startlinecolor\\\":\\\"#2a3f5f\\\"},\\\"type\\\":\\\"carpet\\\"}],\\\"table\\\":[{\\\"cells\\\":{\\\"fill\\\":{\\\"color\\\":\\\"#EBF0F8\\\"},\\\"line\\\":{\\\"color\\\":\\\"white\\\"}},\\\"header\\\":{\\\"fill\\\":{\\\"color\\\":\\\"#C8D4E3\\\"},\\\"line\\\":{\\\"color\\\":\\\"white\\\"}},\\\"type\\\":\\\"table\\\"}],\\\"barpolar\\\":[{\\\"marker\\\":{\\\"line\\\":{\\\"color\\\":\\\"#E5ECF6\\\",\\\"width\\\":0.5},\\\"pattern\\\":{\\\"fillmode\\\":\\\"overlay\\\",\\\"size\\\":10,\\\"solidity\\\":0.2}},\\\"type\\\":\\\"barpolar\\\"}],\\\"pie\\\":[{\\\"automargin\\\":true,\\\"type\\\":\\\"pie\\\"}]},\\\"layout\\\":{\\\"autotypenumbers\\\":\\\"strict\\\",\\\"colorway\\\":[\\\"#636efa\\\",\\\"#EF553B\\\",\\\"#00cc96\\\",\\\"#ab63fa\\\",\\\"#FFA15A\\\",\\\"#19d3f3\\\",\\\"#FF6692\\\",\\\"#B6E880\\\",\\\"#FF97FF\\\",\\\"#FECB52\\\"],\\\"font\\\":{\\\"color\\\":\\\"#2a3f5f\\\"},\\\"hovermode\\\":\\\"closest\\\",\\\"hoverlabel\\\":{\\\"align\\\":\\\"left\\\"},\\\"paper_bgcolor\\\":\\\"white\\\",\\\"plot_bgcolor\\\":\\\"#E5ECF6\\\",\\\"polar\\\":{\\\"bgcolor\\\":\\\"#E5ECF6\\\",\\\"angularaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"radialaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"}},\\\"ternary\\\":{\\\"bgcolor\\\":\\\"#E5ECF6\\\",\\\"aaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"baxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"},\\\"caxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\"}},\\\"coloraxis\\\":{\\\"colorbar\\\":{\\\"outlinewidth\\\":0,\\\"ticks\\\":\\\"\\\"}},\\\"colorscale\\\":{\\\"sequential\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]],\\\"sequentialminus\\\":[[0.0,\\\"#0d0887\\\"],[0.1111111111111111,\\\"#46039f\\\"],[0.2222222222222222,\\\"#7201a8\\\"],[0.3333333333333333,\\\"#9c179e\\\"],[0.4444444444444444,\\\"#bd3786\\\"],[0.5555555555555556,\\\"#d8576b\\\"],[0.6666666666666666,\\\"#ed7953\\\"],[0.7777777777777778,\\\"#fb9f3a\\\"],[0.8888888888888888,\\\"#fdca26\\\"],[1.0,\\\"#f0f921\\\"]],\\\"diverging\\\":[[0,\\\"#8e0152\\\"],[0.1,\\\"#c51b7d\\\"],[0.2,\\\"#de77ae\\\"],[0.3,\\\"#f1b6da\\\"],[0.4,\\\"#fde0ef\\\"],[0.5,\\\"#f7f7f7\\\"],[0.6,\\\"#e6f5d0\\\"],[0.7,\\\"#b8e186\\\"],[0.8,\\\"#7fbc41\\\"],[0.9,\\\"#4d9221\\\"],[1,\\\"#276419\\\"]]},\\\"xaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\",\\\"title\\\":{\\\"standoff\\\":15},\\\"zerolinecolor\\\":\\\"white\\\",\\\"automargin\\\":true,\\\"zerolinewidth\\\":2},\\\"yaxis\\\":{\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"ticks\\\":\\\"\\\",\\\"title\\\":{\\\"standoff\\\":15},\\\"zerolinecolor\\\":\\\"white\\\",\\\"automargin\\\":true,\\\"zerolinewidth\\\":2},\\\"scene\\\":{\\\"xaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2},\\\"yaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2},\\\"zaxis\\\":{\\\"backgroundcolor\\\":\\\"#E5ECF6\\\",\\\"gridcolor\\\":\\\"white\\\",\\\"linecolor\\\":\\\"white\\\",\\\"showbackground\\\":true,\\\"ticks\\\":\\\"\\\",\\\"zerolinecolor\\\":\\\"white\\\",\\\"gridwidth\\\":2}},\\\"shapedefaults\\\":{\\\"line\\\":{\\\"color\\\":\\\"#2a3f5f\\\"}},\\\"annotationdefaults\\\":{\\\"arrowcolor\\\":\\\"#2a3f5f\\\",\\\"arrowhead\\\":0,\\\"arrowwidth\\\":1},\\\"geo\\\":{\\\"bgcolor\\\":\\\"white\\\",\\\"landcolor\\\":\\\"#E5ECF6\\\",\\\"subunitcolor\\\":\\\"white\\\",\\\"showland\\\":true,\\\"showlakes\\\":true,\\\"lakecolor\\\":\\\"white\\\"},\\\"title\\\":{\\\"x\\\":0.05},\\\"mapbox\\\":{\\\"style\\\":\\\"light\\\"}}}},                        {\\\"responsive\\\": true}                    ).then(function(){\\n\",\n       \"                            \\n\",\n       \"var gd = document.getElementById('81fac275-efe7-4173-9197-73c2fe633d3d');\\n\",\n       \"var x = new MutationObserver(function (mutations, observer) {{\\n\",\n       \"        var display = window.getComputedStyle(gd).display;\\n\",\n       \"        if (!display || display === 'none') {{\\n\",\n       \"            console.log([gd, 'removed!']);\\n\",\n       \"            Plotly.purge(gd);\\n\",\n       \"            observer.disconnect();\\n\",\n       \"        }}\\n\",\n       \"}});\\n\",\n       \"\\n\",\n       \"// Listen for the removal of the full notebook cells\\n\",\n       \"var notebookContainer = gd.closest('#notebook-container');\\n\",\n       \"if (notebookContainer) {{\\n\",\n       \"    x.observe(notebookContainer, {childList: true});\\n\",\n       \"}}\\n\",\n       \"\\n\",\n       \"// Listen for the clearing of the current output cell\\n\",\n       \"var outputEl = gd.closest('.output');\\n\",\n       \"if (outputEl) {{\\n\",\n       \"    x.observe(outputEl, {childList: true});\\n\",\n       \"}}\\n\",\n       \"\\n\",\n       \"                        })                };                });            </script>        </div>\"\n      ]\n     },\n     \"metadata\": {},\n     \"output_type\": \"display_data\"\n    }\n   ],\n   \"source\": [\n    \"fig = go.Figure(layout={'showlegend':False, 'xaxis':{'range':(-500,500),}, 'height':800, 'yaxis':{'range':(-50,50)}})\\n\",\n    \"fig.add_trace(go.Scatter(x=mirror_z, y=mirror_x,fill='toself', mode='lines',fillcolor='red',line={\\\"color\\\":'red'}, marker={'size':0}, name='Mirror'))\\n\",\n    \"fig.add_trace(go.Scatter(x=grating_z, y=grating_x,fill='toself',  mode='lines',fillcolor='blue',line={\\\"color\\\":'blue'}, marker={'size':0}, name='Grating'))\\n\",\n    \"fig.update_xaxes(\\n\",\n    \"   scaleanchor=\\\"y\\\",\\n\",\n    \"    scaleratio=1,)\\n\",\n    \"\\n\",\n    \"fig.add_trace(go.Scatter(x=ray1z, y = ray1x, line={'color':'green', 'width':1.5}))\\n\",\n    \"fig.add_trace(go.Scatter(x=ray2z, y = ray2x, line={'color':'green', 'width':1.5}))\\n\",\n    \"fig.add_trace(go.Scatter(x=ray3z, y = ray3x, line={'color':'green', 'width':1.5}))\\n\",\n    \"\\n\",\n    \"\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"4fa70e97-df5a-43b9-a5cc-211ca76856cf\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": []\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"Python 3 (ipykernel)\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.11.9\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n", "type": "text"}, {"name": "__init__.py", "content": "", "type": "text"}, {"name": "requirements.txt", "content": "faicons\nshiny\nseaborn\npandas\npyplanemono_minimal\n", "type": "text"}, {"name": "shared.py", "content": "from pathlib import Path\n\nimport pandas as pd\n\napp_dir = Path(__file__).parent\n", "type": "text"}, {"name": "styles.css", "content": ":root {\n  --bslib-sidebar-main-bg: #f8f8f8;\n}", "type": "text"}, {"name": "static\\pgm.png", "content": "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", "type": "binary"}, {"name": "pyplanemono_minimal\\LICENSE", "content": "MIT License\nCopyright (c) 2023 Patrick Yuheng Wang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", "type": "text"}, {"name": "pyplanemono_minimal\\README.md", "content": "# pyplanemono-minimal\n\nThis is a minimised version of the PyPlaneMono project, which is a calculation suite for the geometry of the plane grating monochromator. This repository contains only only the core calculation and visualisation functionalities and no GUI components\nand is not capable of interacting with SHADOW as a pre-processor. For full functionality, refer to pyplanemono. This is meant to be distributed with the online interface of the PyPlaneMono project with maximum portability.\n\n", "type": "text"}, {"name": "pyplanemono_minimal\\__init__.py", "content": "", "type": "text"}, {"name": "pyplanemono_minimal\\pyproject.toml", "content": "[build-system]\nrequires = [\"setuptools>=61.0\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"pyplanemono_minimal\"\nversion = \"1.0\"\nauthors = [\n  { name=\"Patrick Wang\", email=\"patrick.wang@diamond.ac.uk\" },\n]\ndescription = \"X-ray tracing for plane grating monochromator. Minimal version with no interface to SHADOW.\"\nreadme = \"README.md\"\nrequires-python = \">=3.8.0\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Operating System :: OS Independent\",\n]\n\ndependencies = [\n    \"numpy >= 1.23.0\",\n    \"scipy >= 1.8.1\",\n    \"matplotlib >= 3.5.2\",\n]\n\n[tool.setuptools]\n\npackages = [\"pyplanemono_minimal\",\"pyplanemono_minimal.elements\",\"pyplanemono_minimal.geometry\"]\n\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\__init__.py", "content": "", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\__init__.py", "content": "from .mirror import *\nfrom .grating import *\nfrom .pgm import *", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\grating.py", "content": "from __future__ import annotations\nimport numpy as np\nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Plane, Ray3D\nfrom scipy.constants import c, h, e\n\n\nclass Grating(object):\n    \"\"\"\n    A class for a simple grating\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    dimensions : array_like\n        The dimensions of the grating in mm [length, width, height],\n        dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    \n    Attributes\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    alpha : float\n        The incident angle of the beam in degrees\n    beta : float    \n        The diffraction angle of the beam in degrees\n    dimensions : array_like\n        The dimensions of the grating in mm\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    Methods\n    -------\n    set_angles(alpha, beta)\n        Set the incident and diffraction angles of the grating\n    energy_to_wavelength()\n        Calculate the wavelength of the beam in Angstroms\n    compute_corners()\n        Compute the corners of the grating in the global coordinate system\n    diffract(*args)\n        A method to diffract rays off the grating\n    compute_beta(alpha, line_density, energy, order)\n        Calculate the diffraction angle beta from the incident angle alpha\n    reflect(*args)\n        A method to 'reflect' rays off the grating\n    \"\"\"\n    # Run a code formatter and linter to fix code style adn syntax errors. Black & Falke8 are good for this.\n    def __init__(self, \n                 line_density=600, \n                 energy=2400, \n                 cff=2, \n                 order=1, \n                 dimensions = np.array([200,40,50]), \n                 borders = np.array([0,0,0,0])):\n\n        self._line_density=line_density\n        self._energy=energy\n        self._cff=cff\n        self._order=order\n        self._alpha = None\n        self._beta = None\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._borders = borders\n        _,_ = self.compute_angles()\n        _ = self.compute_corners()\n\n\n\n    def __repr__(self):\n        # Use f-strings\n        return f\"Grating(line_density={self.line_density},\\n energy={self.energy}, \\n cff={self.cff}, \\n order={self.order}, \\n dimensions={self.dimensions},\\n borders={self.borders})\"\n    \n    def read_file(self, filename):\n        \"\"\"\n        Read grating parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['grating']) != 6:\n            # You could add config['grating'] into the error message\n            raise ValueError(\"Expected exactly five parameters in grating file\")\n\n        # Could use tuple instead of list\n        variables = ('line_density', 'energy', 'cff', 'order', 'dimensions')\n        for var in variables:\n            if var not in config['grating']:\n                raise ValueError(\"Missing parameter {} in grating file\".format(var))\n            \n        # You already check if variables in config['grating'] above and repeat below.\n        # Could use sets to create items from variable and config['grating'] to avoid list comprehension.\n        items = [x for x in variables if x in config['grating'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['grating'].values()):\n            setattr(self, key, value)\n            print(key)\n            print(value)\n        \n        self._order = int(self._order)\n        self._dimensions = np.array([float(x) for x in config['grating']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['grating']['borders'].split(',')])\n\n    @property\n    def line_density(self)-> float:\n        return self._line_density\n    \n    @line_density.setter\n    def line_density(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive line density\")\n        else:\n            self._line_density = value\n\n    @property\n    def energy(self)-> float:\n        return self._energy\n    \n    @energy.setter\n    def energy(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive energy\")\n        else:\n            self._energy = value\n        \n    @property\n    def cff(self)-> float:\n        return self._cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if value <= 1:\n            raise ValueError(\"Expected positive cff\")\n        else:\n            self._cff = value\n    \n    @property\n    def order(self)-> int:\n        return int(self._order)\n    \n    @order.setter\n    def order(self, value: int)-> None:\n        if value >= 1 and isinstance(value, int):\n            self._order = value\n            print(\"order set!\")\n        else:\n            raise ValueError(\"Expected positive integer order\")\n\n    @property\n    def alpha(self)-> float:   \n        return self._alpha\n    \n    @alpha.setter\n    def alpha(self, value)-> None:\n        if np.abs(value) <= 180 and isinstance(value, (float, int)):\n            self._alpha = value\n        else:\n            raise ValueError(\"Expected float alpha with magnitude less than 180 degrees\")\n\n    @property\n    def beta(self)-> float:\n        return self._beta\n    \n    @beta.setter\n    def beta(self, value: float)-> None:\n        self._beta = value\n    \n    @property\n    def dimensions(self):\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value):\n        if len(value) != 3:\n            raise ValueError(\"Expected exactly three values for dimensions\")\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._grating_plane\n    \n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._grating_plane = value\n        else:\n            raise TypeError(\"Expected Plane object for plane\")\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value: np.ndarray)-> None:\n        if len(value) != 4 or not isinstance(value, np.ndarray):\n            raise ValueError(\"Expected exactly 1D array of length 4 for borders\")\n        else:\n            self._borders = value\n\n\n    def set_angles(self, alpha: float, beta: float)-> None:\n        \"\"\"\n        Set the incident and diffraction angles of the grating.\n\n        Parameters\n        ----------\n        alpha : float\n            The incident angle in degrees\n        beta : float \n            The diffraction angle in degrees\n\n        Raises\n        ------\n        ValueError\n            If the wavelength is zero\n\n        \"\"\"\n        wavelength = (np.sin(np.deg2rad(alpha)) + np.sin(np.deg2rad(beta))) / (self.line_density*1000*self._order)\n        \n        if wavelength <= 0:\n            raise ValueError(\"Expected positive, non-zero wavelength\")\n\n        else:\n            self._energy = 12398.42 / wavelength #converts wavelength to eV\n        \n        self._alpha = alpha\n        self._beta = beta\n        self._cff = self.cff\n\n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value:any)-> None:\n        print(\"Input ignored, corners are computed from dimensions\")\n        self._corners = self.compute_corners()\n\n    def compute_beta(self)-> float:\n        \"\"\"\n        Compute the diffraction angle beta from the incident angle alpha.\n\n        Returns\n        -------\n        beta : float\n            The diffraction angle in degrees\n        \n    \n        \"\"\"\n        beta = 0\n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        u = self.order*self.line_density*1000*wavelength - np.sin(np.deg2rad(self.alpha))\n        beta = np.rad2deg(np.arcsin(u))\n        \n        \n        return beta\n\n    def compute_angles(self)-> tuple[float, float]:\n        \"\"\"\n        Compute the incident and diffraction angles of the grating.\n        The incident angle is calculated from the diffraction angle\n        using the fixed focus constant.\n\n        Returns\n        -------\n        alpha : float\n            The incident angle in degrees\n\n        beta : float\n            The diffraction angle in degrees\n        \n        \"\"\"\n        \n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        print(self.energy,\n              self.order,\n                self.line_density,\n                self.cff,\n               wavelength)\n        \n        lambda_u = self.order*self.line_density*1000*wavelength/(1-self.cff**2)\n        sin_alpha = lambda_u + np.sqrt(1+lambda_u**2*self.cff**2)\n        self._alpha = np.rad2deg(np.arcsin(sin_alpha))\n        self._beta = -np.rad2deg(np.arccos(np.cos(np.arcsin(sin_alpha))*self.cff))\n\n        return self._alpha, self._beta\n\n    # Could add type annotations on all your functions\n    def diffract(self, *args: Ray3D | list )-> list:\n        \"\"\"\n        A method to diffract rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be diffracted\n\n        Returns\n        -------\n        diffracted_rays : list of Ray3D\n            A list of diffracted rays\n\n        Raises\n        ------\n        raises ValueError too\n        TypeError\n            If the rays are not Ray3D objects\n\n        \"\"\"\n        diffracted_rays = []\n        \n\n        if isinstance(args[0], list):\n            args = args[0]\n\n        elif len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n\n        for _, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            raydotplane = ray.vector.dot(self._grating_plane.normal)\n            angle = np.arccos(raydotplane/np.linalg.norm(self._grating_plane.normal))\n            alpha = np.rad2deg(np.pi/2-angle)\n            beta = self.compute_beta()\n            diff_ray = self.reflect(ray)[0]\n            angle = -90 - beta - alpha\n            diff_ray.vector[2] += np.cos(np.deg2rad(angle))\n            diff_ray.vector[1] += np.sin(np.deg2rad(angle))\n            diff_ray.vector = diff_ray.vector/np.linalg.norm(diff_ray.vector)\n            diffracted_rays.append(diff_ray)\n        return diffracted_rays\n    \n    \n\n    # rename something like energy_to_wavelength\n    def energy_to_wavelength(self, energy: float)-> float:\n        return h*c/(e*energy)\n    \n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the grating in the global coordinate system.\n\n        Returns\n        -------\n        corners : array_like\n            The corners of the grating in the global coordinate system:\n            [bottom left back, \n            bottom right back, \n            bottom left front, \n            bottom right front,\n            top left back,\n            top right back,\n            top left front,\n            top right front]\n        \"\"\"\n        \n        beta = np.deg2rad(self._beta)\n        # beta_g not used\n        beta_g = np.deg2rad(self._beta + 90)\n        l = self._length()\n        w = self._width()\n        d = self._height()        \n        #Bottom left back\n        blbz = (l/2)*np.sin(beta)\n        blby = -(l/2)*np.cos(beta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        #Bottom left front\n        blfz = -(l/2)*np.sin(beta)\n        blfy = (l/2)*np.cos(beta)\n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = blbz - d*np.cos(beta)\n        tlby = blby - d*np.sin(beta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Top right back\n        trbz = brbz - d*np.cos(beta)\n        trby = brby - d*np.sin(beta)\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Top left front\n        tlfz = blfz - d*np.cos(beta)\n        tlfy = blfy - d*np.sin(beta)\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Top right front\n        trfz = brfz - d*np.cos(beta)\n        trfy = brfy - d*np.sin(beta)\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        self._grating_plane = Plane(\n            Point3D(blfx, blfy, blfz),\n            Point3D(brfx, brfy, brfz),\n            Point3D(blbx, blby, blbz)\n        )\n\n        self._corners = np.array([\n            blb,\n            brb,\n            blf,\n            brf,\n            tlb,\n            trb,\n            tlf,\n            trf\n        ])\n\n        return self._corners\n\n    def reflect(self, *args, zero_order = False)-> list:\n        \"\"\"\n        A method to reflect rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        # Check after determining if list\n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        # se isinstance\n        if type(args[0]) == list:\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._grating_plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect grating, tread with caution!')\n                continue\n            ray_array = ray.vector\n            grating_normal = self._grating_plane.normal\n            if zero_order:\n                \n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, -grating_normal) * grating_normal\n            else:\n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, grating_normal) * grating_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n\n    @classmethod\n    def grating_from_file(cls, filename):\n        \"\"\"\n        Create a grating from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        grating = cls()\n        grating.read_file(filename)\n        return grating\n    \n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\mirror.py", "content": "from __future__ import annotations\n# List not used\nfrom ast import List\nfrom matplotlib.pyplot import isinteractive\nimport numpy as np\nfrom pyplanemono_minimal.geometry import Point3D, Vector3D, Plane, Ray3D\nimport configparser\n\nclass Plane_Mirror(object):\n    \"\"\"\n    A class for a simple plane mirror.\n\n    Parameters\n    ----------\n    voffset : float, optional\n        The vertical offset of the mirror in mm\n    hoffset : float, optional\n        The horizontal offset of the mirror in mm\n    axis_voffset : float, optional\n        The vertical offset of the mirror axis in mm\n    axis_hoffset : float, optional\n        The horizontal offset of the mirror axis in mm\n    dimensions : array_like, optional\n        The dimensions of the mirror in mm [length, width, height]\n        Dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    theta : float, optional\n        The angle of the mirror in degrees\n    plane : Plane, optional\n        The plane of the mirror\n    borders: array_like, optional\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    \n\n    Attributes\n    ----------\n    dimensions : array_like\n        The dimensions of the mirror in mm\n    position : Point3D\n        The position of the mirror\n    normal : Vector3D\n        The normal vector of the mirror\n    orientation : Vector3D\n        The orientation of the mirror\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    plane : Plane\n        The plane of the mirror\n    \n    borders: array_like\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    Methods\n    -------\n    set_position(position)\n        Set the position of the mirror\n    set_normal(normal)\n        Set the normal vector of the mirror\n    set_orientation(orientation)\n        Set the orientation of the mirror\n    set_dimensions(*args)\n        Set the dimensions of the mirror\n    set_offsets(voffset, hoffset, axis_voffset, axis_hoffset)\n        Set the offsets of the mirror\n    compute_corners()\n        Compute the corners of the mirror in the global coordinate system,  \n    \n    \n    \"\"\"\n\n    def __init__(self, \n                 voffset=13, \n                 hoffset=40, \n                 axis_voffset=6.5, \n                 axis_hoffset=0, \n                 dimensions = np.array([450, 70, 50]),\n                 theta=45, \n                 plane=Plane(),\n                 borders = np.array([0,0,0,0])\n                 ):\n        \"\"\"\n        Constructor for the Plane_Mirror class.\n\n        Parameters\n        ----------\n        voffset : float\n            The vertical offset of the mirror in mm\n        hoffset : float\n            The horizontal offset of the mirror in mm\n        axis_voffset : float\n            The vertical offset of the mirror axis in mm\n        axis_hoffset : float\n            The horizontal offset of the mirror axis in mm\n        dimensions : array_like\n            The dimensions of the mirror in mm [length, width, height]\n            Dimensions are also accessible with lambda functions as:\n            self._length(), self._width(), self._height()\n\n        \n        theta : float\n            The angle of the mirror in degrees\n        plane : Plane\n            The plane of the mirror\n        \n        \"\"\"\n\n        self._voffset = voffset\n        self._hoffset = hoffset\n        self._axis_voffset = axis_voffset\n        self._axis_hoffset = axis_hoffset\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._plane = plane\n        self._theta = theta\n        # Just call method without assigning to _\n        _ = self.compute_corners()\n        self._borders = borders\n\n\n    def __repr__(self):\n        # Use f-string\n        return \"\"\"Plane_Mirror(voffset={}, \n        hoffset={}, \n        axis_voffset={}, \n        axis_hoffset={}, \n        length={}, \n        width={}, \n        height={}, \n        plane={},\n        borders={})\n        \"\"\".format(self.voffset,\n                            self.hoffset, \n                            self.axis_voffset, \n                            self.axis_hoffset, \n                            self._length(), \n                            self._width(), \n                            self._height(), \n                            self.plane,\n                            self.borders)\n    \n\n    # read_file is very similar to read_file in grating.py. Refactor to use common code.\n    def read_file(self, filename):\n        \"\"\"\n        Read mirror parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['mirror']) != 7:\n            raise ValueError(\"Expected exactly six parameters in mirror file\")\n\n        variables = ['voffset', 'hoffset', 'axis_voffset', 'axis_hoffset', 'dimensions', 'theta']\n        for var in variables:\n            if var not in config['mirror']:\n                raise ValueError(\"Missing parameter {} in mirror file\".format(var))\n        \n        items = [x for x in variables if x in config['mirror'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['mirror'].values()):\n            # Don't use exec. Either explicitly assign variables or if you will not know what they will be, use a dictionary not variables.\n            exec(f\"self._{key} = float({value})\")\n            print(key)\n            print(value)\n        \n        \n        self._dimensions = np.array([float(x) for x in config['mirror']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['mirror']['borders'].split(',')])\n        \n\n    @property\n    def voffset(self)-> float:\n\n        return self._voffset\n\n    @voffset.setter\n    def voffset(self, value: float)-> None:\n        if isinstance(value, float):\n            self._voffset = value  \n        else:\n            raise TypeError(\"Expected voffset to be float!\")\n    @property\n    def a(self)-> float:\n        return self._hoffset\n    \n    @a.setter\n    def a(self, value: float)-> None:\n        self.hoffset = float(value)\n\n    @property\n    def hoffset(self)-> float:\n        return self._hoffset\n\n    @hoffset.setter\n    def hoffset(self, value: float):\n        if isinstance(value, float):\n            self._hoffset = value\n        else:\n            raise TypeError(\"Expected hoffset to be float!\")\n\n    @property\n    def c(self)-> float:\n        return self._voffset\n    \n    @c.setter\n    def c(self, value: float)-> None:\n        self.voffset = float(value)\n\n    \n\n    @property\n    def axis_voffset(self)-> float:\n        return self._axis_voffset\n\n    @axis_voffset.setter\n    def axis_voffset(self, value: float):\n        if isinstance(value, float):\n            self._axis_voffset = value\n        else:\n            raise TypeError(\"Expected axis voffset to be float!\")\n\n    @property\n    def v(self)-> float:\n        return self._axis_voffset\n    \n    @v.setter\n    def v(self, value: float)-> None:\n        self.axis_voffset = float(value)\n\n\n    @property\n    def axis_hoffset(self)-> float:\n        return self._axis_hoffset\n\n    @axis_hoffset.setter\n    def axis_hoffset(self, value:float):\n        if isinstance(value, float):\n            self._axis_hoffset = value\n        else:\n            raise TypeError(\"Expected axis hoffset to be float!\")\n\n    @property\n    def h(self)-> float:\n        return self._axis_hoffset\n    \n    @h.setter\n    def h(self, value: float)-> None:\n        self.axis_hoffset = float(value)\n    \n\n    @property\n    def dimensions(self)-> np.ndarray:\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value:float):\n        \"\"\"\n        Sets the dimensions of the mirror.\n        The dimensions are specified as:\n        [length, width, height]\n\n        \"\"\"\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._plane\n\n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._plane = value\n        else:\n            raise TypeError(\"Expected value to be Plane instance!\")\n    \n    @property\n    def theta(self)-> float:\n        return self._theta\n    \n    @theta.setter\n    def theta(self, value: float)-> float:\n        self._theta = value\n    \n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value):\n        print(\"Input value ignored, corners computed from parameters!\")\n        self.compute_corners()\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value)-> None:\n        \"\"\"\n        Sets the borders of the mirror.\n        The borders are specified as:\n        |-----------Top------------|\n        |                          |\n         Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n        \"\"\"\n        if isinstance(value, np.ndarray) and len(value)==4:\n            if all(value > 0):\n                self._borders = value\n            else:\n                raise ValueError(\"Lengths should be positive.\")\n        else:\n            raise ValueError(\"Expected 1D numpy array with length 4\")\n\n\n    def set_position(self, position: Point3D)-> None:\n        if isinstance(position, Point3D):\n            self._plane.position = position\n        else:\n            raise TypeError(\"Expected Point3D instance for position value!\")\n\n    def set_normal(self, normal: Vector3D)-> None:\n        if isinstance(normal, Vector3D):\n            self._plane.normal = normal\n        else:\n            raise TypeError(\"Expected Vector3D instance for normal value!\")\n\n    # Combine with setter\n    def set_dimensions(self, *args: np.ndarray | float)-> None:\n        \"\"\"\n        Set the dimensions of the mirror.\n\n        Parameters\n        ----------\n        *args : array_like\n            Either one or three arguments for the dimensions\n\n        Raises\n        ------\n        ValueError\n            If the number of arguments is not one or three\n\n        \"\"\"\n        # compute length once and assign to variable. Can use this in error msg.\n        # Will raise ValueError if args does not have length, so check that too.\n        length_of_args = len(args)\n        if length_of_args == 1:\n            self._dimensions = args[0]\n        elif length_of_args == 3:\n            self._dimensions = np.array(args)\n        else:\n            raise ValueError(f\"Expected either one or three arguments for dimensions, got length of {length_of_args} instead.\")\n\n    def set_offsets(self, voffset: float, hoffset: float, axis_voffset: float, axis_hoffset: float)-> None:\n        self.voffset(voffset)\n        self.hoffset(hoffset)\n        self.axis_voffset(axis_voffset)\n        self.axis_hoffset(axis_hoffset)\n\n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the mirror in the global coordinate system,\n        in addition to the plane and normal of the mirror.\n    \n\n        Returns\n        -------\n        corners : np.ndarray\n            The corners of the mirror in the global coordinate system\n            [top left front,\n            top right front,\n            bottom left front,\n            bottom right front,\n            top left back,\n            top right back,\n            bottom left back,\n            bottom right back]\n        \n        \n        \"\"\"\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.theta)\n        theta_g = 90 - self._theta\n        theta_g = np.deg2rad(theta_g)\n        a = self._hoffset\n        c = self._voffset\n        v = self._axis_voffset\n        h = self._axis_hoffset\n        w = self._width()\n        l = self._length()\n        d = self._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Bottom left front\n        blfz = tlfz + d*np.cos(theta)\n        blfy = tlfy - d*np.sin(theta)        \n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Bottom left back\n        blbz = tlbz + d*np.cos(theta)\n        blby = tlby - d*np.sin(theta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        self._plane = Plane(tlf, trf, tlb)\n\n        self._corners = np.array([\n            tlf,\n            trf,\n            blf,\n            brf,\n            tlb,\n            trb,\n            blb,\n            brb\n        ])\n\n        return self._corners\n\n    @classmethod\n\n    def mirror_from_file(cls, filename: str)-> Plane_Mirror:\n        \"\"\"\n        Create a mirror from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        mirror = cls()\n        mirror.read_file(filename)\n        return mirror\n\n    def reflect(self, *args: Ray3D | list) -> list:\n        \"\"\"\n        A method to reflect rays off the mirror.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list of Ray3D\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        if isinstance(args[0], list):\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect mirror, tread with caution!')\n                continue\n            ray_array = ray.vector\n            mirror_normal = self._plane.normal\n            reflected_ray_array = ray_array - 2 * np.dot(ray_array, mirror_normal) * mirror_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\elements\\pgm.py", "content": "from __future__ import annotations\nfrom matplotlib.axes import Axes\nimport numpy as np\nfrom matplotlib.patches import Patch \nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Ray3D\nfrom scipy.spatial import ConvexHull\nfrom matplotlib.lines import Line2D\nfrom pyplanemono_minimal.elements import Plane_Mirror, Grating\n\nclass PGM(object):\n    \"\"\"\n    A class for a PGM setup.\n\n    Parameters\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n\n    Attributes\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n    rays : list\n        The rays to be propagated through the PGM\n    beam_offset : float\n        The vertical offset of the beam in mm\n    beam_width : float\n        The width of the beam in mm\n    beam_height : float\n        The height of the beam in mm\n    \n    Methods\n    -------\n    read_file(filename)\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n    propagate(*args)\n        Propagate rays through the PGM setup.\n    draw_sideview(ax)\n        Draws the setup on a y-z projection on a given axis.\n    draw_topview(ax)\n        Draws the setup on a x-z projection on a given axis, along with the beam footprints.\n    \"\"\"\n\n    def __init__(self, grating = None, mirror = None, **kwargs):\n        \"\"\"\n        \n        Constructor for the PGM class.\n        \n        Parameters\n        ----------\n        grating : Grating\n            The grating component of the PGM\n        mirror : Plane_Mirror\n            The mirror component of the PGM\n        **kwargs : \n            Keyword arguments for the grating and mirror components.\n            See Grating and Plane_Mirror classes for details.\n\n        \n        \"\"\"\n        # It's unclear what is happening here and there will be uncaught errors if kwargs is not as expected.\n        if grating is None:\n            grating_kwargs = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'grating_dimensions'\n            ]\n            grating_kwarg_keys = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'dimensions'\n            ]\n        \n            grating_args = [kwargs.get(x) for x in grating_kwargs]\n            grating_kwargs = dict(zip(grating_kwarg_keys, grating_args))\n            self._grating = Grating(**grating_kwargs)\n\n        else:\n            self._grating = grating\n        \n        if mirror is None:\n            mirror_kwargs = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'mirror_dimensions',\n                'theta'\n            ]\n            mirror_kwarg_keys = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'dimensions',\n                'theta'\n            ]\n        \n            mirror_args = [kwargs.get(x) for x in mirror_kwargs]\n            mirror_kwargs = dict(zip(mirror_kwarg_keys, mirror_args))\n            self._mirror = Plane_Mirror(**mirror_kwargs)\n            \n        else:\n            self._mirror = mirror\n\n        \n        self._rays = []\n        self._beam_offset = 13\n        self._beam_width = 6.43\n        self._beam_height = 5\n        self._energy = 2400\n\n    def __repr__(self):\n        return \"\"\"PGM(grating={}, \\nmirror={}, \\nb={},\\nbeam_width={},\\nbeam_height={})\"\"\".format(self.grating, \n                                                               self.mirror,\n                                                               self.beam_offset,\n                                                               self.beam_width,\n                                                               self.beam_height)\n    \n    def generate_rays(self):\n        \"\"\"\n        Generate rays for the PGM setup.\n        \"\"\"\n        \n        r0 = Ray3D(Point3D(0, self.beam_offset, -1000),\n                   Point3D(0, self.beam_offset, 0)-\n                   Point3D(0, self.beam_offset, -1000))\n        \n        r1 = Ray3D(Point3D(0, self.beam_offset + self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset + self.beam_height/2, 0)-\n                     Point3D(0, self.beam_offset + self.beam_height/2, -1000)\n                   )\n\n        r2 = Ray3D(Point3D(0, self.beam_offset - self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset - self.beam_height/2, 0) -\n                   Point3D(0, self.beam_offset - self.beam_height/2, -1000))\n\n        r3 = Ray3D(Point3D(-self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(-self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(-self.beam_width/2, self.beam_offset, -1000))\n\n        r4 = Ray3D(Point3D(self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(self.beam_width/2, self.beam_offset, -1000))\n\n        self._rays = [r0, r1, r2, r3, r4]\n\n\n    def read_file(self, filename):\n        \"\"\"\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        \n        self._grating.read_file(filename)\n        self._mirror.read_file(filename)\n        pgm_config = configparser.ConfigParser()\n        pgm_config.read(filename)\n        self._energy = float(pgm_config['beam']['energy'])\n        self._beam_offset = float(pgm_config['beam']['beam_offset'])\n        self._beam_width = float(pgm_config['beam']['beam_width'])\n        self._beam_height = float(pgm_config['beam']['beam_height'])\n    \n\n    def set_theta(self):\n        \"\"\"\n        Set the angle of the grating.\n        \"\"\"\n        self.mirror.theta = 0.5 * (self.grating.alpha-self.grating.beta)\n\n    @property\n\n    def theta(self):\n        return self.mirror.theta\n\n    @theta.setter\n\n    def theta(self, value):\n        self.theta = value\n        self.mirror.theta = value\n\n    @property\n\n    def energy(self):\n        return self.grating.energy\n    \n    @property\n    def wavelength(self):\n        return 1239.8419843320025/self.energy\n    \n    @energy.setter\n    # need validation for energy value, e.g. non-zero\n    def energy(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 0:\n            self.grating.energy = value\n        else:\n            print(value, type(value))\n            raise ValueError(\"Expected energy to be a positive float!\")\n    @property\n    def grating(self)-> Grating:\n        return self._grating\n    \n    @grating.setter\n    def grating(self, value: Grating)-> None:\n        if isinstance(value, Grating):\n            self._grating = value\n        else: \n            raise TypeError(\"Expected Grating instance for grating!\")\n    \n    @property\n    def mirror(self)-> Plane_Mirror:\n        return self._mirror\n    \n    @mirror.setter\n    def mirror(self, value: Plane_Mirror):\n        if isinstance(value, Plane_Mirror):\n            self._mirror = value\n        else:\n            raise TypeError(\"Expected Plane_Mirror instance for mirror!\")\n    @property\n    def rays(self)-> list[Ray3D]:\n        return self._rays\n    \n    @rays.setter\n    def rays(self, value: list[Ray3D])-> None:\n        self._rays = value\n    \n    @property\n    def beam_offset(self)-> float:\n        return -1*self._beam_offset\n    \n    @beam_offset.setter\n    def beam_offset(self, value: float)-> None:\n        if isinstance(value, (float, int)):\n            self._beam_offset = -1*value\n        else:\n            raise TypeError(\"Expected float for beam_offset!\")\n        \n    @property\n    def b(self)-> float:\n        return self._beam_offset\n    \n    @b.setter\n    def b(self, value: float)-> None:\n        self.beam_offset = value\n\n    @property\n    def beam_width(self)-> float:\n        return self._beam_width\n    \n    @beam_width.setter\n    def beam_width(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_width = value\n        else:\n            raise TypeError(\"Expected non-negative float for beam_width!\")\n    \n    @property\n    def beam_height(self)-> float:\n        return self._beam_height\n    \n    @beam_height.setter\n    def beam_height(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_height = value\n        else:\n            raise ValueError(\"Expected non-negative float for beam_height!\")\n\n\n    @property\n    def mirror_intercept(self)-> Point3D:\n        return self._mirror_intercept\n    \n    @property\n    def grating_intercept(self)-> Point3D:\n        return self._grating_intercept\n    \n    \n    @property\n    def cff(self)-> float:\n        return self.grating.cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 1:\n            self.grating.cff = value\n        else:\n            raise ValueError(\"Expected cff to be a positive float bigger than 1!\")\n\n    def values(self)-> dict:\n\n        dictionary = {'beam_vertical': self.beam_offset,\n                      'beam_width': self.beam_width,\n                      'beam_height': self.beam_height,\n                      'line_density': self.grating.line_density,\n                      'energy': self.grating.energy,\n                      'cff': self.grating.cff,\n                      'order': self.grating.order,\n                      'grating_dimensions': self.grating.dimensions,\n                      'grating.borders': self.grating.borders,\n                      'mirror_voffset': self.mirror.voffset,\n                      'mirror_hoffset': self.mirror.hoffset,\n                      'mirror_axis_voffset': self.mirror.axis_voffset,\n                      'mirror_axis_hoffset': self.mirror.axis_hoffset,\n                      'mirror_dimensions': self.mirror.dimensions,\n                      'mirror_theta': self.mirror.theta,\n                      'mirror_borders': self.mirror.borders}\n        return dictionary\n\n    @classmethod\n\n    def pgm_from_file(cls, filename:float)-> PGM:\n        \"\"\"\n        Create a PGM from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        pgm = cls()\n        pgm.read_file(filename)\n        return pgm\n\n    def propagate(self, *args: Ray3D | list)-> tuple:\n        \"\"\"\n        Propagate rays through the PGM setup.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be propagated\n        \n        Returns\n        -------\n        grating_ray : list of Ray3D objects\n            A list of propagated rays originating at the grating intercept\n        \n        mirror_intercept : list of array_like\n            A list of the mirror intercepts\n\n        grating_intercept : list of array_like\n            A list of the grating intercepts\n\n        \"\"\"\n        _ = self._mirror.compute_corners()\n        _ = self._grating.compute_corners()\n\n        mirr_ray = self._mirror.reflect(*args)\n        grating_ray = self._grating.diffract(*mirr_ray)\n        mirror_intercept = [mirr_ray.position for mirr_ray in mirr_ray]\n        grating_intercept = [grating_ray.position for grating_ray in grating_ray]\n        \n        # _mirror_intercept and _grating_intercept not defined in __init__\n        self._mirror_intercept = mirror_intercept\n        self._grating_intercept = grating_intercept\n        return grating_ray, mirror_intercept, grating_intercept\n\n\n    def draw_sideview(self, ax: Axes):\n        \"\"\"\n        Draws the setup on a y-z projection on a given axis.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes\n            The axis to draw on\n\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        grating_corners = self.grating.compute_corners()\n        mirror_corners_y, mirror_corners_z = mirror_corners[::2,1], mirror_corners[::2,2]\n        mirror_corners_yz = np.array([mirror_corners_z, mirror_corners_y]).T\n        # ConvexHull sp?\n        # ConvelHull method used to ensure the entire region is filled regardless\n        # of point order.\n        hull_grating = ConvexHull(mirror_corners_yz)\n\n        grating_corners_y, grating_corners_z = grating_corners[::2,1], grating_corners[::2,2]\n        grating_corners_yz = np.array([grating_corners_z, grating_corners_y]).T\n        hull_mirror = ConvexHull(grating_corners_yz)\n\n        ax.fill(mirror_corners_yz[hull_mirror.vertices,0], mirror_corners_yz[hull_mirror.vertices,1], 'r')\n        ax.fill(grating_corners_yz[hull_grating.vertices,0], grating_corners_yz[hull_grating.vertices,1], 'b')\n\n        self.generate_rays()\n        grating_ray, mirror_int, grating_int = self.propagate(self.rays)\n        #print(\"Side view r3 int:\", mirror_int[3])\n        for index, ray in enumerate(grating_ray):\n            r_z = np.array([\n            self.rays[index].position.z,\n            mirror_int[index].z,\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            self.rays[index].position.y,\n            mirror_int[index].y,\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='green', linewidth=1, label='Dispersed Rays')\n            ax.add_line(line)\n        \n        zero_order_rays = self.grating.reflect(self.rays, zero_order=True)\n\n        \"\"\"\n        for index, ray in enumerate(zero_order_rays):\n            r_z = np.array([\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='gray', linewidth=1, label='Zero Order Reflections')\n            ax.add_line(line)\n        \"\"\"\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n        ]\n        ax.legend(handles=legend_entries, loc = 'lower right', fontsize=16, fancybox=True, shadow=True)\n        ax.axhline(y=0, color='black', linestyle='--', linewidth=1.3)\n        ax.axvline(x=0, color='black', linestyle='--', linewidth=1.3)\n        \n    def draw_topview(self, ax: Axes)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        \n        self.generate_rays()\n        \n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        _, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        _, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        _, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        _, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n        #print(\"Mirror footprint width:\", mirror_footprint_width)\n       # print(\"Mirror footprint height:\", mirror_footprint_height)\n        #print(\"Grating footprint width:\", grating_footprint_width)\n       # print(\"Grating footprint height:\", grating_footprint_height)\n        \n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        ax.fill(mirror_corners[:,0], mirror_corners[:,1], 'r',alpha=1, label='Mirror')\n        ax.fill(grating_corners[:,0], grating_corners[:,1], 'b',alpha=0.5, label='Grating')\n        ax.fill(mirr_footprint_corners[:,0], mirr_footprint_corners[:,1], c='black')\n        ax.fill(grating_footprint_corners[:,0], grating_footprint_corners[:,1], c='green')\n        ax.grid(axis='both', which='both', alpha = 0.5)\n        ax.set_xticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xticks(np.arange(-1000, 1000, 100), minor=False)\n        ax.set_yticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xlim(min(mirror_corners[:,0]), max(grating_corners[:,0]))\n        ax.set_ylim(min(mirror_corners[:,1]), max(grating_corners[:,1]))\n        #ax.fill(mirror_rect_borders[:,0], mirror_rect_borders[:,1], 'r',alpha=0.5)\n        #ax.fill(m_corners[:,] , 'r',alpha=1)\n        #x.fill(grating_rect_borders[:,0], grating_rect_borders[:,1], 'b',alpha=1)\n        #ax.fill(grating_rect[:,0], grating_rect[:,1], 'b',alpha=0.5, label='Grating')\n        #ax.fill([mirror_blz, mirror_blz + mirror_l, mirror_blz + mirror_l, mirror_blz], [mirror_blx, mirror_blx, mirror_blx + mirror_w, mirror_blx + mirror_w], 'g', alpha=0.5, label='Beam Footprint')\n        #ax.fill([grating_blz, grating_blz + grating_l, grating_blz + grating_l, grating_blz], [grating_blx, grating_blx, grating_blx + grating_w, grating_blx + grating_w], 'g', alpha=0.5)\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n            Patch(facecolor=(0,0,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Mirror): {mirror_footprint_width:.2f} mm x {mirror_footprint_height:.2f} mm'),\n            Patch(facecolor=(0,1,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Grating): {grating_footprint_width:.2f} mm x {grating_footprint_height:.2f} mm')\n\n        ]\n\n        ax.legend(handles=legend_entries, loc = 'upper left', fontsize=12, fancybox=True, shadow=True)\n\n\n    def topview_trace(self)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        # use your _width and _length setters\n        \n        self.generate_rays()\n        \n        # _, mirror_intercept, grating_intercept\n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        grating_ray, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        grating_ray, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        grating_ray, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        grating_ray, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n\n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        return mirror_intercepts, grating_intercepts\n        \n\n    def calc_footprint_size(self, intercepts: list[Point3D])-> tuple:\n        \"\"\"\n        Calculate the size of the footprint of the beam on the grating or the mirror\n        when given the intercepts of the beam with the grating or the mirror.\n         \n        \n        Parameters\n        ----------\n        intercepts : list of Point3D objects\n            The intercepts of the beam with the grating or the mirror\n            [r_1, r_2, r_3, r_4]\n\n        Returns\n        -------\n        size : tuple\n            The size of the footprint of the beam on the grating or the mirror in mm\n        \"\"\"\n\n        r_1, r_2, r_3, r_4 = intercepts\n    \n        width = r_1.distance(r_2)\n        height = r_3.distance(r_4)\n\n        return width, height\n\n\n    def centre_of_footprint(self):\n        \"\"\"\n        Calculate the centre of the footprint of the beam on the grating or the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the footprint of the beam on the grating or the mirror\n        \"\"\"\n        _, mirror_int_0, grating_int_0 =  self.propagate(self.rays[0])\n\n        return mirror_int_0, grating_int_0\n        \n    def find_offset(self):\n\n        mirror_int, grating_int = self.centre_of_footprint()\n        mirror_int = mirror_int[0]\n        grating_int = grating_int[0]\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        #print(mirror_corners)\n        centre_of_mirror_top = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        #print([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]])\n        #print(centre_of_mirror_top)\n        mirror_offset =  np.array([mirror_int.x, mirror_int.y, mirror_int.z]) - centre_of_mirror_top\n        #print(mirror_offset)\n        mirror_offset = np.linalg.norm(mirror_offset) * mirror_offset[1]/np.abs(mirror_offset[1])\n\n        grating_offset = np.linalg.norm(grating_int) * grating_int[1]/np.abs(grating_int[1])\n        return mirror_offset, grating_offset\n    \n    def centre_of_mirror(self):\n        \"\"\"\n        Calculate the centre of the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the mirror\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        centre_of_mirror = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        return centre_of_mirror\n\n\n    def mirror_corners(self)-> tuple:\n\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.mirror.theta)\n        theta_g = 90 - self.theta\n        theta_g = np.deg2rad(theta_g)\n        a = self.mirror._hoffset\n        c = self.mirror._voffset\n        v = self.mirror._axis_voffset\n        h = self.mirror._axis_hoffset\n\n        w = self.mirror._width()\n        l = self.mirror._length()\n        d = self.mirror._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        return ((tlfz, tlfx), (trfz, trfx), (trbz, trbx), (tlbz, tlbx))\n\n    def grating_corners(self)-> tuple:\n        \n        l = self.grating._length()\n        w = self.grating._width()\n        beta = self.grating.beta\n        \n        beta_g = 90 + beta\n        beta_rad = beta_g*np.pi/180\n\n        blbz = -(l/2)*np.cos(beta_rad)\n        blbx = -w/2\n\n        brbz = -(l/2)*np.cos(beta_rad)\n        brbx = w/2\n\n        blfz = (l/2)*np.cos(beta_rad)\n        blfx = -w/2\n\n        brfz = (l/2)*np.cos(beta_rad)\n        brfx = w/2\n\n        return ((blbz, blbx), (brbz, brbx), (brfz, brfx), (blfz, blfx))\n    \n    def corners(self)-> tuple[dict]:\n        \"\"\"\n        Calculate the corners of the mirror and grating.\n        \n        Returns\n        -------\n        corners : dict\n            The corners of the grating and mirror in the following order:\n            bottom left back, bottom right back, bottom left front, bottom right front,\n            top left back, top right back, top left front, top right front\n        \"\"\"\n        positions = [\n            \"bottom left back\",\n            \"bottom right back\",\n            \"bottom left front\",\n            \"bottom right front\",\n            \"top left back\",\n            \"top right back\",\n            \"top left front\",\n            \"top right front\"\n        ]\n        grating_corners = self.grating.compute_corners()\n        grating_corners_dict = dict(zip(positions, grating_corners))\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners_dict = dict(zip(positions, mirror_corners))\n\n        return grating_corners_dict, mirror_corners_dict\n            \n\n    @staticmethod\n    def undulator_size():\n        pass\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\geometry\\__init__.py", "content": "from .geometry import *\n#from .light import *", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal\\geometry\\geometry.py", "content": "\"\"\"\nA module containing classes for simple 3D geometry\nused in ray tracing of X-ray optics.\n\nAuthor: Patrick Wang\nEmail: patrick.wang@diamond.ac.uk\n\nVersion: 0.2.2\nDate: 2023-09-15\n\n\"\"\"\nfrom __future__ import division, print_function\nimport numpy as np\n\nclass Ray3D(object):\n    \"\"\"\n    A class for a simple 3D ray\n\n    Parameters\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n    \n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the ray\n\n    Attributes\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n\n    \"\"\"\n    def __init__(self, position, vector):\n        self._position = position\n        vector_mag = np.linalg.norm(vector)\n        if vector_mag == 0:\n            raise ValueError(\"Vector magnitude cannot be zero\")\n        self._vector = vector / vector_mag\n\n    def __repr__(self):\n        # use f-string\n        return f\"Ray3D(position={self.position}, vector={self.vector})\"\n    @property\n    def position(self):\n        return self._position\n    \n    @position.setter\n    def position(self, value):\n        self._position = value\n    \n    @property\n    def vector(self):\n        return self._vector\n    \n    @vector.setter\n    def vector(self, value):\n        self._vector = value / np.linalg.norm(value)\n\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\n\n\nclass Point3D(object):\n    \"\"\"\n    A class for a simple 3D point.\n\n    Parameters\n    ----------\n    x : float\n        The x coordinate of the point\n    y : float\n        The y coordinate of the point\n    z : float\n        The z coordinate of the point\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the point\n    __add__ : Point3D\n        Adds two points together\n    __sub__ : Point3D\n        Subtracts two points\n    __eq__ : bool\n        Checks if two points are equal\n    __ne__ : bool\n        Checks if two points are not equal\n    __getitem__ : float\n        Returns the x, y or z coordinate of the point\n    __setitem__ : float\n        Sets the x, y or z coordinate of the point\n    __iter__ : float\n        Returns an iterator over the point\n    __len__ : int\n        Returns the length of the point\n    __hash__ : int \n        Returns the hash of the point\n    __copy__ : Point3D\n        Returns a copy of the point\n    __deepcopy__ : Point3D\n        Returns a deep copy of the point\n    copy : Point3D\n        Returns a copy of the point\n    distance : float\n        Finds the distance between two points\n    \"\"\"\n\n    def __init__(self, x, y, z):\n        self._point = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        # f-string\n        return \"Point3D(x={}, y={}, z={})\".format(self.x, self.y, self.z)\n    \n    def __add__(self, other):\n        return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other._point)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._point, other._point)\n    \n    def __getitem__(self, key):\n        return self._point[key] \n    \n    def __setitem__(self, key, value):\n        self._point[key] = value\n\n    def __iter__(self):\n        return iter(self._point)    \n\n    def __len__(self):\n        return len(self._point)\n    \n    def __hash__(self):\n        return hash(self._point.tostring())\n    \n    def __copy__(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Point3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def distance(self, other):\n        # use point property rather than accessing other._point\n        return np.linalg.norm(self._point - other._point)\n    \n    @property\n    def x(self):\n        return self._point[0]\n    \n    @x.setter\n    def x(self, value):\n        self._point[0] = value\n\n    @property\n    def y(self):\n        return self._point[1]\n    \n    @y.setter\n    def y(self, value):\n        self._point[1] = value\n\n    @property\n    def z(self):\n        return self._point[2]\n    \n    @z.setter\n    def z(self, value):\n        self._point[2] = value\n\n    @property\n    def list(self):\n        return self._point.tolist()\n    \n\nclass Vector3D(object):\n    \"\"\"A class for a simple 3D vector\n    \n    Parameters\n    ----------\n    x : float\n    The x component of the vector\n    y : float\n    The y component of the vector\n    z : float\n    The z component of the vector\n    \n    Methods:\n    ----------\n    __repr__ : str\n    Returns a string representation of the vector\n    __add__ : Vector3D\n    Adds two vectors together\n    __sub__ : Vector3D\n    Subtracts two vectors\n    __mul__ : Vector3D\n    Finds the dot product of two vectors\n    __div__ : Vector3D\n    Finds the cross product of two vectors\n    __abs__ : float\n    Finds the magnitude of the vector\n    __neg__ : Vector3D\n    Finds the negative of the vector\n    __eq__ : bool\n    Checks if two vectors are equal\n    __ne__ : bool\n    Checks if two vectors are not equal\n    __getitem__ : float\n    Returns the x, y or z component of the vector\n    __setitem__ : float\n    Sets the x, y or z component of the vector\n    __iter__ : float\n    Returns an iterator over the vector\n    __len__ : int\n    Returns the length of the vector\n    __hash__ : int\n    Returns the hash of the vector\n    __copy__ : Vector3D\n    Returns a copy of the vector\n    __deepcopy__ : Vector3D\n    Returns a deep copy of the vector\n    copy : Vector3D\n    Returns a copy of the vector\n    dot : float\n    Finds the dot product of two vectors\n    cross : Vector3D\n    Finds the cross product of two vectors\n    norm : float\n    Finds the magnitude of the vector\n    normalize : Vector3D\n    Normalizes the vector\n    angle : float\n    Finds the angle between two vectors\n    rotate : Vector3D\n    Rotates the vector around an axis\n    rotate_x : Vector3D\n    Rotates the vector around the x axis\n    rotate_y : Vector3D\n    Rotates the vector around the y axis\n    rotate_z : Vector3D\n    Rotates the vector around the z axis\n\n    \"\"\"\n    def __init__(self, x, y, z):\n        self._vector = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        return f\"Vector3D(x={self.x}, y={self.y}, z={self.z})\"\n    \n    def __add__(self, other):\n        return Vector3D(self.x + other[0], self.y + other[1], self.z + other[2])\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __mul__(self, other):\n        if isinstance(other, (int, float)):\n            return Vector3D(self.x*other, self.y*other, self.z*other)\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def __div__(self, other):\n        # np.cross returns np ndarray but Vector3D expects x, y, z params\n        cp = np.cross(self._vector, other._vector)\n        return Vector3D(cp[0],cp[1],cp[2])\n    \n    def __abs__(self):\n        return np.linalg.norm(self._vector)\n    \n    def __neg__(self):\n        return Vector3D(-self.x, -self.y, -self.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._vector, other._vector)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._vector, other._vector)\n    \n    def __getitem__(self, key):\n        return self._vector[key]\n    \n    def __setitem__(self, key, value):\n        self._vector[key] = value\n\n    def __iter__(self):\n        return iter(self._vector)\n    \n    def __len__(self):\n        return len(self._vector)\n    \n    def __hash__(self):\n        return hash(self._vector.tostring())\n    \n    def __copy__(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def dot(self, other):\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def cross(self, other):\n        # Vector3D expects x, y, z\n        return Vector3D(np.cross(self._vector, other._vector))\n    \n    def norm(self):\n        return np.linalg.norm(self._vector)\n    \n    def normalize(self):\n        return Vector3D(self.x/self.norm(), self.y/self.norm(), self.z/self.norm())\n    \n    def angle(self, other):\n        return np.arccos(self.dot(other)/(self.norm()*other.norm()))\n    \n    def rotate(self, axis, angle):\n        axis = axis.normalize()\n        return Vector3D(self.x*np.cos(angle) + (1 - np.cos(angle))*axis.x*axis.x + np.sin(angle)*(axis.y*self.z - axis.z*self.y),\n                        self.y*np.cos(angle) + (1 - np.cos(angle))*axis.y*axis.y + np.sin(angle)*(axis.z*self.x - axis.x*self.z),\n                        self.z*np.cos(angle) + (1 - np.cos(angle))*axis.z*axis.z + np.sin(angle)*(axis.x*self.y - axis.y*self.x))\n    \n    def rotate_x(self, angle):\n        return Vector3D(self.x, self.y*np.cos(angle) - self.z*np.sin(angle), self.y*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_y(self, angle):\n        return Vector3D(self.x*np.cos(angle) + self.z*np.sin(angle), self.y, -self.x*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_z(self, angle):\n        return Vector3D(self.x*np.cos(angle) - self.y*np.sin(angle), self.x*np.sin(angle) + self.y*np.cos(angle), self.z)\n    \n    @property\n    def x(self):\n        return self._vector[0]\n    \n    @x.setter\n    def x(self, value):\n        self._vector[0] = value\n\n    @property\n    def y(self):\n        return self._vector[1]\n    \n    @y.setter\n    def y(self, value):\n        self._vector[1] = value\n\n    @property\n    def z(self):\n        return self._vector[2]\n    \n    @z.setter\n    def z(self, value):\n        self._vector[2] = value\n\n    def to_point(self)-> Point3D:\n        \"\"\"\n        Converts the vector to a Point3D\n        \"\"\"\n        return Point3D(self.x, self.y, self.z)\n\n\nclass Plane(object):\n    \"\"\"\n    A class for a simple plane\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    *args\n        Either a point and a normal vector, or three points defining the plane, np.array_like\n\n    Attributes\n    ----------\n    point : array_like\n        A point on the plane\n\n    normal : array_like\n        The normal vector of the plane\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the plane\n    __eq__ : bool\n        Checks if two planes are equal\n    intersectQ : bool\n        Checks if the plane intersects another plane or ray3d\n\n    \"\"\"\n\n    def __init__(self, *args):\n        if len(args) == 0:\n            print(\"No arguments given, plane at origin with normal (0, 0, 1) initialised! Tread carefully!\")\n            self._point = np.array([0, 0, 0])\n            self._normal = np.array([0, 0, 1])\n\n\n        if len(args) == 2:\n            self._point = args[0]\n            self._normal = args[1]\n\n        elif len(args) == 3:\n            v1 = args[2] - args[0]\n            v2 = args[1] - args[0]\n\n\n            self._normal = np.cross(v1, v2) / np.linalg.norm(np.cross(v1, v2))\n            self._point = args[0]\n\n        self.d = -self._normal.dot(self._point)\n\n    def __repr__(self):\n        #f-string\n        return \"Plane(point={}, normal={})\".format(self._point, self._normal)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other.point) and np.array_equal(self._normal, other.normal)\n    \n    @property\n    def point(self):\n        return self._point\n    \n    @point.setter\n    def point(self, value):\n        self._point = np.array(value)\n\n    @property\n    def position(self):\n        return self._point\n    \n    @position.setter\n    def position(self, value):\n        self._point = np.array(value)\n\n    @property\n    def normal(self):\n        return self._normal\n    \n    @normal.setter\n    def normal(self, value):\n        self._normal = np.array(value)\n            \n    # rename intersect_q\n    def intersectQ(self, other, atol=1e-6):\n        \"\"\"\n        Checks if the plane intersects another plane or ray3d\n\n        Parameters\n        ----------\n        other : Plane or Ray3D\n            The other plane or ray3d\n        atol : float\n            The absolute tolerance for the dot product of the normal vectors\n\n        Returns\n        ----------\n        bool\n            True if the plane intersects the other plane or ray3d, False otherwise\n        Point3D or None\n            The point of intersection if the plane intersects the other plane or ray3d, None otherwise\n        \"\"\"\n    \n        if isinstance(other, Plane):\n            return not np.isclose(self.normal.dot(other.normal), 1.0, atol=atol), None\n\n        elif isinstance(other, Ray3D):\n            if not np.isclose(self.normal.dot(other.vector), 0.0, atol=atol):\n                w = other.position - self.point\n                fac = -self.normal.dot(w) / self.normal.dot(other.vector)\n                plane_intersect = w + fac * other.vector + self.point\n                return True, plane_intersect\n            \n            else:\n                raise ValueError(\"The plane and ray are parallel\")    \n        # return type is different to return type from if and elif above\n        print('Not handled!')\n\n\n\n# Image class already defined\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\ndef calc_beam_size(electron_size: float,\n                   electron_div: float,\n                   wavelength: float,\n                   distance: float,\n                   length: float,\n                   num_of_sigmas=3,\n                   insertion_device='undulator') -> float:\n    \"\"\"\n    Calculate the beam size based on the electron size and divergence.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n    electron_div : float\n        The electron divergence in urad\n    wavelength not photon_energy in params\n    photon_energy : float\n        The photon energy in eV\n    distance : float\n        The distance from the source to the image plane in m\n    length : float\n        The length of the insertion device in m\n    num_of_sigmas : int\n        The number of sigmas to use when calculating the beam size\n    insertion_device : str\n        The type of insertion device, can be 'undulator' or 'wiggler', default is 'undulator'\n    \n    Returns\n    ----------\n    float\n        The RMS photon beam size at distance in mm\n\n    \"\"\"\n    if insertion_device == 'undulator':\n        source_size = calc_source_size(electron_size, wavelength, length)\n        source_div = calc_source_div(electron_div, wavelength, length)\n        return np.sqrt(source_size**2 + (source_div*distance)**2)*1e3*num_of_sigmas\n    else:\n        raise NotImplementedError(\"Only undulator is currently supported\")\n        \n\n\ndef calc_source_size(electron_size: float, wavelength:float, length:float)-> float:\n    \"\"\"\n    Calculates the source size based on provided parameters.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source size in m\n    \"\"\"\n    return np.sqrt((electron_size*1e-6)**2 + (wavelength*1e-9*length/(2*np.pi**2)))\n\ndef calc_source_div(electron_div: float, wavelength: float, length: float)-> float:\n    \"\"\"\n    Calculates the source divergence based on provided parameters.\n\n    Parameters\n    ----------\n    electron_div : float\n        The electron divergence in urad\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source divergence in rad\n    \"\"\"\n    return np.sqrt((electron_div*1e-6)**2 + (wavelength*1e-9/(2*length)))", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\PKG-INFO", "content": "Metadata-Version: 2.1\nName: pyplanemono_minimal\nVersion: 1.0\nSummary: X-ray tracing for plane grating monochromator. Minimal version with no interface to SHADOW.\nAuthor-email: Patrick Wang <patrick.wang@diamond.ac.uk>\nClassifier: Programming Language :: Python :: 3\nClassifier: License :: OSI Approved :: MIT License\nClassifier: Operating System :: OS Independent\nRequires-Python: >=3.8.0\nDescription-Content-Type: text/markdown\nLicense-File: LICENSE\nRequires-Dist: numpy>=1.23.0\nRequires-Dist: scipy>=1.8.1\nRequires-Dist: matplotlib>=3.5.2\n\n# pyplanemono-minimal\n\nThis is a minimised version of the PyPlaneMono project, which is a calculation suite for the geometry of the plane grating monochromator. This repository contains only only the core calculation and visualisation functionalities and no GUI components\nand is not capable of interacting with SHADOW as a pre-processor. For full functionality, refer to pyplanemono. This is meant to be distributed with the online interface of the PyPlaneMono project with maximum portability.\n\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\SOURCES.txt", "content": "LICENSE\nREADME.md\npyproject.toml\npyplanemono_minimal/__init__.py\npyplanemono_minimal.egg-info/PKG-INFO\npyplanemono_minimal.egg-info/SOURCES.txt\npyplanemono_minimal.egg-info/dependency_links.txt\npyplanemono_minimal.egg-info/requires.txt\npyplanemono_minimal.egg-info/top_level.txt\npyplanemono_minimal/elements/__init__.py\npyplanemono_minimal/elements/grating.py\npyplanemono_minimal/elements/mirror.py\npyplanemono_minimal/elements/pgm.py\npyplanemono_minimal/geometry/__init__.py\npyplanemono_minimal/geometry/geometry.py", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\dependency_links.txt", "content": "\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\requires.txt", "content": "numpy>=1.23.0\nscipy>=1.8.1\nmatplotlib>=3.5.2\n", "type": "text"}, {"name": "pyplanemono_minimal\\pyplanemono_minimal.egg-info\\top_level.txt", "content": "pyplanemono_minimal\n", "type": "text"}, {"name": "pyplanemono_minimal\\geometry\\__init__.py", "content": "from .geometry import *\n#from .light import *", "type": "text"}, {"name": "pyplanemono_minimal\\geometry\\geometry.py", "content": "\"\"\"\nA module containing classes for simple 3D geometry\nused in ray tracing of X-ray optics.\n\nAuthor: Patrick Wang\nEmail: patrick.wang@diamond.ac.uk\n\nVersion: 0.2.2\nDate: 2023-09-15\n\n\"\"\"\nfrom __future__ import division, print_function\nimport numpy as np\n\nclass Ray3D(object):\n    \"\"\"\n    A class for a simple 3D ray\n\n    Parameters\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n    \n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the ray\n\n    Attributes\n    ----------\n    position : Point3D\n        The position of the ray\n    vector : Vector3D\n        The vector of the ray\n\n    \"\"\"\n    def __init__(self, position, vector):\n        self._position = position\n        vector_mag = np.linalg.norm(vector)\n        if vector_mag == 0:\n            raise ValueError(\"Vector magnitude cannot be zero\")\n        self._vector = vector / vector_mag\n\n    def __repr__(self):\n        # use f-string\n        return f\"Ray3D(position={self.position}, vector={self.vector})\"\n    @property\n    def position(self):\n        return self._position\n    \n    @position.setter\n    def position(self, value):\n        self._position = value\n    \n    @property\n    def vector(self):\n        return self._vector\n    \n    @vector.setter\n    def vector(self, value):\n        self._vector = value / np.linalg.norm(value)\n\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\n\n\nclass Point3D(object):\n    \"\"\"\n    A class for a simple 3D point.\n\n    Parameters\n    ----------\n    x : float\n        The x coordinate of the point\n    y : float\n        The y coordinate of the point\n    z : float\n        The z coordinate of the point\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the point\n    __add__ : Point3D\n        Adds two points together\n    __sub__ : Point3D\n        Subtracts two points\n    __eq__ : bool\n        Checks if two points are equal\n    __ne__ : bool\n        Checks if two points are not equal\n    __getitem__ : float\n        Returns the x, y or z coordinate of the point\n    __setitem__ : float\n        Sets the x, y or z coordinate of the point\n    __iter__ : float\n        Returns an iterator over the point\n    __len__ : int\n        Returns the length of the point\n    __hash__ : int \n        Returns the hash of the point\n    __copy__ : Point3D\n        Returns a copy of the point\n    __deepcopy__ : Point3D\n        Returns a deep copy of the point\n    copy : Point3D\n        Returns a copy of the point\n    distance : float\n        Finds the distance between two points\n    \"\"\"\n\n    def __init__(self, x, y, z):\n        self._point = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        # f-string\n        return \"Point3D(x={}, y={}, z={})\".format(self.x, self.y, self.z)\n    \n    def __add__(self, other):\n        return Point3D(self.x + other.x, self.y + other.y, self.z + other.z)\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other._point)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._point, other._point)\n    \n    def __getitem__(self, key):\n        return self._point[key] \n    \n    def __setitem__(self, key, value):\n        self._point[key] = value\n\n    def __iter__(self):\n        return iter(self._point)    \n\n    def __len__(self):\n        return len(self._point)\n    \n    def __hash__(self):\n        return hash(self._point.tostring())\n    \n    def __copy__(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Point3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Point3D(self.x, self.y, self.z)\n    \n    def distance(self, other):\n        # use point property rather than accessing other._point\n        return np.linalg.norm(self._point - other._point)\n    \n    @property\n    def x(self):\n        return self._point[0]\n    \n    @x.setter\n    def x(self, value):\n        self._point[0] = value\n\n    @property\n    def y(self):\n        return self._point[1]\n    \n    @y.setter\n    def y(self, value):\n        self._point[1] = value\n\n    @property\n    def z(self):\n        return self._point[2]\n    \n    @z.setter\n    def z(self, value):\n        self._point[2] = value\n\n    @property\n    def list(self):\n        return self._point.tolist()\n    \n\nclass Vector3D(object):\n    \"\"\"A class for a simple 3D vector\n    \n    Parameters\n    ----------\n    x : float\n    The x component of the vector\n    y : float\n    The y component of the vector\n    z : float\n    The z component of the vector\n    \n    Methods:\n    ----------\n    __repr__ : str\n    Returns a string representation of the vector\n    __add__ : Vector3D\n    Adds two vectors together\n    __sub__ : Vector3D\n    Subtracts two vectors\n    __mul__ : Vector3D\n    Finds the dot product of two vectors\n    __div__ : Vector3D\n    Finds the cross product of two vectors\n    __abs__ : float\n    Finds the magnitude of the vector\n    __neg__ : Vector3D\n    Finds the negative of the vector\n    __eq__ : bool\n    Checks if two vectors are equal\n    __ne__ : bool\n    Checks if two vectors are not equal\n    __getitem__ : float\n    Returns the x, y or z component of the vector\n    __setitem__ : float\n    Sets the x, y or z component of the vector\n    __iter__ : float\n    Returns an iterator over the vector\n    __len__ : int\n    Returns the length of the vector\n    __hash__ : int\n    Returns the hash of the vector\n    __copy__ : Vector3D\n    Returns a copy of the vector\n    __deepcopy__ : Vector3D\n    Returns a deep copy of the vector\n    copy : Vector3D\n    Returns a copy of the vector\n    dot : float\n    Finds the dot product of two vectors\n    cross : Vector3D\n    Finds the cross product of two vectors\n    norm : float\n    Finds the magnitude of the vector\n    normalize : Vector3D\n    Normalizes the vector\n    angle : float\n    Finds the angle between two vectors\n    rotate : Vector3D\n    Rotates the vector around an axis\n    rotate_x : Vector3D\n    Rotates the vector around the x axis\n    rotate_y : Vector3D\n    Rotates the vector around the y axis\n    rotate_z : Vector3D\n    Rotates the vector around the z axis\n\n    \"\"\"\n    def __init__(self, x, y, z):\n        self._vector = np.array([x, y, z], dtype=float)\n\n    def __repr__(self):\n        return f\"Vector3D(x={self.x}, y={self.y}, z={self.z})\"\n    \n    def __add__(self, other):\n        return Vector3D(self.x + other[0], self.y + other[1], self.z + other[2])\n    \n    def __sub__(self, other):\n        return Vector3D(self.x - other.x, self.y - other.y, self.z - other.z)\n    \n    def __mul__(self, other):\n        if isinstance(other, (int, float)):\n            return Vector3D(self.x*other, self.y*other, self.z*other)\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def __div__(self, other):\n        # np.cross returns np ndarray but Vector3D expects x, y, z params\n        cp = np.cross(self._vector, other._vector)\n        return Vector3D(cp[0],cp[1],cp[2])\n    \n    def __abs__(self):\n        return np.linalg.norm(self._vector)\n    \n    def __neg__(self):\n        return Vector3D(-self.x, -self.y, -self.z)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._vector, other._vector)\n    \n    def __ne__(self, other):\n        return not np.array_equal(self._vector, other._vector)\n    \n    def __getitem__(self, key):\n        return self._vector[key]\n    \n    def __setitem__(self, key, value):\n        self._vector[key] = value\n\n    def __iter__(self):\n        return iter(self._vector)\n    \n    def __len__(self):\n        return len(self._vector)\n    \n    def __hash__(self):\n        return hash(self._vector.tostring())\n    \n    def __copy__(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def __deepcopy__(self, memo):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def copy(self):\n        return Vector3D(self.x, self.y, self.z)\n    \n    def dot(self, other):\n        return self.x*other.x + self.y*other.y + self.z*other.z\n    \n    def cross(self, other):\n        # Vector3D expects x, y, z\n        return Vector3D(np.cross(self._vector, other._vector))\n    \n    def norm(self):\n        return np.linalg.norm(self._vector)\n    \n    def normalize(self):\n        return Vector3D(self.x/self.norm(), self.y/self.norm(), self.z/self.norm())\n    \n    def angle(self, other):\n        return np.arccos(self.dot(other)/(self.norm()*other.norm()))\n    \n    def rotate(self, axis, angle):\n        axis = axis.normalize()\n        return Vector3D(self.x*np.cos(angle) + (1 - np.cos(angle))*axis.x*axis.x + np.sin(angle)*(axis.y*self.z - axis.z*self.y),\n                        self.y*np.cos(angle) + (1 - np.cos(angle))*axis.y*axis.y + np.sin(angle)*(axis.z*self.x - axis.x*self.z),\n                        self.z*np.cos(angle) + (1 - np.cos(angle))*axis.z*axis.z + np.sin(angle)*(axis.x*self.y - axis.y*self.x))\n    \n    def rotate_x(self, angle):\n        return Vector3D(self.x, self.y*np.cos(angle) - self.z*np.sin(angle), self.y*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_y(self, angle):\n        return Vector3D(self.x*np.cos(angle) + self.z*np.sin(angle), self.y, -self.x*np.sin(angle) + self.z*np.cos(angle))\n    \n    def rotate_z(self, angle):\n        return Vector3D(self.x*np.cos(angle) - self.y*np.sin(angle), self.x*np.sin(angle) + self.y*np.cos(angle), self.z)\n    \n    @property\n    def x(self):\n        return self._vector[0]\n    \n    @x.setter\n    def x(self, value):\n        self._vector[0] = value\n\n    @property\n    def y(self):\n        return self._vector[1]\n    \n    @y.setter\n    def y(self, value):\n        self._vector[1] = value\n\n    @property\n    def z(self):\n        return self._vector[2]\n    \n    @z.setter\n    def z(self, value):\n        self._vector[2] = value\n\n    def to_point(self)-> Point3D:\n        \"\"\"\n        Converts the vector to a Point3D\n        \"\"\"\n        return Point3D(self.x, self.y, self.z)\n\n\nclass Plane(object):\n    \"\"\"\n    A class for a simple plane\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    *args\n        Either a point and a normal vector, or three points defining the plane, np.array_like\n\n    Attributes\n    ----------\n    point : array_like\n        A point on the plane\n\n    normal : array_like\n        The normal vector of the plane\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the plane\n    __eq__ : bool\n        Checks if two planes are equal\n    intersectQ : bool\n        Checks if the plane intersects another plane or ray3d\n\n    \"\"\"\n\n    def __init__(self, *args):\n        if len(args) == 0:\n            print(\"No arguments given, plane at origin with normal (0, 0, 1) initialised! Tread carefully!\")\n            self._point = np.array([0, 0, 0])\n            self._normal = np.array([0, 0, 1])\n\n\n        if len(args) == 2:\n            self._point = args[0]\n            self._normal = args[1]\n\n        elif len(args) == 3:\n            v1 = args[2] - args[0]\n            v2 = args[1] - args[0]\n\n\n            self._normal = np.cross(v1, v2) / np.linalg.norm(np.cross(v1, v2))\n            self._point = args[0]\n\n        self.d = -self._normal.dot(self._point)\n\n    def __repr__(self):\n        #f-string\n        return \"Plane(point={}, normal={})\".format(self._point, self._normal)\n    \n    def __eq__(self, other):\n        return np.array_equal(self._point, other.point) and np.array_equal(self._normal, other.normal)\n    \n    @property\n    def point(self):\n        return self._point\n    \n    @point.setter\n    def point(self, value):\n        self._point = np.array(value)\n\n    @property\n    def position(self):\n        return self._point\n    \n    @position.setter\n    def position(self, value):\n        self._point = np.array(value)\n\n    @property\n    def normal(self):\n        return self._normal\n    \n    @normal.setter\n    def normal(self, value):\n        self._normal = np.array(value)\n            \n    # rename intersect_q\n    def intersectQ(self, other, atol=1e-6):\n        \"\"\"\n        Checks if the plane intersects another plane or ray3d\n\n        Parameters\n        ----------\n        other : Plane or Ray3D\n            The other plane or ray3d\n        atol : float\n            The absolute tolerance for the dot product of the normal vectors\n\n        Returns\n        ----------\n        bool\n            True if the plane intersects the other plane or ray3d, False otherwise\n        Point3D or None\n            The point of intersection if the plane intersects the other plane or ray3d, None otherwise\n        \"\"\"\n    \n        if isinstance(other, Plane):\n            return not np.isclose(self.normal.dot(other.normal), 1.0, atol=atol), None\n\n        elif isinstance(other, Ray3D):\n            if not np.isclose(self.normal.dot(other.vector), 0.0, atol=atol):\n                w = other.position - self.point\n                fac = -self.normal.dot(w) / self.normal.dot(other.vector)\n                plane_intersect = w + fac * other.vector + self.point\n                return True, plane_intersect\n            \n            else:\n                raise ValueError(\"The plane and ray are parallel\")    \n        # return type is different to return type from if and elif above\n        print('Not handled!')\n\n\n\n# Image class already defined\nclass Image(object):\n    \"\"\"\n    A class for a 2D image.\n\n    Parameters\n    ----------\n    width : float\n        The width of the image\n    height : float\n        The height of the image\n    h_div : int\n        The number of horizontal divisions\n    v_div : int\n        The number of vertical divisions\n\n    Methods\n    ----------\n    __repr__ : str\n        Returns a string representation of the image\n\n    \"\"\"\n    def __init__(self, width, height, h_div, v_div):\n        self.width = width\n        self.height = height\n        self.h_div = h_div\n        self.v_div = v_div\n    \n    def __repr__(self):\n        return \"Image(width={}, height={}, h_div={}, v_div={})\".format(self.width, self.height, self.h_div, self.v_div)\n\ndef calc_beam_size(electron_size: float,\n                   electron_div: float,\n                   wavelength: float,\n                   distance: float,\n                   length: float,\n                   num_of_sigmas=3,\n                   insertion_device='undulator') -> float:\n    \"\"\"\n    Calculate the beam size based on the electron size and divergence.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n    electron_div : float\n        The electron divergence in urad\n    wavelength not photon_energy in params\n    photon_energy : float\n        The photon energy in eV\n    distance : float\n        The distance from the source to the image plane in m\n    length : float\n        The length of the insertion device in m\n    num_of_sigmas : int\n        The number of sigmas to use when calculating the beam size\n    insertion_device : str\n        The type of insertion device, can be 'undulator' or 'wiggler', default is 'undulator'\n    \n    Returns\n    ----------\n    float\n        The RMS photon beam size at distance in mm\n\n    \"\"\"\n    if insertion_device == 'undulator':\n        source_size = calc_source_size(electron_size, wavelength, length)\n        source_div = calc_source_div(electron_div, wavelength, length)\n        return np.sqrt(source_size**2 + (source_div*distance)**2)*1e3*num_of_sigmas\n    else:\n        raise NotImplementedError(\"Only undulator is currently supported\")\n        \n\n\ndef calc_source_size(electron_size: float, wavelength:float, length:float)-> float:\n    \"\"\"\n    Calculates the source size based on provided parameters.\n\n    Parameters\n    ----------\n    electron_size : float\n        The electron size in um\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source size in m\n    \"\"\"\n    return np.sqrt((electron_size*1e-6)**2 + (wavelength*1e-9*length/(2*np.pi**2)))\n\ndef calc_source_div(electron_div: float, wavelength: float, length: float)-> float:\n    \"\"\"\n    Calculates the source divergence based on provided parameters.\n\n    Parameters\n    ----------\n    electron_div : float\n        The electron divergence in urad\n\n    wavelength : float\n        The wavelength in nm\n    \n    length : float\n        The length of the insertion device in m\n    \n    Returns\n    ----------\n    float\n        The RMS source divergence in rad\n    \"\"\"\n    return np.sqrt((electron_div*1e-6)**2 + (wavelength*1e-9/(2*length)))", "type": "text"}, {"name": "pyplanemono_minimal\\dist\\pyplanemono_minimal-1.0-py3-none-any.whl", "content": "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", "type": "binary"}, {"name": "pyplanemono_minimal\\dist\\pyplanemono_minimal-1.0.tar.gz", "content": "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", "type": "binary"}, {"name": "pyplanemono_minimal\\elements\\__init__.py", "content": "from .mirror import *\nfrom .grating import *\nfrom .pgm import *", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\grating.py", "content": "from __future__ import annotations\nimport numpy as np\nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Plane, Ray3D\nfrom scipy.constants import c, h, e\n\n\nclass Grating(object):\n    \"\"\"\n    A class for a simple grating\n\n    Based on the work of Matthew Hand\n\n    Parameters\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    dimensions : array_like\n        The dimensions of the grating in mm [length, width, height],\n        dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    \n    Attributes\n    ----------\n    line_density : float\n        The line density of the grating in lines per mm\n    energy : float\n        The energy of the incident beam in eV\n    cff : float\n        The fixed focus constant of the grating\n    order : int\n        The diffraction order of the grating\n    alpha : float\n        The incident angle of the beam in degrees\n    beta : float    \n        The diffraction angle of the beam in degrees\n    dimensions : array_like\n        The dimensions of the grating in mm\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Grating Plane      Right\n        |                          |      ----> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n\n        Left - Right => Tangential\n        Top - Bottom => Sagittal\n    Methods\n    -------\n    set_angles(alpha, beta)\n        Set the incident and diffraction angles of the grating\n    energy_to_wavelength()\n        Calculate the wavelength of the beam in Angstroms\n    compute_corners()\n        Compute the corners of the grating in the global coordinate system\n    diffract(*args)\n        A method to diffract rays off the grating\n    compute_beta(alpha, line_density, energy, order)\n        Calculate the diffraction angle beta from the incident angle alpha\n    reflect(*args)\n        A method to 'reflect' rays off the grating\n    \"\"\"\n    # Run a code formatter and linter to fix code style adn syntax errors. Black & Falke8 are good for this.\n    def __init__(self, \n                 line_density=600, \n                 energy=2400, \n                 cff=2, \n                 order=1, \n                 dimensions = np.array([200,40,50]), \n                 borders = np.array([0,0,0,0])):\n\n        self._line_density=line_density\n        self._energy=energy\n        self._cff=cff\n        self._order=order\n        self._alpha = None\n        self._beta = None\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._borders = borders\n        _,_ = self.compute_angles()\n        _ = self.compute_corners()\n\n\n\n    def __repr__(self):\n        # Use f-strings\n        return f\"Grating(line_density={self.line_density},\\n energy={self.energy}, \\n cff={self.cff}, \\n order={self.order}, \\n dimensions={self.dimensions},\\n borders={self.borders})\"\n    \n    def read_file(self, filename):\n        \"\"\"\n        Read grating parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['grating']) != 6:\n            # You could add config['grating'] into the error message\n            raise ValueError(\"Expected exactly five parameters in grating file\")\n\n        # Could use tuple instead of list\n        variables = ('line_density', 'energy', 'cff', 'order', 'dimensions')\n        for var in variables:\n            if var not in config['grating']:\n                raise ValueError(\"Missing parameter {} in grating file\".format(var))\n            \n        # You already check if variables in config['grating'] above and repeat below.\n        # Could use sets to create items from variable and config['grating'] to avoid list comprehension.\n        items = [x for x in variables if x in config['grating'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['grating'].values()):\n            setattr(self, key, value)\n            print(key)\n            print(value)\n        \n        self._order = int(self._order)\n        self._dimensions = np.array([float(x) for x in config['grating']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['grating']['borders'].split(',')])\n\n    @property\n    def line_density(self)-> float:\n        return self._line_density\n    \n    @line_density.setter\n    def line_density(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive line density\")\n        else:\n            self._line_density = value\n\n    @property\n    def energy(self)-> float:\n        return self._energy\n    \n    @energy.setter\n    def energy(self, value: float)-> None:\n        if value <= 0:\n            raise ValueError(\"Expected positive energy\")\n        else:\n            self._energy = value\n        \n    @property\n    def cff(self)-> float:\n        return self._cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if value <= 1:\n            raise ValueError(\"Expected positive cff\")\n        else:\n            self._cff = value\n    \n    @property\n    def order(self)-> int:\n        return int(self._order)\n    \n    @order.setter\n    def order(self, value: int)-> None:\n        if value >= 1 and isinstance(value, int):\n            self._order = value\n            print(\"order set!\")\n        else:\n            raise ValueError(\"Expected positive integer order\")\n\n    @property\n    def alpha(self)-> float:   \n        return self._alpha\n    \n    @alpha.setter\n    def alpha(self, value)-> None:\n        if np.abs(value) <= 180 and isinstance(value, (float, int)):\n            self._alpha = value\n        else:\n            raise ValueError(\"Expected float alpha with magnitude less than 180 degrees\")\n\n    @property\n    def beta(self)-> float:\n        return self._beta\n    \n    @beta.setter\n    def beta(self, value: float)-> None:\n        self._beta = value\n    \n    @property\n    def dimensions(self):\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value):\n        if len(value) != 3:\n            raise ValueError(\"Expected exactly three values for dimensions\")\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._grating_plane\n    \n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._grating_plane = value\n        else:\n            raise TypeError(\"Expected Plane object for plane\")\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value: np.ndarray)-> None:\n        if len(value) != 4 or not isinstance(value, np.ndarray):\n            raise ValueError(\"Expected exactly 1D array of length 4 for borders\")\n        else:\n            self._borders = value\n\n\n    def set_angles(self, alpha: float, beta: float)-> None:\n        \"\"\"\n        Set the incident and diffraction angles of the grating.\n\n        Parameters\n        ----------\n        alpha : float\n            The incident angle in degrees\n        beta : float \n            The diffraction angle in degrees\n\n        Raises\n        ------\n        ValueError\n            If the wavelength is zero\n\n        \"\"\"\n        wavelength = (np.sin(np.deg2rad(alpha)) + np.sin(np.deg2rad(beta))) / (self.line_density*1000*self._order)\n        \n        if wavelength <= 0:\n            raise ValueError(\"Expected positive, non-zero wavelength\")\n\n        else:\n            self._energy = 12398.42 / wavelength #converts wavelength to eV\n        \n        self._alpha = alpha\n        self._beta = beta\n        self._cff = self.cff\n\n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value:any)-> None:\n        print(\"Input ignored, corners are computed from dimensions\")\n        self._corners = self.compute_corners()\n\n    def compute_beta(self)-> float:\n        \"\"\"\n        Compute the diffraction angle beta from the incident angle alpha.\n\n        Returns\n        -------\n        beta : float\n            The diffraction angle in degrees\n        \n    \n        \"\"\"\n        beta = 0\n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        u = self.order*self.line_density*1000*wavelength - np.sin(np.deg2rad(self.alpha))\n        beta = np.rad2deg(np.arcsin(u))\n        \n        \n        return beta\n\n    def compute_angles(self)-> tuple[float, float]:\n        \"\"\"\n        Compute the incident and diffraction angles of the grating.\n        The incident angle is calculated from the diffraction angle\n        using the fixed focus constant.\n\n        Returns\n        -------\n        alpha : float\n            The incident angle in degrees\n\n        beta : float\n            The diffraction angle in degrees\n        \n        \"\"\"\n        \n        \n        wavelength = self.energy_to_wavelength(self.energy)\n        print(self.energy,\n              self.order,\n                self.line_density,\n                self.cff,\n               wavelength)\n        \n        lambda_u = self.order*self.line_density*1000*wavelength/(1-self.cff**2)\n        sin_alpha = lambda_u + np.sqrt(1+lambda_u**2*self.cff**2)\n        self._alpha = np.rad2deg(np.arcsin(sin_alpha))\n        self._beta = -np.rad2deg(np.arccos(np.cos(np.arcsin(sin_alpha))*self.cff))\n\n        return self._alpha, self._beta\n\n    # Could add type annotations on all your functions\n    def diffract(self, *args: Ray3D | list )-> list:\n        \"\"\"\n        A method to diffract rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be diffracted\n\n        Returns\n        -------\n        diffracted_rays : list of Ray3D\n            A list of diffracted rays\n\n        Raises\n        ------\n        raises ValueError too\n        TypeError\n            If the rays are not Ray3D objects\n\n        \"\"\"\n        diffracted_rays = []\n        \n\n        if isinstance(args[0], list):\n            args = args[0]\n\n        elif len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n\n        for _, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            raydotplane = ray.vector.dot(self._grating_plane.normal)\n            angle = np.arccos(raydotplane/np.linalg.norm(self._grating_plane.normal))\n            alpha = np.rad2deg(np.pi/2-angle)\n            beta = self.compute_beta()\n            diff_ray = self.reflect(ray)[0]\n            angle = -90 - beta - alpha\n            diff_ray.vector[2] += np.cos(np.deg2rad(angle))\n            diff_ray.vector[1] += np.sin(np.deg2rad(angle))\n            diff_ray.vector = diff_ray.vector/np.linalg.norm(diff_ray.vector)\n            diffracted_rays.append(diff_ray)\n        return diffracted_rays\n    \n    \n\n    # rename something like energy_to_wavelength\n    def energy_to_wavelength(self, energy: float)-> float:\n        return h*c/(e*energy)\n    \n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the grating in the global coordinate system.\n\n        Returns\n        -------\n        corners : array_like\n            The corners of the grating in the global coordinate system:\n            [bottom left back, \n            bottom right back, \n            bottom left front, \n            bottom right front,\n            top left back,\n            top right back,\n            top left front,\n            top right front]\n        \"\"\"\n        \n        beta = np.deg2rad(self._beta)\n        # beta_g not used\n        beta_g = np.deg2rad(self._beta + 90)\n        l = self._length()\n        w = self._width()\n        d = self._height()        \n        #Bottom left back\n        blbz = (l/2)*np.sin(beta)\n        blby = -(l/2)*np.cos(beta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        #Bottom left front\n        blfz = -(l/2)*np.sin(beta)\n        blfy = (l/2)*np.cos(beta)\n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = blbz - d*np.cos(beta)\n        tlby = blby - d*np.sin(beta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Top right back\n        trbz = brbz - d*np.cos(beta)\n        trby = brby - d*np.sin(beta)\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Top left front\n        tlfz = blfz - d*np.cos(beta)\n        tlfy = blfy - d*np.sin(beta)\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Top right front\n        trfz = brfz - d*np.cos(beta)\n        trfy = brfy - d*np.sin(beta)\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        self._grating_plane = Plane(\n            Point3D(blfx, blfy, blfz),\n            Point3D(brfx, brfy, brfz),\n            Point3D(blbx, blby, blbz)\n        )\n\n        self._corners = np.array([\n            blb,\n            brb,\n            blf,\n            brf,\n            tlb,\n            trb,\n            tlf,\n            trf\n        ])\n\n        return self._corners\n\n    def reflect(self, *args, zero_order = False)-> list:\n        \"\"\"\n        A method to reflect rays off the grating.\n\n        Parameters\n        ----------\n        *args : Ray3D or list of Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        # Check after determining if list\n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        # se isinstance\n        if type(args[0]) == list:\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._grating_plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect grating, tread with caution!')\n                continue\n            ray_array = ray.vector\n            grating_normal = self._grating_plane.normal\n            if zero_order:\n                \n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, -grating_normal) * grating_normal\n            else:\n                reflected_ray_array = ray_array - 2 * np.dot(ray_array, grating_normal) * grating_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n\n    @classmethod\n    def grating_from_file(cls, filename):\n        \"\"\"\n        Create a grating from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        grating section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        grating = cls()\n        grating.read_file(filename)\n        return grating\n    \n", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\mirror.py", "content": "from __future__ import annotations\n# List not used\nfrom ast import List\nfrom matplotlib.pyplot import isinteractive\nimport numpy as np\nfrom pyplanemono_minimal.geometry import Point3D, Vector3D, Plane, Ray3D\nimport configparser\n\nclass Plane_Mirror(object):\n    \"\"\"\n    A class for a simple plane mirror.\n\n    Parameters\n    ----------\n    voffset : float, optional\n        The vertical offset of the mirror in mm\n    hoffset : float, optional\n        The horizontal offset of the mirror in mm\n    axis_voffset : float, optional\n        The vertical offset of the mirror axis in mm\n    axis_hoffset : float, optional\n        The horizontal offset of the mirror axis in mm\n    dimensions : array_like, optional\n        The dimensions of the mirror in mm [length, width, height]\n        Dimensions are also accessible with lambda functions as:\n        self._length(), self._width(), self._height()\n    theta : float, optional\n        The angle of the mirror in degrees\n    plane : Plane, optional\n        The plane of the mirror\n    borders: array_like, optional\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    \n\n    Attributes\n    ----------\n    dimensions : array_like\n        The dimensions of the mirror in mm\n    position : Point3D\n        The position of the mirror\n    normal : Vector3D\n        The normal vector of the mirror\n    orientation : Vector3D\n        The orientation of the mirror\n    corners : array_like\n        The corners of the grating in the global coordinate system:\n        [bottom left back, \n        bottom right back, \n        bottom left front, \n        bottom right front,\n        top left back,\n        top right back,\n        top left front,\n        top right front]\n    plane : Plane\n        The plane of the mirror\n    \n    borders: array_like\n        Specifies the borders for a realistic plane mirror:\n        borders : array_like\n        Specifies the borders of a realistic grating component.\n        |-----------Top------------|\n        |                          |\n       Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|        \n        [top, bottom, left, right]\n    Methods\n    -------\n    set_position(position)\n        Set the position of the mirror\n    set_normal(normal)\n        Set the normal vector of the mirror\n    set_orientation(orientation)\n        Set the orientation of the mirror\n    set_dimensions(*args)\n        Set the dimensions of the mirror\n    set_offsets(voffset, hoffset, axis_voffset, axis_hoffset)\n        Set the offsets of the mirror\n    compute_corners()\n        Compute the corners of the mirror in the global coordinate system,  \n    \n    \n    \"\"\"\n\n    def __init__(self, \n                 voffset=13, \n                 hoffset=40, \n                 axis_voffset=6.5, \n                 axis_hoffset=0, \n                 dimensions = np.array([450, 70, 50]),\n                 theta=45, \n                 plane=Plane(),\n                 borders = np.array([0,0,0,0])\n                 ):\n        \"\"\"\n        Constructor for the Plane_Mirror class.\n\n        Parameters\n        ----------\n        voffset : float\n            The vertical offset of the mirror in mm\n        hoffset : float\n            The horizontal offset of the mirror in mm\n        axis_voffset : float\n            The vertical offset of the mirror axis in mm\n        axis_hoffset : float\n            The horizontal offset of the mirror axis in mm\n        dimensions : array_like\n            The dimensions of the mirror in mm [length, width, height]\n            Dimensions are also accessible with lambda functions as:\n            self._length(), self._width(), self._height()\n\n        \n        theta : float\n            The angle of the mirror in degrees\n        plane : Plane\n            The plane of the mirror\n        \n        \"\"\"\n\n        self._voffset = voffset\n        self._hoffset = hoffset\n        self._axis_voffset = axis_voffset\n        self._axis_hoffset = axis_hoffset\n        self._dimensions = dimensions\n        self._length = lambda: self._dimensions[0]\n        self._width = lambda: self._dimensions[1]\n        self._height = lambda: self._dimensions[2]\n        self._plane = plane\n        self._theta = theta\n        # Just call method without assigning to _\n        _ = self.compute_corners()\n        self._borders = borders\n\n\n    def __repr__(self):\n        # Use f-string\n        return \"\"\"Plane_Mirror(voffset={}, \n        hoffset={}, \n        axis_voffset={}, \n        axis_hoffset={}, \n        length={}, \n        width={}, \n        height={}, \n        plane={},\n        borders={})\n        \"\"\".format(self.voffset,\n                            self.hoffset, \n                            self.axis_voffset, \n                            self.axis_hoffset, \n                            self._length(), \n                            self._width(), \n                            self._height(), \n                            self.plane,\n                            self.borders)\n    \n\n    # read_file is very similar to read_file in grating.py. Refactor to use common code.\n    def read_file(self, filename):\n        \"\"\"\n        Read mirror parameters from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        config = configparser.ConfigParser()\n        config.read(filename)\n        \n        if len(config['mirror']) != 7:\n            raise ValueError(\"Expected exactly six parameters in mirror file\")\n\n        variables = ['voffset', 'hoffset', 'axis_voffset', 'axis_hoffset', 'dimensions', 'theta']\n        for var in variables:\n            if var not in config['mirror']:\n                raise ValueError(\"Missing parameter {} in mirror file\".format(var))\n        \n        items = [x for x in variables if x in config['mirror'] and x != 'dimensions' and x != 'borders']\n\n        for key, value in zip(items, config['mirror'].values()):\n            # Don't use exec. Either explicitly assign variables or if you will not know what they will be, use a dictionary not variables.\n            exec(f\"self._{key} = float({value})\")\n            print(key)\n            print(value)\n        \n        \n        self._dimensions = np.array([float(x) for x in config['mirror']['dimensions'].split(',')])\n        self._borders= np.array([float(x) for x in config['mirror']['borders'].split(',')])\n        \n\n    @property\n    def voffset(self)-> float:\n\n        return self._voffset\n\n    @voffset.setter\n    def voffset(self, value: float)-> None:\n        if isinstance(value, float):\n            self._voffset = value  \n        else:\n            raise TypeError(\"Expected voffset to be float!\")\n    @property\n    def a(self)-> float:\n        return self._hoffset\n    \n    @a.setter\n    def a(self, value: float)-> None:\n        self.hoffset = float(value)\n\n    @property\n    def hoffset(self)-> float:\n        return self._hoffset\n\n    @hoffset.setter\n    def hoffset(self, value: float):\n        if isinstance(value, float):\n            self._hoffset = value\n        else:\n            raise TypeError(\"Expected hoffset to be float!\")\n\n    @property\n    def c(self)-> float:\n        return self._voffset\n    \n    @c.setter\n    def c(self, value: float)-> None:\n        self.voffset = float(value)\n\n    \n\n    @property\n    def axis_voffset(self)-> float:\n        return self._axis_voffset\n\n    @axis_voffset.setter\n    def axis_voffset(self, value: float):\n        if isinstance(value, float):\n            self._axis_voffset = value\n        else:\n            raise TypeError(\"Expected axis voffset to be float!\")\n\n    @property\n    def v(self)-> float:\n        return self._axis_voffset\n    \n    @v.setter\n    def v(self, value: float)-> None:\n        self.axis_voffset = float(value)\n\n\n    @property\n    def axis_hoffset(self)-> float:\n        return self._axis_hoffset\n\n    @axis_hoffset.setter\n    def axis_hoffset(self, value:float):\n        if isinstance(value, float):\n            self._axis_hoffset = value\n        else:\n            raise TypeError(\"Expected axis hoffset to be float!\")\n\n    @property\n    def h(self)-> float:\n        return self._axis_hoffset\n    \n    @h.setter\n    def h(self, value: float)-> None:\n        self.axis_hoffset = float(value)\n    \n\n    @property\n    def dimensions(self)-> np.ndarray:\n        return self._dimensions\n    \n    @dimensions.setter\n    def dimensions(self, value:float):\n        \"\"\"\n        Sets the dimensions of the mirror.\n        The dimensions are specified as:\n        [length, width, height]\n\n        \"\"\"\n        self._dimensions = value\n\n    @property\n    def plane(self)-> Plane:\n        return self._plane\n\n    @plane.setter\n    def plane(self, value: Plane)-> None:\n        if isinstance(value, Plane):\n            self._plane = value\n        else:\n            raise TypeError(\"Expected value to be Plane instance!\")\n    \n    @property\n    def theta(self)-> float:\n        return self._theta\n    \n    @theta.setter\n    def theta(self, value: float)-> float:\n        self._theta = value\n    \n    @property\n    def corners(self)-> np.ndarray:\n        return self._corners\n    \n    @corners.setter\n    def corners(self, value):\n        print(\"Input value ignored, corners computed from parameters!\")\n        self.compute_corners()\n\n    @property\n    def borders(self)-> np.ndarray:\n        return self._borders\n    \n    @borders.setter\n    def borders(self, value)-> None:\n        \"\"\"\n        Sets the borders of the mirror.\n        The borders are specified as:\n        |-----------Top------------|\n        |                          |\n         Left   Mirror Plane       Right\n        |                          |       ---> +z direction\n        |----------Bottom----------|\n        [top, bottom, left, right]\n        \"\"\"\n        if isinstance(value, np.ndarray) and len(value)==4:\n            if all(value > 0):\n                self._borders = value\n            else:\n                raise ValueError(\"Lengths should be positive.\")\n        else:\n            raise ValueError(\"Expected 1D numpy array with length 4\")\n\n\n    def set_position(self, position: Point3D)-> None:\n        if isinstance(position, Point3D):\n            self._plane.position = position\n        else:\n            raise TypeError(\"Expected Point3D instance for position value!\")\n\n    def set_normal(self, normal: Vector3D)-> None:\n        if isinstance(normal, Vector3D):\n            self._plane.normal = normal\n        else:\n            raise TypeError(\"Expected Vector3D instance for normal value!\")\n\n    # Combine with setter\n    def set_dimensions(self, *args: np.ndarray | float)-> None:\n        \"\"\"\n        Set the dimensions of the mirror.\n\n        Parameters\n        ----------\n        *args : array_like\n            Either one or three arguments for the dimensions\n\n        Raises\n        ------\n        ValueError\n            If the number of arguments is not one or three\n\n        \"\"\"\n        # compute length once and assign to variable. Can use this in error msg.\n        # Will raise ValueError if args does not have length, so check that too.\n        length_of_args = len(args)\n        if length_of_args == 1:\n            self._dimensions = args[0]\n        elif length_of_args == 3:\n            self._dimensions = np.array(args)\n        else:\n            raise ValueError(f\"Expected either one or three arguments for dimensions, got length of {length_of_args} instead.\")\n\n    def set_offsets(self, voffset: float, hoffset: float, axis_voffset: float, axis_hoffset: float)-> None:\n        self.voffset(voffset)\n        self.hoffset(hoffset)\n        self.axis_voffset(axis_voffset)\n        self.axis_hoffset(axis_hoffset)\n\n    def compute_corners(self)-> np.ndarray:\n        \"\"\"\n        Compute the corners of the mirror in the global coordinate system,\n        in addition to the plane and normal of the mirror.\n    \n\n        Returns\n        -------\n        corners : np.ndarray\n            The corners of the mirror in the global coordinate system\n            [top left front,\n            top right front,\n            bottom left front,\n            bottom right front,\n            top left back,\n            top right back,\n            bottom left back,\n            bottom right back]\n        \n        \n        \"\"\"\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.theta)\n        theta_g = 90 - self._theta\n        theta_g = np.deg2rad(theta_g)\n        a = self._hoffset\n        c = self._voffset\n        v = self._axis_voffset\n        h = self._axis_hoffset\n        w = self._width()\n        l = self._length()\n        d = self._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n        tlf = Point3D(tlfx, tlfy, tlfz)\n\n        #Bottom left front\n        blfz = tlfz + d*np.cos(theta)\n        blfy = tlfy - d*np.sin(theta)        \n        blfx = -w/2\n        blf = Point3D(blfx, blfy, blfz)\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n        trf = Point3D(trfx, trfy, trfz)\n\n        #Bottom right front\n        brfz = blfz\n        brfy = blfy\n        brfx = w/2\n        brf = Point3D(brfx, brfy, brfz)\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n        tlb = Point3D(tlbx, tlby, tlbz)\n\n        #Bottom left back\n        blbz = tlbz + d*np.cos(theta)\n        blby = tlby - d*np.sin(theta)\n        blbx = -w/2\n        blb = Point3D(blbx, blby, blbz)\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        #Bottom right back\n        brbz = blbz\n        brby = blby\n        brbx = w/2\n        brb = Point3D(brbx, brby, brbz)\n\n        self._plane = Plane(tlf, trf, tlb)\n\n        self._corners = np.array([\n            tlf,\n            trf,\n            blf,\n            brf,\n            tlb,\n            trb,\n            blb,\n            brb\n        ])\n\n        return self._corners\n\n    @classmethod\n\n    def mirror_from_file(cls, filename: str)-> Plane_Mirror:\n        \"\"\"\n        Create a mirror from a file. \n        See config_pgm.ini for an example.\n        A config_file may contain more than one sections, but only the\n        mirror section will be read.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        mirror = cls()\n        mirror.read_file(filename)\n        return mirror\n\n    def reflect(self, *args: Ray3D | list) -> list:\n        \"\"\"\n        A method to reflect rays off the mirror.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be reflected\n\n        Returns\n        -------\n        reflected_rays : list of Ray3D\n            A list of reflected rays\n\n        \"\"\"\n        reflected_rays = []\n        \n        if len(args) == 0:\n            raise ValueError(\"Expected at least one ray\")\n        \n        if isinstance(args[0], list):\n            args = args[0]\n        \n\n        for index, ray in enumerate(args):\n            if not isinstance(ray, Ray3D):\n                raise TypeError(\"Expected Ray3D object\")\n            try:\n                _, plane_intersection = self._plane.intersectQ(ray)\n            except ValueError:\n                print(f'Ray of index {index} does not intersect mirror, tread with caution!')\n                continue\n            ray_array = ray.vector\n            mirror_normal = self._plane.normal\n            reflected_ray_array = ray_array - 2 * np.dot(ray_array, mirror_normal) * mirror_normal\n            reflected_ray_array = reflected_ray_array / np.linalg.norm(reflected_ray_array)\n            reflected_ray = Ray3D(plane_intersection, reflected_ray_array)\n            reflected_rays.append(reflected_ray)\n        \n        return reflected_rays\n", "type": "text"}, {"name": "pyplanemono_minimal\\elements\\pgm.py", "content": "from __future__ import annotations\nfrom matplotlib.axes import Axes\nimport numpy as np\nfrom matplotlib.patches import Patch \nimport configparser\nfrom pyplanemono_minimal.geometry import Point3D, Ray3D\nfrom scipy.spatial import ConvexHull\nfrom matplotlib.lines import Line2D\nfrom pyplanemono_minimal.elements import Plane_Mirror, Grating\n\nclass PGM(object):\n    \"\"\"\n    A class for a PGM setup.\n\n    Parameters\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n\n    Attributes\n    ----------\n    grating : Grating\n        The grating component of the PGM\n    mirror : Plane_Mirror\n        The mirror component of the PGM\n    rays : list\n        The rays to be propagated through the PGM\n    beam_offset : float\n        The vertical offset of the beam in mm\n    beam_width : float\n        The width of the beam in mm\n    beam_height : float\n        The height of the beam in mm\n    \n    Methods\n    -------\n    read_file(filename)\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n    propagate(*args)\n        Propagate rays through the PGM setup.\n    draw_sideview(ax)\n        Draws the setup on a y-z projection on a given axis.\n    draw_topview(ax)\n        Draws the setup on a x-z projection on a given axis, along with the beam footprints.\n    \"\"\"\n\n    def __init__(self, grating = None, mirror = None, **kwargs):\n        \"\"\"\n        \n        Constructor for the PGM class.\n        \n        Parameters\n        ----------\n        grating : Grating\n            The grating component of the PGM\n        mirror : Plane_Mirror\n            The mirror component of the PGM\n        **kwargs : \n            Keyword arguments for the grating and mirror components.\n            See Grating and Plane_Mirror classes for details.\n\n        \n        \"\"\"\n        # It's unclear what is happening here and there will be uncaught errors if kwargs is not as expected.\n        if grating is None:\n            grating_kwargs = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'grating_dimensions'\n            ]\n            grating_kwarg_keys = [\n                'line_density',\n                'energy',\n                'cff',\n                'order',\n                'dimensions'\n            ]\n        \n            grating_args = [kwargs.get(x) for x in grating_kwargs]\n            grating_kwargs = dict(zip(grating_kwarg_keys, grating_args))\n            self._grating = Grating(**grating_kwargs)\n\n        else:\n            self._grating = grating\n        \n        if mirror is None:\n            mirror_kwargs = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'mirror_dimensions',\n                'theta'\n            ]\n            mirror_kwarg_keys = [\n                'voffset',\n                'hoffset',\n                'axis_voffset',\n                'axis_hoffset',\n                'dimensions',\n                'theta'\n            ]\n        \n            mirror_args = [kwargs.get(x) for x in mirror_kwargs]\n            mirror_kwargs = dict(zip(mirror_kwarg_keys, mirror_args))\n            self._mirror = Plane_Mirror(**mirror_kwargs)\n            \n        else:\n            self._mirror = mirror\n\n        \n        self._rays = []\n        self._beam_offset = 13\n        self._beam_width = 6.43\n        self._beam_height = 5\n        self._energy = 2400\n\n    def __repr__(self):\n        return \"\"\"PGM(grating={}, \\nmirror={}, \\nb={},\\nbeam_width={},\\nbeam_height={})\"\"\".format(self.grating, \n                                                               self.mirror,\n                                                               self.beam_offset,\n                                                               self.beam_width,\n                                                               self.beam_height)\n    \n    def generate_rays(self):\n        \"\"\"\n        Generate rays for the PGM setup.\n        \"\"\"\n        \n        r0 = Ray3D(Point3D(0, self.beam_offset, -1000),\n                   Point3D(0, self.beam_offset, 0)-\n                   Point3D(0, self.beam_offset, -1000))\n        \n        r1 = Ray3D(Point3D(0, self.beam_offset + self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset + self.beam_height/2, 0)-\n                     Point3D(0, self.beam_offset + self.beam_height/2, -1000)\n                   )\n\n        r2 = Ray3D(Point3D(0, self.beam_offset - self.beam_height/2, -1000),\n                   Point3D(0, self.beam_offset - self.beam_height/2, 0) -\n                   Point3D(0, self.beam_offset - self.beam_height/2, -1000))\n\n        r3 = Ray3D(Point3D(-self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(-self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(-self.beam_width/2, self.beam_offset, -1000))\n\n        r4 = Ray3D(Point3D(self.beam_width/2, self.beam_offset, -1000),\n                   Point3D(self.beam_width/2, self.beam_offset, 0) -\n                   Point3D(self.beam_width/2, self.beam_offset, -1000))\n\n        self._rays = [r0, r1, r2, r3, r4]\n\n\n    def read_file(self, filename):\n        \"\"\"\n        Read PGM parameters from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        \n        self._grating.read_file(filename)\n        self._mirror.read_file(filename)\n        pgm_config = configparser.ConfigParser()\n        pgm_config.read(filename)\n        self._energy = float(pgm_config['beam']['energy'])\n        self._beam_offset = float(pgm_config['beam']['beam_offset'])\n        self._beam_width = float(pgm_config['beam']['beam_width'])\n        self._beam_height = float(pgm_config['beam']['beam_height'])\n    \n\n    def set_theta(self):\n        \"\"\"\n        Set the angle of the grating.\n        \"\"\"\n        self.mirror.theta = 0.5 * (self.grating.alpha-self.grating.beta)\n\n    @property\n\n    def theta(self):\n        return self.mirror.theta\n\n    @theta.setter\n\n    def theta(self, value):\n        self.theta = value\n        self.mirror.theta = value\n\n    @property\n\n    def energy(self):\n        return self.grating.energy\n    \n    @property\n    def wavelength(self):\n        return 1239.8419843320025/self.energy\n    \n    @energy.setter\n    # need validation for energy value, e.g. non-zero\n    def energy(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 0:\n            self.grating.energy = value\n        else:\n            print(value, type(value))\n            raise ValueError(\"Expected energy to be a positive float!\")\n    @property\n    def grating(self)-> Grating:\n        return self._grating\n    \n    @grating.setter\n    def grating(self, value: Grating)-> None:\n        if isinstance(value, Grating):\n            self._grating = value\n        else: \n            raise TypeError(\"Expected Grating instance for grating!\")\n    \n    @property\n    def mirror(self)-> Plane_Mirror:\n        return self._mirror\n    \n    @mirror.setter\n    def mirror(self, value: Plane_Mirror):\n        if isinstance(value, Plane_Mirror):\n            self._mirror = value\n        else:\n            raise TypeError(\"Expected Plane_Mirror instance for mirror!\")\n    @property\n    def rays(self)-> list[Ray3D]:\n        return self._rays\n    \n    @rays.setter\n    def rays(self, value: list[Ray3D])-> None:\n        self._rays = value\n    \n    @property\n    def beam_offset(self)-> float:\n        return -1*self._beam_offset\n    \n    @beam_offset.setter\n    def beam_offset(self, value: float)-> None:\n        if isinstance(value, (float, int)):\n            self._beam_offset = -1*value\n        else:\n            raise TypeError(\"Expected float for beam_offset!\")\n        \n    @property\n    def b(self)-> float:\n        return self._beam_offset\n    \n    @b.setter\n    def b(self, value: float)-> None:\n        self.beam_offset = value\n\n    @property\n    def beam_width(self)-> float:\n        return self._beam_width\n    \n    @beam_width.setter\n    def beam_width(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_width = value\n        else:\n            raise TypeError(\"Expected non-negative float for beam_width!\")\n    \n    @property\n    def beam_height(self)-> float:\n        return self._beam_height\n    \n    @beam_height.setter\n    def beam_height(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value >= 0:\n            self._beam_height = value\n        else:\n            raise ValueError(\"Expected non-negative float for beam_height!\")\n\n\n    @property\n    def mirror_intercept(self)-> Point3D:\n        return self._mirror_intercept\n    \n    @property\n    def grating_intercept(self)-> Point3D:\n        return self._grating_intercept\n    \n    \n    @property\n    def cff(self)-> float:\n        return self.grating.cff\n    \n    @cff.setter\n    def cff(self, value: float)-> None:\n        if isinstance(value, (float, int)) and value > 1:\n            self.grating.cff = value\n        else:\n            raise ValueError(\"Expected cff to be a positive float bigger than 1!\")\n\n    def values(self)-> dict:\n\n        dictionary = {'beam_vertical': self.beam_offset,\n                      'beam_width': self.beam_width,\n                      'beam_height': self.beam_height,\n                      'line_density': self.grating.line_density,\n                      'energy': self.grating.energy,\n                      'cff': self.grating.cff,\n                      'order': self.grating.order,\n                      'grating_dimensions': self.grating.dimensions,\n                      'grating.borders': self.grating.borders,\n                      'mirror_voffset': self.mirror.voffset,\n                      'mirror_hoffset': self.mirror.hoffset,\n                      'mirror_axis_voffset': self.mirror.axis_voffset,\n                      'mirror_axis_hoffset': self.mirror.axis_hoffset,\n                      'mirror_dimensions': self.mirror.dimensions,\n                      'mirror_theta': self.mirror.theta,\n                      'mirror_borders': self.mirror.borders}\n        return dictionary\n\n    @classmethod\n\n    def pgm_from_file(cls, filename:float)-> PGM:\n        \"\"\"\n        Create a PGM from a file. \n        See config_pgm.ini for an example.\n        The config file should contain a grating and a mirror section.\n\n        Parameters\n        ----------\n        filename : str\n            The name of the file to read from\n        \"\"\"\n        pgm = cls()\n        pgm.read_file(filename)\n        return pgm\n\n    def propagate(self, *args: Ray3D | list)-> tuple:\n        \"\"\"\n        Propagate rays through the PGM setup.\n\n        Parameters\n        ----------\n        *args : Ray3D\n            The rays to be propagated\n        \n        Returns\n        -------\n        grating_ray : list of Ray3D objects\n            A list of propagated rays originating at the grating intercept\n        \n        mirror_intercept : list of array_like\n            A list of the mirror intercepts\n\n        grating_intercept : list of array_like\n            A list of the grating intercepts\n\n        \"\"\"\n        _ = self._mirror.compute_corners()\n        _ = self._grating.compute_corners()\n\n        mirr_ray = self._mirror.reflect(*args)\n        grating_ray = self._grating.diffract(*mirr_ray)\n        mirror_intercept = [mirr_ray.position for mirr_ray in mirr_ray]\n        grating_intercept = [grating_ray.position for grating_ray in grating_ray]\n        \n        # _mirror_intercept and _grating_intercept not defined in __init__\n        self._mirror_intercept = mirror_intercept\n        self._grating_intercept = grating_intercept\n        return grating_ray, mirror_intercept, grating_intercept\n\n\n    def draw_sideview(self, ax: Axes):\n        \"\"\"\n        Draws the setup on a y-z projection on a given axis.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes\n            The axis to draw on\n\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        grating_corners = self.grating.compute_corners()\n        mirror_corners_y, mirror_corners_z = mirror_corners[::2,1], mirror_corners[::2,2]\n        mirror_corners_yz = np.array([mirror_corners_z, mirror_corners_y]).T\n        # ConvexHull sp?\n        # ConvelHull method used to ensure the entire region is filled regardless\n        # of point order.\n        hull_grating = ConvexHull(mirror_corners_yz)\n\n        grating_corners_y, grating_corners_z = grating_corners[::2,1], grating_corners[::2,2]\n        grating_corners_yz = np.array([grating_corners_z, grating_corners_y]).T\n        hull_mirror = ConvexHull(grating_corners_yz)\n\n        ax.fill(mirror_corners_yz[hull_mirror.vertices,0], mirror_corners_yz[hull_mirror.vertices,1], 'r')\n        ax.fill(grating_corners_yz[hull_grating.vertices,0], grating_corners_yz[hull_grating.vertices,1], 'b')\n\n        self.generate_rays()\n        grating_ray, mirror_int, grating_int = self.propagate(self.rays)\n        #print(\"Side view r3 int:\", mirror_int[3])\n        for index, ray in enumerate(grating_ray):\n            r_z = np.array([\n            self.rays[index].position.z,\n            mirror_int[index].z,\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            self.rays[index].position.y,\n            mirror_int[index].y,\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='green', linewidth=1, label='Dispersed Rays')\n            ax.add_line(line)\n        \n        zero_order_rays = self.grating.reflect(self.rays, zero_order=True)\n\n        \"\"\"\n        for index, ray in enumerate(zero_order_rays):\n            r_z = np.array([\n            grating_int[index].z,\n            grating_int[index].z + 1000*ray.vector[-1]\n            ])\n\n            r_x = np.array([\n            grating_int[index].y,\n            grating_int[index].y + 1000*ray.vector[-2]\n            ])\n\n            line = Line2D(r_z, r_x, color='gray', linewidth=1, label='Zero Order Reflections')\n            ax.add_line(line)\n        \"\"\"\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n        ]\n        ax.legend(handles=legend_entries, loc = 'lower right', fontsize=16, fancybox=True, shadow=True)\n        ax.axhline(y=0, color='black', linestyle='--', linewidth=1.3)\n        ax.axvline(x=0, color='black', linestyle='--', linewidth=1.3)\n        \n    def draw_topview(self, ax: Axes)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        \n        self.generate_rays()\n        \n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        _, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        _, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        _, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        _, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n        #print(\"Mirror footprint width:\", mirror_footprint_width)\n       # print(\"Mirror footprint height:\", mirror_footprint_height)\n        #print(\"Grating footprint width:\", grating_footprint_width)\n       # print(\"Grating footprint height:\", grating_footprint_height)\n        \n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        ax.fill(mirror_corners[:,0], mirror_corners[:,1], 'r',alpha=1, label='Mirror')\n        ax.fill(grating_corners[:,0], grating_corners[:,1], 'b',alpha=0.5, label='Grating')\n        ax.fill(mirr_footprint_corners[:,0], mirr_footprint_corners[:,1], c='black')\n        ax.fill(grating_footprint_corners[:,0], grating_footprint_corners[:,1], c='green')\n        ax.grid(axis='both', which='both', alpha = 0.5)\n        ax.set_xticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xticks(np.arange(-1000, 1000, 100), minor=False)\n        ax.set_yticks(np.arange(-1000, 1000, 10), minor=True)\n        ax.set_xlim(min(mirror_corners[:,0]), max(grating_corners[:,0]))\n        ax.set_ylim(min(mirror_corners[:,1]), max(grating_corners[:,1]))\n        #ax.fill(mirror_rect_borders[:,0], mirror_rect_borders[:,1], 'r',alpha=0.5)\n        #ax.fill(m_corners[:,] , 'r',alpha=1)\n        #x.fill(grating_rect_borders[:,0], grating_rect_borders[:,1], 'b',alpha=1)\n        #ax.fill(grating_rect[:,0], grating_rect[:,1], 'b',alpha=0.5, label='Grating')\n        #ax.fill([mirror_blz, mirror_blz + mirror_l, mirror_blz + mirror_l, mirror_blz], [mirror_blx, mirror_blx, mirror_blx + mirror_w, mirror_blx + mirror_w], 'g', alpha=0.5, label='Beam Footprint')\n        #ax.fill([grating_blz, grating_blz + grating_l, grating_blz + grating_l, grating_blz], [grating_blx, grating_blx, grating_blx + grating_w, grating_blx + grating_w], 'g', alpha=0.5)\n        legend_entries = [\n            Patch(facecolor=(1,0,0,1), edgecolor=(1,0,0,0.3), label='Mirror'),\n            Patch(facecolor=(0,0,1,1), edgecolor=(0,0,1,0.3), label='Grating'),\n            Patch(facecolor=(0,0,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Mirror): {mirror_footprint_width:.2f} mm x {mirror_footprint_height:.2f} mm'),\n            Patch(facecolor=(0,1,0,1), edgecolor=(0,1,0,0.3), label=rf'Beam Footprint (Grating): {grating_footprint_width:.2f} mm x {grating_footprint_height:.2f} mm')\n\n        ]\n\n        ax.legend(handles=legend_entries, loc = 'upper left', fontsize=12, fancybox=True, shadow=True)\n\n\n    def topview_trace(self)-> None:\n        \"\"\"\n        Draws the top-view (x-z projection) of the setup on the current\n        axes.\n\n        \"\"\"\n\n        m_corners = self.mirror_corners()\n        g_corners = self.grating_corners()\n        m_corners = np.array(m_corners)\n        # use your _width and _length setters\n        \n        self.generate_rays()\n        \n        # _, mirror_intercept, grating_intercept\n        grating_corners = np.array(self.grating_corners())\n        mirror_corners = np.array(self.mirror_corners())\n        grating_ray, mirror_int_1, grating_int_1 =  self.propagate(self.rays[1])\n        grating_ray, mirror_int_2, grating_int_2 =  self.propagate(self.rays[2])\n        grating_ray, mirror_int_3, grating_int_3 =  self.propagate(self.rays[3])\n        grating_ray, mirror_int_4, grating_int_4 =  self.propagate(self.rays[4])\n\n        mirror_intercepts = [\n            mirror_int_1[0].to_point(),\n            mirror_int_2[0].to_point(),\n            mirror_int_3[0].to_point(),\n            mirror_int_4[0].to_point()\n        ]\n\n        grating_intercepts = [\n            grating_int_1[0].to_point(),\n            grating_int_2[0].to_point(),\n            grating_int_3[0].to_point(),\n            grating_int_4[0].to_point()\n        ]\n\n        mirror_footprint_width, mirror_footprint_height = self.calc_footprint_size(mirror_intercepts)\n        grating_footprint_width, grating_footprint_height = self.calc_footprint_size(grating_intercepts)\n\n        mirr_footprint_corners = np.array([\n            [mirror_int_2[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_3[0].x],\n            [mirror_int_1[0].z, mirror_int_4[0].x],\n            [mirror_int_2[0].z, mirror_int_4[0].x]\n        ])\n\n        grating_footprint_corners = np.array([\n            [grating_int_2[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_3[0].x],\n            [grating_int_1[0].z, grating_int_4[0].x],\n            [grating_int_2[0].z, grating_int_4[0].x]\n        ])\n\n        offset = 0.5*(self.mirror._width() + self.grating._width())* np.array([\n            [0,1],\n            [0,1],\n            [0,1],\n            [0,1]\n        ])\n\n        grating_corners = grating_corners + offset\n        grating_footprint_corners = grating_footprint_corners + offset\n\n        return mirror_intercepts, grating_intercepts\n        \n\n    def calc_footprint_size(self, intercepts: list[Point3D])-> tuple:\n        \"\"\"\n        Calculate the size of the footprint of the beam on the grating or the mirror\n        when given the intercepts of the beam with the grating or the mirror.\n         \n        \n        Parameters\n        ----------\n        intercepts : list of Point3D objects\n            The intercepts of the beam with the grating or the mirror\n            [r_1, r_2, r_3, r_4]\n\n        Returns\n        -------\n        size : tuple\n            The size of the footprint of the beam on the grating or the mirror in mm\n        \"\"\"\n\n        r_1, r_2, r_3, r_4 = intercepts\n    \n        width = r_1.distance(r_2)\n        height = r_3.distance(r_4)\n\n        return width, height\n\n\n    def centre_of_footprint(self):\n        \"\"\"\n        Calculate the centre of the footprint of the beam on the grating or the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the footprint of the beam on the grating or the mirror\n        \"\"\"\n        _, mirror_int_0, grating_int_0 =  self.propagate(self.rays[0])\n\n        return mirror_int_0, grating_int_0\n        \n    def find_offset(self):\n\n        mirror_int, grating_int = self.centre_of_footprint()\n        mirror_int = mirror_int[0]\n        grating_int = grating_int[0]\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        #print(mirror_corners)\n        centre_of_mirror_top = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        #print([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]])\n        #print(centre_of_mirror_top)\n        mirror_offset =  np.array([mirror_int.x, mirror_int.y, mirror_int.z]) - centre_of_mirror_top\n        #print(mirror_offset)\n        mirror_offset = np.linalg.norm(mirror_offset) * mirror_offset[1]/np.abs(mirror_offset[1])\n\n        grating_offset = np.linalg.norm(grating_int) * grating_int[1]/np.abs(grating_int[1])\n        return mirror_offset, grating_offset\n    \n    def centre_of_mirror(self):\n        \"\"\"\n        Calculate the centre of the mirror.\n        \n        Returns\n        -------\n        centre : Point3D\n            The centre of the mirror\n        \"\"\"\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners = np.array(mirror_corners)\n        centre_of_mirror = np.mean([mirror_corners[0], mirror_corners[1], mirror_corners[4], mirror_corners[5]], axis=0)\n        return centre_of_mirror\n\n\n    def mirror_corners(self)-> tuple:\n\n        cot = lambda x: 1/np.tan(x)\n        theta = np.deg2rad(self.mirror.theta)\n        theta_g = 90 - self.theta\n        theta_g = np.deg2rad(theta_g)\n        a = self.mirror._hoffset\n        c = self.mirror._voffset\n        v = self.mirror._axis_voffset\n        h = self.mirror._axis_hoffset\n\n        w = self.mirror._width()\n        l = self.mirror._length()\n        d = self.mirror._height()\n        #Top left front\n\n        tlfz = -((a - c * cot(theta)) * np.sin(theta)) + h\n        tlfy = -(c / np.sin(theta) + \n                 (a - c*cot(theta)) * np.cos(theta)) + v\n        tlfx = -w/2\n\n        #Top right front\n        trfz = tlfz\n        trfy = tlfy\n        trfx = w/2\n\n        #Top left back\n        tlbz = tlfz - l*np.sin(theta)\n        tlby = tlfy - l*np.cos(theta)\n        tlbx = -w/2\n\n        #Top right back\n        trbz = tlbz\n        trby = tlby\n        trbx = w/2\n        trb = Point3D(trbx, trby, trbz)\n\n        return ((tlfz, tlfx), (trfz, trfx), (trbz, trbx), (tlbz, tlbx))\n\n    def grating_corners(self)-> tuple:\n        \n        l = self.grating._length()\n        w = self.grating._width()\n        beta = self.grating.beta\n        \n        beta_g = 90 + beta\n        beta_rad = beta_g*np.pi/180\n\n        blbz = -(l/2)*np.cos(beta_rad)\n        blbx = -w/2\n\n        brbz = -(l/2)*np.cos(beta_rad)\n        brbx = w/2\n\n        blfz = (l/2)*np.cos(beta_rad)\n        blfx = -w/2\n\n        brfz = (l/2)*np.cos(beta_rad)\n        brfx = w/2\n\n        return ((blbz, blbx), (brbz, brbx), (brfz, brfx), (blfz, blfx))\n    \n    def corners(self)-> tuple[dict]:\n        \"\"\"\n        Calculate the corners of the mirror and grating.\n        \n        Returns\n        -------\n        corners : dict\n            The corners of the grating and mirror in the following order:\n            bottom left back, bottom right back, bottom left front, bottom right front,\n            top left back, top right back, top left front, top right front\n        \"\"\"\n        positions = [\n            \"bottom left back\",\n            \"bottom right back\",\n            \"bottom left front\",\n            \"bottom right front\",\n            \"top left back\",\n            \"top right back\",\n            \"top left front\",\n            \"top right front\"\n        ]\n        grating_corners = self.grating.compute_corners()\n        grating_corners_dict = dict(zip(positions, grating_corners))\n        mirror_corners = self.mirror.compute_corners()\n        mirror_corners_dict = dict(zip(positions, mirror_corners))\n\n        return grating_corners_dict, mirror_corners_dict\n            \n\n    @staticmethod\n    def undulator_size():\n        pass\n", "type": "text"}]